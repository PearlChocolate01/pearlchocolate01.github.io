<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统概述 | 珍珠巧克力</title><meta name="author" content="Zong Yi"><meta name="copyright" content="Zong Yi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="description" content="定义1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。 1.2 线程：线程是进程中的一个实体，是处理器调度和分派的基本单位。可与同属一个进程的其他线程共享进程所拥有的全部资源。 1.3 原语：原语是由若干条指令所组成的一个指令序列。用来实现某个特定的操作功能。具有连续性，不可分割性。在执行时也不可间断，必须在管态下执行，并且常驻内存。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统概述">
<meta property="og:url" content="https://pearlchocolatezy.com/2024/09/26/LearnOS/index.html">
<meta property="og:site_name" content="珍珠巧克力">
<meta property="og:description" content="定义1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。 1.2 线程：线程是进程中的一个实体，是处理器调度和分派的基本单位。可与同属一个进程的其他线程共享进程所拥有的全部资源。 1.3 原语：原语是由若干条指令所组成的一个指令序列。用来实现某个特定的操作功能。具有连续性，不可分割性。在执行时也不可间断，必须在管态下执行，并且常驻内存。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pearlchocolatezy.com/img/bg_os.png">
<meta property="article:published_time" content="2024-09-26T14:40:51.000Z">
<meta property="article:modified_time" content="2025-06-08T07:59:05.348Z">
<meta property="article:author" content="Zong Yi">
<meta property="article:tag" content="X2080901">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pearlchocolatezy.com/img/bg_os.png"><link rel="shortcut icon" href="/img/touxiang_yuki_small.png"><link rel="canonical" href="https://pearlchocolatezy.com/2024/09/26/LearnOS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统概述',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-06-08 15:59:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transparency.css"><link rel="stylesheet" href="/css/zy.css"><script type="text/javascript" src="/js/jquery-3.6.3.min.js"></script><script type="text/javascript" src="/js/zy.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="珍珠巧克力" type="application/rss+xml">
</head><body><link rel="stylesheet" href="/css/loading-bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang_yuki.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"><i class="fa-fw fas fa-laptop"></i><span> 计算机</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%AE%B0/"><i class="fa-fw fa fa-book"></i><span> 日记</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E5%AD%A6/"><i class="fa-fw fas fa-infinity"></i><span> 数学</span></a></li><li><a class="site-page child" href="/categories/%E8%B4%A2%E4%BC%9A/"><i class="fa-fw far fa-chart-bar"></i><span> 财会</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/lab/"><i class="fa-fw fa-solid fa-keyboard"></i><span> 实验室</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tree"></i><span> 收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书架</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 影院</span></a></li><li><a class="site-page child" href="/tvdrama/"><i class="fa-fw fa fa-video-camera"></i><span> 剧集</span></a></li><li><a class="site-page child" href="/animation/"><i class="fa-fw fas fa-candy-cane"></i><span> 追番</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-dog"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/chat/"><i class="fa-fw fa fa-leaf"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg_os.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">珍珠巧克力</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"><i class="fa-fw fas fa-laptop"></i><span> 计算机</span></a></li><li><a class="site-page child" href="/categories/%E6%97%A5%E8%AE%B0/"><i class="fa-fw fa fa-book"></i><span> 日记</span></a></li><li><a class="site-page child" href="/categories/%E6%95%B0%E5%AD%A6/"><i class="fa-fw fas fa-infinity"></i><span> 数学</span></a></li><li><a class="site-page child" href="/categories/%E8%B4%A2%E4%BC%9A/"><i class="fa-fw far fa-chart-bar"></i><span> 财会</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/lab/"><i class="fa-fw fa-solid fa-keyboard"></i><span> 实验室</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tree"></i><span> 收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书架</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 影院</span></a></li><li><a class="site-page child" href="/tvdrama/"><i class="fa-fw fa fa-video-camera"></i><span> 剧集</span></a></li><li><a class="site-page child" href="/animation/"><i class="fa-fw fas fa-candy-cane"></i><span> 追番</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-dog"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/chat/"><i class="fa-fw fa fa-leaf"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-26T14:40:51.000Z" title="发表于 2024-09-26 22:40:51">2024-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T07:59:05.348Z" title="更新于 2025-06-08 15:59:05">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统概述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p>
<p>1.2 线程：线程是进程中的一个实体，是处理器调度和分派的基本单位。可与同属一个进程的其他线程共享进程所拥有的全部资源。</p>
<p>1.3 原语：原语是由若干条指令所组成的一个指令序列。用来实现某个特定的操作功能。具有连续性，不可分割性。在执行时也不可间断，必须在管态下执行，并且常驻内存。</p>
<p>1.4 创建原语：是指创建一个新的进程，前者称为父进程，后者称为子进程建立进程控制块PCB。</p>
<p>1.5 DMA (Direct Memory Access)：直接内存访问，是一种完全由硬件执行I/O数据交换的工作方式。</p>
<p>1.6 通道：通道是一个特殊功能的处理器，它有自己的指令和程序，可以实现对外部设备的统一管理和外部设备与内存之间的数据传送。</p>
<p>1.7 SPOOLING (Simultaneous Peripheral Operations On-Line)：外部设备联机并行操作(虚拟设备技术)。它是关于慢速字符设备如何与计算机主机交换信息一种技术，通常称为“假脱机技术”。是多道程序设计系统中处理独占I/O设备的一种方法，能将独占设备转变为共享设备，可以提高设备利用率并缩短单个程序的响应时间。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 计算机系统的资源包括两大类：硬件资源和软件资源。</p>
<p>2.2 操作系统的两大发展方向：宏观应用、微观应用。</p>
<p>2.3 操作系统启动的引导方式：BIOS引导，UEFI引导。</p>
<p>2.4 操作系统的启动过程：BIOS自检、系统引导、启动内核、初始化系统。</p>
<p>2.5 操作系统管理程序运行的状态称为<font color="purple">管态</font>。<br>系统启动时，处理器的初始状态为管态。<br>当处理器处于管态时，可以执行全部指令。<br>当用户程序占用处理器时，应让处理器在<font color="purple">目态</font>下工作。</p>
<p>2.6 处理器的状态字（PSW）通常包含以下状态代码：(1)CPU的工作状态代码；(2)条件码；(3)中断屏蔽码。</p>
<p>2.7 所有的子系统都可以包括在<font color="purple">硬件（子）系统</font>和<font color="purple">软件（子）系统</font>。</p>
<p>2.8 系统软件包括：操作系统、编译系统、数据库。</p>
<p>2.9 硬件系统：中央处理器、存储系统、中断机制、I/O技术、时钟。</p>
<p>2.10 内存空间的最小分配单位为<font color="purple">块</font>，这样的块有时被称为一个物理页(Page)。</p>
<p>2.11 时钟中断处理程序的主要内容：(1)维护软件时钟；(2)处理器调度；(3)控制系统定时任务；(4)实时处理。</p>
<p>2.12 允许优先级较高的中断打断优先级较低的中断处理过程称为<font color="purple">中断嵌套</font>。</p>
<p>2.13 时钟分为<font color="purple">硬件时钟</font>和<font color="purple">软件时钟</font>。</p>
<p>2.14 <font color="purple">系统调用</font>是操作系统提供给编程人员的唯一接口。</p>
<p>2.15 进程从运行状态进入就绪状态的原因可能是：时间片用完。</p>
<p>2.16 七状态模型和五状态模型相比，增加了<font color="purple">就绪挂起</font>和<font color="purple">阻塞挂起</font>两个状态。</p>
<p>2.17 操作系统把所有的PCB用适当方式组织起来。一般的组织方式：线性方式、索引方式、链接方式。</p>
<p>2.18 同一个进程中的各个线程共享该进程的内存地址空间。</p>
<p>2.19 对进程在整个生命周期中各种状态之间的转换进行有效的控制通过<font color="purple">进程控制原语</font>来实现。</p>
<p>2.20 <font color="purple">线程</font>作为调度和分派的基本单位，<font color="purple">进程</font>作为资源拥有的基本单位。</p>
<p>2.21 线程的实现机制：用户级线程、内核级线程、混合方式。</p>
<p>2.22 CPU主要的两级调度：进程调度、作业调度。</p>
<p>2.23 <font color="purple">时间片轮转法</font>主要用于分时系统中的进程调度。</p>
<p>2.24 <font color="purple">保证调度算法</font>的目标是保证每个进程享用CPU的时间完全一样，即如果系统里一共有n个进程，则每个进程占用CPU的时间为<font color="purple">1/n</font>。</p>
<p>2.25 <font color="purple">彩票调度算法</font>是一种概率调度算法。</p>
<p>2.26 基于进程组的调度决策是非常有吸引力的，该方法通常称作<font color="purple">公平共享调度</font>。</p>
<p>2.27 BSD UNIX系统主要用于<font color="purple">分时交互</font>环境中。</p>
<p>2.28 Linux系统的调度方式基本上采用<font color="purple">抢占式优先级</font>方式。</p>
<p>2.29 Windows中的优先级被组织成两段：<font color="purple">实时</font>和<font color="purple">可变</font>。</p>
<p>2.30 任何情况下，都可以把系统看作是<font color="purple">多服务器排队</font>结构。</p>
<p>2.31 线程调度常用方法有：加载共享、组调度、专用处理器分配、动态调度。</p>
<p>2.32 为周期性任务解决多任务调度冲突的一个非常好的方法是<font color="purple">速率单调调度RMS</font>。</p>
<p>2.33 <font color="purple">优先级逆转</font>是在任何基于优先级的可抢占的调度方案中都能发生的一种现象，但是它与实时调度的上下文关联特别大。</p>
<p>2.34 <font color="purple">优先级继承协议</font>的基本思想是优先级较低的任务继承任何与它共享同一个资源的优先级较高的任务的优先级。</p>
<p>2.35 采用动态重定位的系统支持“程序浮动”。</p>
<p>2.36 存储管理的主要任务包括：内存的分配与回收、内存扩充、存储共享、存储保护。</p>
<p>2.37 在存储管理中，将绝对地址对应的存储空间称为<font color="purple">物理地址空间</font>，将逻辑地址对应的存储空间称为<font color="purple">逻辑地址空间</font>。</p>
<p>2.38 通过分区管理，内存真正成为了共享资源，提高了系统得到吞吐量和缩短了周转时间。</p>
<p>2.39 在可变区分存储管理方案中，解决碎片问题的一个有效办法是采用<font color="purple">紧缩技术</font>，通过移动内存中程序，把<font color="purple">所有空闲碎片</font>的合并成一个连续的大空闲区，置于内存的一端，把<font color="purple">所有程序占用区</font>的放在内存的另一端。</p>
<p>2.40 采用页式存储管理的主要目的是：提高内存的利用率。</p>
<p>2.41 大多数操作系统采用的进程页表是二级页表：即由页表页和页目录一起构成进程页表。</p>
<p>2.42 分页后，逻辑地址由两部分组成：虚拟页号，页内地址。</p>
<p>2.43 流式文件是有序字符的集合。</p>
<p>2.44 常用的文件物理结构：索引结构、链接结构、顺序结构。</p>
<p>2.45 文件按组织形式进行分类：普通文件、目录文件、特殊文件。<br>文件按文件用途进行分类：库函数文件、用户文件。</p>
<p>2.46 文件常用的存取方法：顺序存取、随机存取。</p>
<p>2.47 链式结构，有利于文件动态扩充，解决了存储的碎片问题，但不适合随机存取。</p>
<p>2.48 磁盘空间的分配与回收算法：位示图、空闲块表、空闲块链表。</p>
<p>2.49 把若干个逻辑记录合成一组，存入一个物理块的工作称为<font color="purple">记录的成组</font>。</p>
<p>2.50 记录的成组和分解技术是磁盘高速缓存的一种应用，虽然需要代价，但是具有提高<font color="purple">存储空间利用率</font>和减少<font color="purple">启动设备次数</font>的优点。</p>
<p>2.51 用来解决磁盘速度慢、出现故障的技术是<font color="purple">RAID技术</font>。</p>
<p>2.52 RAID2和RAID3以<font color="purple">位</font>或<font color="purple">字节</font>作为并行单位。</p>
<p>2.53 规定用户使用文件的权限的方法：<font color="purple">树形目录结构</font>、<font color="purple">存取控制表</font>。</p>
<p>2.54 UNIX的文件使用权限管理方案中，对文件存取权限的设置方法：<font color="purple">存取控制矩阵</font>和<font color="purple">二级存取控制</font>。</p>
<p>2.55 按设备的使用特性分类：（1）输入设备；（2）输出设备；（3）交互式设备；（4）存储设备。</p>
<p>2.56 设备驱动程序是操作系统底层中唯一知道各种输入输出设备的控制器细节以及其用途的部分。</p>
<p>2.57 设计I/O软件的一个最关键目标是设备独立性。</p>
<p>2.58 键盘、终端、打印机等以<font color="purple">字符</font>为单位组织好处理信息的设备。</p>
<p>2.59 I/O硬件由<font color="purple">物理设备</font>和<font color="purple">电子部件</font>两部分组成。</p>
<p>2.60 在典型的计算机系统硬件结构中，CPU与内存在最里层，通过总线与第二层的<font color="purple">适配器（接口）</font>部件相连，第三层是<font color="purple">各种外围设备控制器</font>，最外层是外围设备。</p>
<p>2.61 从功能上看，<font color="purple">设备独立层</font>是I/O软件的主要部分；<br>从代码量上看，<font color="purple">设备驱动层</font>是I/O软件的主要部分。</p>
<p>2.62 I/O设备管理中，可按照两种方式进行设备分配：<font color="purple">静态分配</font>和<font color="purple">动态分配</font>。</p>
<p>2.63 两种常用设备分配策略：先来先服务、高优先级优先。</p>
<p>2.64 设备分配表由<font color="purple">设备类表</font>和<font color="purple">设备表</font>组成。</p>
<p>2.65 常用的磁盘移臂调度算法：先来先服务调度算法、最短寻找时间优先调度算法、电梯调度算法、单向扫描调度算法。</p>
<p>2.66 缓冲出把多个缓冲区连接起来统一管理。</p>
<p>2.67 SPOOLING系统主要包括：输入程序模块、输出程序模块、作业调度程序。</p>
<p>2.68 Dijkstra把同步问题抽象成一种<font color="purple">生产者-消费者关系</font>。</p>
<p>2.69 对信号量的PV操作在程序流程上必定是成对出现，不能缺少，缺少了会<font color="purple">死锁</font>。</p>
<p>2.70 剥夺资源的常用方法：（1）还原算法，即恢复计算结果和状态；（2）建立检查点，用来恢复分配前的状态。</p>
<p>2.71 死锁产生的必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。</p>
<p>2.72 <font color="purple">哲学家就餐问题</font>是操作系统中关于进程同步与互斥的经典问题，也是涉及到<font color="purple">死锁</font>的关键问题。<br>在哲学家就餐问题中，为每只筷子设置一个信号量，一个哲学家通过在信号量上执行操作<font color="purple">P</font>抓起一只筷子，通过执行<font color="purple">V</font>操作放下一只筷子。</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 操作系统的特性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 并发：在计算机系统中同时存在多个程序，宏观上，这些程序是在同时执行的；微观上，任何时刻只有一个程序在执行，即微观上这些程序在CPU上轮流执行。</span><br><span class="line">2. 共享：操作系统与多个用户的程序共同使用计算机系统中的资源。</span><br><span class="line">3. 虚拟性：虚拟性是一种管理技术，该技术把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物。</span><br><span class="line">4. 异步性：操作系统必须随时对不可预测的次序发生的事件进行响应。</span><br></pre></td></tr></table></figure></p>
<p>3.2 操作系统的主要功能：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理机管理功能：进程控制，进程同步，进程通信，调度。</span><br><span class="line">2. 存储器管理功能：内存分配，内存保护，地址映射，内存扩充。</span><br><span class="line">3. 设备管理功能：缓冲管理，设备分配，设备处理。</span><br><span class="line">4. 文件管理功能：文件存储空间的管理，目录管理，文件的读写管理和保护。</span><br><span class="line">5. 用户接口：命令接口，程序接口，图形接口。</span><br></pre></td></tr></table></figure></p>
<p>3.3 微内核结构及其基本原理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 微内核OS结构：能实现OS核心功能的小型内核。并非一个完整的OS，与OS的服务进程（如文件服务器、作业服务器等）共同构成OS。</span><br><span class="line">2. 基本原理：只有最基本的操作系统功能才能放在内核中。不是最基本的服务和应用程序在微内核之上构造，并在用户模式下执行。</span><br><span class="line">3. 微内核通常提供最小的进程和内存管理以及通信功能。微内核的主要功能是提供客户程序和运行在用户空间的各种服务之间进行通信的能力。通信以消息传递形式提供，一般采用客户/服务器模式。</span><br></pre></td></tr></table></figure></p>
<p>3.4 最常见的控制和状态寄存器：（了解）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 程序计数器（PC:Program Counter）：记录了将要取出的指令的地址。</span><br><span class="line">2. 指令寄存器（IR:Instruction Register）：包含了最近取出的指令。</span><br><span class="line">3. 程序状态字（PSW:Program Status Word）：记录了处理器的运行模式信息等。</span><br></pre></td></tr></table></figure></p>
<p>3.5 系统软件包括哪些软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统软件包括：系统软件、支撑软件、应用软件。</span><br><span class="line">系统软件：操作系统、编译系统。</span><br><span class="line">支撑软件：数据库、各种接口软件、软件开发工具等。</span><br><span class="line">应用软件：财务管理、人口普查等专用程序。</span><br></pre></td></tr></table></figure></p>
<p>3.6 简述指令的执行过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 每个取值周期先从存储器中读取一条指令。</span><br><span class="line">2. 在取指令完成后，根据指令类别将程序计数器的值变成下一条指令的地址，通常是自增1。</span><br><span class="line">3. 取到的指令被放在处理器的指令寄存器中。</span><br><span class="line">4. 处理器解释并执行命令。</span><br></pre></td></tr></table></figure></p>
<p>3.7 简述指令的分类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 访问存储器指令：负责处理器和存储器之间的数据传送。</span><br><span class="line">2. I/O指令：负责处理器和I/O模块之间的数据传送和命令发送。</span><br><span class="line">3. 算术逻辑指令（数据处理指令）：用以执行有关数据的算术和逻辑操作。</span><br><span class="line">4. 控制转移指令：这种指令可以指定一个新的指令的执行起点。</span><br><span class="line">5. 处理器控制指令：这种指令用于修改处理器状态，改变处理器工作方式。</span><br></pre></td></tr></table></figure></p>
<p>3.8 现代计算机采用的多级存储体系包括哪几部分？简述各部分功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多级存储体系包括寄存器、主存储器、高速缓冲存储器、辅助存储器。</span><br><span class="line">2. 寄存器用来存放处理器的工作信息。</span><br><span class="line">3. 主存储器用来存放当前要执行的程序和数据。</span><br><span class="line">4. 高速缓冲存储器用来存放当前经常要使用的信息。</span><br><span class="line">5. 辅助存储器作为主存储器的扩展，用来存放大量的程序和数据。</span><br></pre></td></tr></table></figure></p>
<p>3.9 中断响应是什么？中断处理程序主要工作有哪些方面？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器每执行完一条指令后，中断装置立即检查有无中断事件发生。</span><br><span class="line">2. 若有中断事件发生，则暂停现行进程的执行，而让操作系统的中断处理程序占用处理器。中断处理程序主要工作如下：</span><br><span class="line">(1) 保护被中断进程的现场信息；(2)分析中断原因；(3)处理发生的中断事件。</span><br></pre></td></tr></table></figure></p>
<p>3.10 简述通道的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 当处理器执行到一条“启动外设”指令时，就按指令中给定的参数启动指定的设备。</span><br><span class="line">2. 设备启动后，对该外部设备的控制权转移到通道。</span><br><span class="line">3. 该外部设备与主存储器之间发生的信息传送，由通道控制。</span><br><span class="line">4. 该外部设备工作结束后，会产生形成一个“输入输出操作结束”的I/O中断事件。</span><br></pre></td></tr></table></figure></p>
<p>3.11 简述时钟的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件时钟的工作原理：电路中的晶体振荡器，每隔一定间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加1的工作。</span><br><span class="line">2. 软件时钟的工作原理：利用内存单元模拟时钟寄存器，采用一段程序来计算响应的脉冲数，对内存时钟寄存器进行加1或减1的工作。</span><br></pre></td></tr></table></figure></p>
<p>3.12 简述时钟的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在多道程序运行，时钟可以发现死循环，防止机时的浪费。</span><br><span class="line">2. 在分时系统中，用时钟实现时间片轮转运行。</span><br><span class="line">3. 在实时系统中，按要求的时间间隔输出信号控制设备。</span><br><span class="line">4. 定时唤醒外部事件。</span><br><span class="line">5. 记录用户和系统所需要的绝对事件，即年、月、日。</span><br></pre></td></tr></table></figure></p>
<p>3.13 简述系统调用的分离<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个操作系统的功能分为两大部分：一部分是系统自身所需要的，另一部分功能是作为服务提供给用户的，有关这部分功能可以从操作系统所提供的系统调用上体现出来。</span><br><span class="line">1. 进程控制类系统调用。</span><br><span class="line">2. 文件操作类系统调用。</span><br><span class="line">3. 进程通信类系统调用。</span><br><span class="line">4. 设备管理类系统调用。</span><br><span class="line">5. 信息维护类系统调用。</span><br></pre></td></tr></table></figure></p>
<p>3.14 在七状态模型中，什么是阻塞状态？什么是阻塞挂起状态？两个状态之间如何转换<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 阻塞状态：进程在内存并等待某事件的出现。</span><br><span class="line">2. 阻塞挂起状态：进程在外存并等待某事件的出现。</span><br><span class="line">3. 没有进程处于就绪状态或就绪进程要求更多内存资源时，就会把阻塞状态编程阻塞挂起状态。</span><br><span class="line">4. 当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程激活，由阻塞挂起状态变成阻塞状态。</span><br></pre></td></tr></table></figure></p>
<p>3.15 进程具有哪些特性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 并发性：一个进程可以同其他进程一道向前推进。</span><br><span class="line">2. 动态性：进程有其生命周期，且进程的状态是不断变化的。</span><br><span class="line">3. 独立性：一个进程是一个相对完整的资源分配单位。</span><br><span class="line">4. 交往性：一个进程在运行过程中可能会与其他进程发生直接的或间接的相互作用。</span><br><span class="line">5. 异步性：每个进程按照各自独立的、不可预知的速度向前推进。</span><br><span class="line">6. 结构性：一个进程由程序、数据和进程控制块三部分组成。</span><br></pre></td></tr></table></figure></p>
<p>3.16 线程与进程的关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 线程是进程中可独立执行的子任务。</span><br><span class="line">2. 一个进程中可以有一个活多个线程。</span><br><span class="line">3. 同一进程中的各线程共享分配给进程的主存空间。</span><br><span class="line">4. 进程是资源分配单位，线程是调度和执行单位。</span><br><span class="line">5. 一个进程内的线程共享分配给该进程的资源。</span><br></pre></td></tr></table></figure></p>
<p>3.17 进程调度的主要功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 保存现场：记录系统中所有进程得到执行状况。</span><br><span class="line">2. 挑选进程：根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它。</span><br><span class="line">3. 恢复现场：为选中的进程恢复现场信息。</span><br></pre></td></tr></table></figure></p>
<p>3.18 在选择调度策略时应该考虑什么因素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 设计目标</span><br><span class="line">2. 公平性</span><br><span class="line">3. 均衡性</span><br><span class="line">4. 统筹兼顾</span><br><span class="line">5. 优先级</span><br><span class="line">6. 开销</span><br></pre></td></tr></table></figure></p>
<p>3.19 进程最短剩余时间优先调度算法的基本思路和实现方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最短进程优先算法的抢占版本是最短剩余时间优先(SRTN)算法。</span><br><span class="line">使用这个算法，调度程序总是选择其剩余运行时间最短的那个进程运行。</span><br><span class="line">当一个新的进程到达时，其整个时间同当前进程的剩余时间作比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短进程获得良好的服务。</span><br></pre></td></tr></table></figure></p>
<p>3.20☆ 某单CPU系统有如下一批处于就绪状态的进程。<br>(1) 给出<font color="purple">FCFS(先来先服务)</font>和<font color="purple">SJF(最短作业优先)</font>算法个进程的开始事件、完成时间、周转时间。<br>(2) 计算在各算法下的平均周转时间</p>
<p><table>
    <th rowspan="2">进程进入就绪队列的先后顺序</th> <th rowspan="2">运行时间</th> <th colspan="3">FCFS</th> <th colspan="3">SJF</th>
    <tr>
        <td>开始时间</td> <td>完成时间</td> <td>周转时间</td> <td>开始时间</td> <td>完成时间</td> <td>周转时间</td>
    </tr>
    <tr>
        <td>1</td> <td>10</td> <td class="td3_20">0</td> <td class="td3_20">10</td> <td class="td3_20">10</td> <td class="td3_20">9</td> <td class="td3_20">10</td> <td class="td3_20">19</td>
    </tr>
    <tr>
        <td>2</td> <td>1</td> <td class="td3_20">10</td> <td class="td3_20">1</td> <td class="td3_20">11</td> <td class="td3_20">0</td> <td class="td3_20">1</td> <td class="td3_20">1</td>
    </tr>
    <tr>
        <td>3</td> <td>2</td> <td class="td3_20">11</td> <td class="td3_20">2</td> <td class="td3_20">13</td> <td class="td3_20">2</td> <td class="td3_20">2</td> <td class="td3_20">4</td>
    </tr>
    <tr>
        <td>4</td> <td>1</td> <td class="td3_20">13</td> <td class="td3_20">1</td> <td class="td3_20">14</td> <td class="td3_20">1</td> <td class="td3_20">1</td> <td class="td3_20">2</td>
    </tr>
    <tr>
        <td>5</td> <td>5</td> <td class="td3_20">14</td> <td class="td3_20">5</td> <td class="td3_20">19</td> <td class="td3_20">4</td> <td class="td3_20">5</td> <td class="td3_20">9</td>
    </tr>
</table><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平均周转时间：</span><br><span class="line">FCFS：(10+11+13+14+19)/5=13.4</span><br><span class="line">SJF：(19+1+4+2+9)/5=7</span><br></pre></td></tr></table></figure></p>
<p>3.21 加载共享的缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中心队列占据了必须互斥访问的存储器区域，被抢占的线程可能不在同一个处理器上恢复执行。如果一个程序的线程间需要高度的合作，所涉及的进程切换就会严重影响性能。</span><br></pre></td></tr></table></figure></p>
<p>3.22 存储管理中交换技术的实现原理及主要作用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交换技术又称对换技术。</span><br><span class="line">进程从内存移到磁盘，并再移回内存称为交换。</span><br><span class="line">交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。交换技术的目的是尽可能达到“足够快地交换进程，以使当处理器调度程序想重新调度处理器时，总有进程在内存中处于就绪（准备执行）状态”的理想状态，从而提高内存利用率。</span><br></pre></td></tr></table></figure></p>
<p>3.23 虚拟页式存储管理的优缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：由于它不要求进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。这既提高了内存的利用率，又有利于组织多道程序执行。</span><br><span class="line">缺点：存在页面空间的浪费问题。这是由于各种程序代码的长度是各不相同的，但页面的大小是固定的，所以在每个程序的最后一页内总有一部分空间得不到利用。如果页面较大，则由此引起的存储空间的损失仍然较大。</span><br></pre></td></tr></table></figure></p>
<p>3.24 文件系统的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 统一管理文件的存储空间，实施存储空间的分配与回收。</span><br><span class="line">2. 实现文件从名字到外存地址空间的映射，即实现文件的按名存取。</span><br><span class="line">3. 实现文件信息的共享，并提供文件的保护措施。</span><br><span class="line">4. 向用户提供一个方便使用的接口。</span><br><span class="line">5. 系统维护及向用户提供有关信息。</span><br><span class="line">6. 保持文件系统的执行效率，文件系统在操作系统中占的比例最大。</span><br><span class="line">7. 提供I/O的统一接口。</span><br></pre></td></tr></table></figure></p>
<p>3.25 什么是逻辑文件？什么是物理文件？简述逻辑文件的几种形式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 用户组织的文件称为逻辑文件，存放在存储介质上的文件称为物理文件。</span><br><span class="line">2. 流式文件是由一串顺序的字符流组成的，记录式文件是由若干逻辑记录组成的。</span><br></pre></td></tr></table></figure></p>
<p>3.26☆ 某UNIX操作系统采用i结点管理文件的存储空间，假设磁盘大小为2048字节，每个地址占64位（8个字节），i结点包括13个地址项，其中10个地址用来存直接地址，一个地址项存一次间接地址，一个地址项存二次间接地址，一个地址项存三次间接地址。问系统能管理的单个文件最大长度是多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">磁盘块大小=2048字节=2×1024字节=2×1KB=2KB</span><br><span class="line">10个直接地址表示的文件大小=10×2KB=20KB                  直接地址指向磁盘块</span><br><span class="line">每个地址占8字节</span><br><span class="line">每个盘块中存放2^8=256个盘块号</span><br><span class="line">1个一次间接地址存放文件大小=1×256×2KB=512KB             间接地址指向直接地址</span><br><span class="line">1个二次间接地址存放文件大小=1×256×256×2KB=128MB         二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">1个三次间接地址存放文件大小=1×256×256×256×2KB=32GB      三级间接-&gt;二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">所以一个文件的最大长度=20KB+512KB+128MB+32GB</span><br></pre></td></tr></table></figure></p>
<p>3.27☆ 假定某系统中，磁带的记录密度为每英寸1200个字符，每个逻辑记录长为200个字符，块与块之间的间隙为0.5英寸。问，为了使磁带空间利用率达到70%，采用记录成组操作时的块因子应为多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设块因子为x。</span><br><span class="line">每条记录所占磁带空间=200/1200=1/6英寸</span><br><span class="line">(x*1/6)/(x*1/6+0.5)=0.7</span><br><span class="line">解得：x=7</span><br><span class="line">成组操作时块因子是7。</span><br></pre></td></tr></table></figure></p>
<p>3.28 简述UNIX的目录文件的存取权限及其含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读：允许读该目录。</span><br><span class="line">写：允许修改目录内容。</span><br><span class="line">执行：允许搜索该目录。</span><br></pre></td></tr></table></figure></p>
<p>3.29 通道有哪三种类型？简述三种通道的优缺点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 选择通道</span><br><span class="line">优点：以数据块为单位进行传输，传输效率高。</span><br><span class="line">缺点：通道利用率低。</span><br><span class="line">2. 数组多路通道</span><br><span class="line">优点：以数据块为单位进行传输，传输率高；又具有多路并行操作的能力，通道利用率高。</span><br><span class="line">缺点：控制复杂。</span><br><span class="line">3. 字节多路通道</span><br><span class="line">优点：多路并行操作能力与数组多路通道相同。</span><br><span class="line">缺点：以字节为单位交替进行的，个设备轮流占用一个很短的时间片，效率低。</span><br></pre></td></tr></table></figure></p>
<p>3.30☆ 假设对磁盘的请求为柱面号95、180、35、120、10、122、64、68，磁头的初始位置为30，求在下列移臂调度算法下的服务顺序和移动臂需要移动的距离。<br>（1）最短寻找时间优先调度算法。<br>（2）移动臂由外向里移动（向柱面号增大的方向）的电梯调度算法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 最短寻找时间优先调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;10-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180</span><br><span class="line">移动臂需要移动的距离=(35-30)+(35-10)+(64-10)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)=200(柱面)</span><br><span class="line">(2) 移动臂由外向里移动的电梯调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180-&gt;10</span><br><span class="line">移动臂需要移动的距离=(35-30)+(64-35)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)+(180-10)=320(柱面)</span><br></pre></td></tr></table></figure><br>3.31 磁盘驱动调度包括什么调度？各涉及什么时间？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">磁盘驱动调度包括移臂调度和旋转调度。</span><br><span class="line">分别涉及寻找时间和延迟时间。</span><br></pre></td></tr></table></figure></p>
<p>3.32 简述关于磁盘的电梯调度算法与单向扫描调度算法的含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 电梯调度算法是从移动臂当前位置开始沿移动方向去选择最近的柱面请求，当移臂方向向上无请求时，就改变移臂的移动方向再做类似处理。</span><br><span class="line">2. 单向扫描调度算法总是从0号柱面开始向里扫描，为请求的柱面提供服务，到达最后一个柱面再把读写头快速返回0号柱面（返回过程不做服务），返回后可再进行扫描和服务。</span><br></pre></td></tr></table></figure></p>
<p>3.33 磁盘驱动调度和调度原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘执行一次输入输出所需时间是：寻找时间、延迟时间、传送时间。</span><br><span class="line">采用一定得到调度策略以决定各等待访问者的执行次序，称为驱动调度。</span><br><span class="line">磁盘驱动调度就需要优化寻找时间和延迟时间，就是移臂调度和旋转调度。</span><br></pre></td></tr></table></figure></p>
<p>3.34 什么是死锁？产生死锁的额两个主要原因？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">死锁是指在多道程序系统中的一种现象，一组进程中的每个进程均无限期地等待被该进程中的另一个进程所占用且永远不会释放的资源。</span><br><span class="line">产生死锁的原因：</span><br><span class="line">（1）竞争资源，系统资源在分配时出现失误，进程间对资源的相互争夺而造成僵局。</span><br><span class="line">（2）多道程序运行时，进程推进顺序不合理。</span><br></pre></td></tr></table></figure></p>
<style>
    .td3_20{
        color:midnightblue;
    }
</style></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://pearlchocolatezy.com">Zong Yi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pearlchocolatezy.com/2024/09/26/LearnOS/">https://pearlchocolatezy.com/2024/09/26/LearnOS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pearlchocolatezy.com" target="_blank">珍珠巧克力</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/X2080901/">X2080901</a></div><div class="post_share"><div class="social-share" data-image="/img/bg_os.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/02/LearnDB/"><img class="prev-cover" src="/img/bg_db.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库系统原理概述</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/05/LearnJSP/"><img class="next-cover" src="/img/bg_jsp.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaWeb：JSP概述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/05/20/02333-1/" title="02333 软件工程（一）——绪论"><img class="cover" src="/img/bg_software.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="title">02333 软件工程（一）——绪论</div></div></a></div><div><a href="/2025/06/01/02333-2/" title="02333 软件工程（二）——软件需求与软件需求规约"><img class="cover" src="/img/bg_software.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="title">02333 软件工程（二）——软件需求与软件需求规约</div></div></a></div><div><a href="/2025/06/01/02333-3/" title="02333 软件工程（三）——结构化方法"><img class="cover" src="/img/bg_software.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="title">02333 软件工程（三）——结构化方法</div></div></a></div><div><a href="/2025/06/11/02333-5/" title="02333 软件工程（五）——面向对象方法RUP"><img class="cover" src="/img/bg_software.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-11</div><div class="title">02333 软件工程（五）——面向对象方法RUP</div></div></a></div><div><a href="/2025/05/29/04747-01/" title="04747-Java（一）——概述"><img class="cover" src="/img/bg_java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-29</div><div class="title">04747-Java（一）——概述</div></div></a></div><div><a href="/2025/06/10/04747-05/" title="04747-Java（五）——数组和字符串"><img class="cover" src="/img/bg_java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="title">04747-Java（五）——数组和字符串</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang_yuki.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zong Yi</div><div class="author-info__description">Mon panache. - 我的勇气。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pearlchocolate01"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://pearlchocolatezy.com/rss2.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">(๑╹ヮ╹๑)ﾉ  欢迎来到珍珠巧克力的小站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">简述</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/12/04747-06/" title="04747-Java（六）——继承与多态"><img src="/img/bg_java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="04747-Java（六）——继承与多态"/></a><div class="content"><a class="title" href="/2025/06/12/04747-06/" title="04747-Java（六）——继承与多态">04747-Java（六）——继承与多态</a><time datetime="2025-06-13T10:24:00.287Z" title="更新于 2025-06-13 18:24:00">2025-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/23/LeetCode100-91-100/" title="LeetCode热题100：91-100解析"><img src="/img/bg_leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode热题100：91-100解析"/></a><div class="content"><a class="title" href="/2025/05/23/LeetCode100-91-100/" title="LeetCode热题100：91-100解析">LeetCode热题100：91-100解析</a><time datetime="2025-06-11T14:50:07.456Z" title="更新于 2025-06-11 22:50:07">2025-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/11/02333-5/" title="02333 软件工程（五）——面向对象方法RUP"><img src="/img/bg_software.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="02333 软件工程（五）——面向对象方法RUP"/></a><div class="content"><a class="title" href="/2025/06/11/02333-5/" title="02333 软件工程（五）——面向对象方法RUP">02333 软件工程（五）——面向对象方法RUP</a><time datetime="2025-06-11T10:41:24.126Z" title="更新于 2025-06-11 18:41:24">2025-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/04747-05/" title="04747-Java（五）——数组和字符串"><img src="/img/bg_java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="04747-Java（五）——数组和字符串"/></a><div class="content"><a class="title" href="/2025/06/10/04747-05/" title="04747-Java（五）——数组和字符串">04747-Java（五）——数组和字符串</a><time datetime="2025-06-10T14:19:24.470Z" title="更新于 2025-06-10 22:19:24">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/04747-04/" title="04747-Java（四）——面向对象程序设计"><img src="/img/bg_java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="04747-Java（四）——面向对象程序设计"/></a><div class="content"><a class="title" href="/2025/06/08/04747-04/" title="04747-Java（四）——面向对象程序设计">04747-Java（四）——面向对象程序设计</a><time datetime="2025-06-08T14:42:30.719Z" title="更新于 2025-06-08 22:42:30">2025-06-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2022-12 - 2025 By Zong Yi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '8a1150939f4fa795f439',
      clientSecret: 'ba1c39ca577e914d7e48639a4e1fb9b6ce67d8c8',
      repo: 'pearlchocolate01.github.io',
      owner: 'PearlChocolate01',
      admin: ['PearlChocolate01'],
      id: 'f554f9b37889163b6093882c96b47386',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'DPq7jAfPBtKwlm2h1mA2KUVb-MdYXbMMI',
      appKey: 'uLosrTMuocJInslQDE0UJEGE',
      avatar: 'retro',
      serverURLs: 'https://valine.pearlchocolatezy.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>