<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Thu, 30 Jan 2025 11:33:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>计算机网络自顶向下（四）——网络层：数据平面</title>
      <link>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</link>
      <guid>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</guid>
      <pubDate>Thu, 30 Jan 2025 02:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;网络层：数据平面&quot;&gt;&lt;a href=&quot;#网络层：数据平面&quot; class=&quot;headerlink&quot; title=&quot;网络层：数据平面&quot;&gt;&lt;/a&gt;网络层：数据平面&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解网络服务的基本原理<br>网络服务模型<br>转发和路由<br>路由器工作原理<br>通用转发<br>网络层协议的实例</p><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ol><li>在发送主机和接收主机对之间传送段</li><li>在发送端，将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/30/LearnNet4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（三）——传输层</title>
      <link>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</link>
      <guid>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</guid>
      <pubDate>Mon, 27 Jan 2025 12:50:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解传输层的工作原理<br>（1）多路复用，解复用<br>（2）可靠数据传输<br>（3）流量控制<br>（4）拥塞控制<br>学习Internet的传输层协议：<br>（1）UDP无连接传输<br>（2）TCP面向连接的可靠传输<br>（3）TCP的可靠控制</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RDT，即reliable data transfer</p><p>物理层：传输实体，链路层：点到点，网络层：端到端，传输层：进程到进程，应用层：客户-服务</p><p>传输层提供进程与进程之间的，以message为单位的通信服务</p><p>传输协议运行在端系统。<br>发送方：讲应用层的报文分成报文段，然后传递给网络层。<br>接收方：将报文段重组成报文，然后传递给应用层。</p><p>有多个传输层协议可供应用选择</p><p>IP向上层提供的服务是不可靠的，TCP加强了可靠性；TCP向上层提供的服务是不安全的，SSL可以加强安全性。TCP无法降低延迟，无法增加带宽。TCP可以加强服务品质，但无法优化性能。</p><p>有连接的单位是分组，无连接的单位是数据报</p><p>字节流：Byte stream；数据报：Datagram；边界信息：Boundary information</p><p>best effort</p><h3 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h3><p>上一层实现IP的区分，到传输层引入端口，区分进程，完成源端的复用，到目标端的解复用。<br>复用是指多个tcp socket的信息都往下交,对方收到再分给不同的socket</p><p>共有65535个端口号</p><p>TCP和UDP使用端口的方式不一样</p><p>为了使穿过层间的信息最少，TCP和四元组相捆绑，即socket，socket包含四个信息：本地IP，本地port，对方IP，对方port。</p><p>socket是网络服务接口，对应进程</p><p>UDP的socket和本地IP，本地port相捆绑（二元组）。</p><p>应用往下传的是：（1）数据（2）socket（3）对方IP和对方port的地址（cad，指针）</p><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><p>应用：实时流媒体；事务性应用（一次往返）<br>UDP：用户数据报协议<br>UDP校验和：检测在被传输报文段中的差错。<br>残存错误：数据部分和EDC部分出错后依然符合校验规则。（概率小，但不可忽略）<br>发送方编码，接收方解码<br>进位回滚</p><h3 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt（可靠数据传输）在应用层、传输层和数据链路层都很重要。是网络Top10问题之一。<br>信道的不可靠特点决定了可靠数据传输协议的复杂性。</p><p>在可靠信道上传输：不出错，不丢失</p><p>超时重传机制（解决传错/丢失问题）</p><p>滑动窗口协议（slide window）：发送缓冲区。<br>发送窗口的最大值&lt;=发送缓冲区的值<br>发送窗口前沿移动的极限：不能超过发送缓冲区<br>接收窗口=接收缓冲区<br>GBN（Go-back-N）协议和SR(Selective Repeat)协议的异同：相同：发送窗口&gt;1，一次可发多个未经确认分组。区别：GBN接收窗口尺寸=1，只能顺序接收，一旦一个分组没有发成功，要返回错误的地方重发；SR接收窗口尺寸&gt;1，可乱序接收，发送未成可以选择性重发错的中间某一项。</p><p>GBN适用范围：出错率低（SR复杂易出错）<br>SR适用范围：链路容量大（延迟大，带宽大）<br>GBN:以时间换空间  SR: 以空间换时间</p><h3 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h3><p>（段结构；可靠数据传输；流量控制；连接管理）<br>TCP概述：点对点，可靠的、按顺序的字节流，管道化（流水线），发送和接收缓存，全双工数据，面向连接，有流量控制</p><p>MSS:Maximum Segment Size, 最大报文段大小，≤当然可以</p><p><strong>TCP往返延时（RTT）和超时</strong><br>在局域网中，两台计算机之间的往返延迟可以设置为固定的值；通过TCP处理进程通信的情况，超时时间是动态的、自适应的。<br>sampleRTT 当前采样RTT<br>estimatedRTT 移动平均RTT</p><p>TCP在IP不可靠服务的基础上建立了RTT</p><p>快速重传算法</p><p><strong>流量控制</strong><br>目的：防止发送方发的太快，超出了接收方的处理能力（防止接收方缓冲区溢出）。</p><p><strong>连接管理</strong><br>连接建立 和 连接拆除</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络拥塞的表现：分组丢失率变高，延迟更多<br>两种拥塞控制方法：端到端拥塞控制，网络辅助的拥塞控制<br>ATM网络：异步传输网络，它的数据单位是RM（信元）<br>ABR模式：弹性服务</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>如何检测拥塞：超时（拥塞）；收到某个段三个重复的ACK（轻微拥塞，没有发生拥塞，但是由于未通过差错检验，给源端一种发生拥塞的错觉）</p><p>rate=CongWin/RTT<br>两种控制同时考虑：接受窗口反映流量控制，拥塞窗口反映拥塞控制<br>拥塞控制的策略：慢启动（每个RTT，CongWin加倍；一开始慢速，但加速是指数性的）</p><p>拥塞控制的机制：线性增加-层性减-线性增加-层性减…<br>（改进）指数增加-线性增加-线性减-指数增加-线性增加-线性减…</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>传输层提供的服务：为应用进程间的逻辑通信服务（相对的，网络层提供的是主机和主机之间的通信服务），传输层协议包括TCP和UDP</li><li>原理：多路复用和解复用<br>区分进程使用的是：端口</li><li>无连接传输层协议UDP</li><li>可靠数据传输原理：停止等待协议（RDT），流水线协议（GBN：接收窗口=1，SR：接收窗口&gt;1）</li><li>TCP协议：TCP特性，面向连接的，进程到进程的；TCP报文段格式；TCO可靠传输机制；超时重传，快速重传；流量控制；连接管理</li><li>拥塞控制原理：拥塞原因，拥塞代价（方式：网络辅助e.g.ATM - 根据网络提供的反馈信息；端到端e.g.TCP - 超时和三个冗余ACK来判断拥塞）</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/27/LearnNet3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（二）——应用层</title>
      <link>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</link>
      <guid>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</guid>
      <pubDate>Mon, 06 Jan 2025 13:19:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;h3 id=&quot;提纲&quot;&gt;&lt;a href=&quot;#提纲&quot; class=&quot;headerlink&quot; title=&quot;提纲&quot;&gt;&lt;/a&gt;提纲&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>目标：原理&amp;实例&amp;编程</p><ol><li>应用层协议原理</li><li>Web and HTTP</li><li>FTP*</li><li>Email<br>（1）SMTP（2）POP3（3）IMAP</li><li>DNS</li><li>P2P应用</li><li>CDN</li><li>TCP套接字（Soclet）编程</li><li>UDP套接字编程</li></ol><h3 id="应用层原理"><a href="#应用层原理" class="headerlink" title="应用层原理"></a>应用层原理</h3><p>网络应用的例子：E-mail，Web，文本消息，远程登录，P2P文件共享，即时通信，多用户网络游戏，流媒体（YouTube,Netflix），Internet电话，实时电视会议，社交网络，搜索……<br>网络应用得到体系结构：客户-服务器模式（C/S），对等模式（P2P），混合体</p><ol><li>客户-服务器（C/S）体系结构<br>服务器：一直运行；固定的IP地址和周知的端口号（约定）；扩展性差；可靠性差（服务器会宕机）。<br>客户端：主动与服务器通信；与互联网有间歇性的连接；可能是动态IP地址；不直接与其它客户端通信。</li><li>对等体（P2P）体系结构<br>（几乎）没有一直运行的服务器；<br>任意端系统之间可以进行通信；<br><font color="purple">每一个节点即是客户端又是服务器</font>，自扩展性；<br>参与的主机间歇性连接且可以改变IP地址（难以管理）。<br>e.g.迅雷</li><li><p>C/S和P2P混合体<br>（1）e.g.Napster</p><blockquote><p>《Napster》是一个真实的案例，是一家音乐分享平台的。它以其革命性的P2P（点对点）文件共享技术引发了音乐行业的巨大变革，但最终因未能应对法律和商业压力而走向失败。如今Napster以经营付费服务为主，而免费的Napster的流行和回响使其在电脑界和娱乐业里成为一个传奇的象征。</p></blockquote><p> 文件搜索：集中<br> 文件传输：P2P<br> （2）即时通信</p></li><li>进程通信<br>进程：在主机上运行的应用程序<br>客户端进程：发起通信的进程<br>服务器进程：等待连接的进程<br>在同一个主机内，使用进程间通信机制通信（由操作系统定义）。<br>不同主机，通过交换报文（message）来通信（使用OS提供的通信服务；借助传输层的服务，按照应用协议交换报文）。<br>P2P架构也有客户端进程和服务器进程之分。</li><li>分布式应用进程需要解决的问题<br>（1）进程标识和寻址问题（服务用户）<br>（2）传输层-应用层怎样提供服务（位置：层间界面的SAP；形式：应用程序接口API）<br>（3）如何使用传输层提供的服务，实现应用进程间的报文交换，实现应用（用户使用服务）（定义应用层协议，编制程序）<br><br><strong>（1）-&gt; 对进程进行编址（addressing）</strong><br>进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）：<br>①每台主机有唯一的32位IP地址，但IP地址无法唯一标识一个进程。<br>②采用的传输层协议：TCP or UDP<br>③端口号（Port Numbers）<br>约定默认端口号：<br>FTP：21<br>Telnet：23<br>HTTP:TCP：80<br>MAIL:TCP：25<br>ftp:TCP：2<br>一个进程：IP+port标示端节点<br>本质上，一对主机进程之间的通信由2个端节点构成。<br>TCP和UDP使用端口的方式不同。<br><strong>（2）-&gt; 传输层提供的服务-需要穿过层间的信息</strong><br>层间接口必须要携带的信息：<br>①要传输的报文（本层SDU）<br>②谁传的：对方的应用进程标示：IP+TCP(UDP)端口<br>③传给谁：对方的应用进程标示：对方的IP+TCP(UDP)端口号<br>传输层实体（TCP or UDP实体）根据这些信息进程TCP报文段（UDP数据报）的封装。<br>如果Socket API每次传输报文，都携带这么多信息（IP+TCP/UDP端口），易出错，不易管理。<br><mark class="hl-label pink">TCP Socket</mark> ：TCP服务，两个进程通信之前需要建立连接（持续一段时间）。<br>可以用一个整数表示两个实体之间的通信关系（本地标示）；穿过层间的信息量最小。<br><font color="purple">TCP Socket是本地IP、本地TCP端口、对方IP、对方TCP端口以及连接状态的一个本地标识，是一个整数。</font>（会话关系的本地标识）<br>Socket是TCP之上的套接字。<font color="purple">4元组</font>，唯一指定一个会话。简单，便于管理。<br>TCP是传数据报和Socket这两样东西。<br><mark class="hl-label pink">UDP Socket</mark> ：UDP服务，两个进程通信前无需建立连接。<br>每条报文独立传输；前后报文可能给不同的分布式进程。因此只能用一个整数表示本应用实体的标示。穿过层间接口的信息量最小。<br><font color="purple">UDP Socket是本地IP、本地端口号的标识。2元组。</font>传输报文时需要提供对方IP、对方端口；接收报文时需要上传对方IP、对方端口。<br>UDP是传数据报、Socket、对方IP、对方端口号这四样东西。<br>套接字Socket像是门（饥荒小木牌）。进程向套接字发送报文或从套接字接收报文。<br><strong>（3.1）-&gt; 如何使用传输层提供的服务实现应用</strong><br>定义应用层协议：报文格式、解释、时序等。<br>编制程序：通过API调用网络基础设施提供通信服务传报文、解析报文、实现应用时序等。<br><mark class="hl-label pink">应用层协议</mark> 定义了运行在不同端系统上的应用进程如何交换报文，规范了报文类型、语法、语义、规则。<br>应用协议是应用的一个组成成分。<br>公开协议：HTTP，SMTP等。由RFC文档定义。<br>私有协议：Skype等。<br><strong>（3.2）-&gt; 应用层需要传输层提供什么样的服务</strong><br>要素：数据丢失率，延迟，吞吐，安全性。</li><li>安全TCP<br>（1）TCP&amp;UDP<br>（2）SSL（Security Socket Layer）：基于TCP提供加密的TCP连接，位于应用层。<br>网站http开头：跑在TCP之上；https开头：跑在SSL over TCP之上。</li></ol><h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><p>Web网页：由一些对象组成（e.g.HTML文件、图片、Java小程序、mp3文件等）。<br>Web页含有一个基本的HTML文件，该文件包含若干对象的引用（链接）。<br>通过URL对每个对象进行引用，URL包含访问协议，用户名，口令字，端口号等。</p><ol><li>HTTP概况<br>HTTP：超文本传输协议。Web的应用层协议。<br>客户/服务器模式：<br>（1）客户：请求、接收和显示Web对象的浏览器。<br>（2）服务器：对请求进行响应，发送对象的Web服务器。<pre><code> PC/mobile browser-&gt;HTTP request                     HTTP response&lt;-Web server</code></pre>HTTP跑在TCP之上：<br>（1）客户发起与服务器的TCP连接（建立套接字）；<br>（2）服务器接收客户的TCP连接；<br>（3）在浏览器与Web服务器交换HTTP报文；<br>（4）关闭TCP连接。<br>HTTP是无状态的，服务器不维护。<br>服务器刚刚建立的时候，守候在默认的80端口，套接字为Socket1（S1）；一个连接建立起来后得到S2，又一个连接建立后得到S3，原来的S1等待着其它Web浏览器的并发建立连接请求。（S1是waiting socket，特殊socket）<br><strong>非持久HTTP</strong><br>最多只有一个对象在TCP连接上发送；<br>下载多个对象需要多个TCP连接；<br>HTTP/1.0使用非持久连接。<br>三次握手：[连接请求，连接确认，http request]，http response，关闭连接。（上传10个文件就重复操作这五步10次）<br>缺点：每个对象要两个RTT；操作系统必须为每个TCP连接分配资源；浏览器通常打开并行TCP连接以获取引用对象。<br><strong>持久HTTP</strong><br>多个对象可以在一个TCP上传输；<br>HTTP/1.1默认使用持久连接。<br>三次握手基础上不关闭连接。<br>优点：保持连接；反复请求，使用相同连接传送；引用对象可以尽快发送。<br>（1）非流水方式的持久HTTP：客户端收到一个响应才能发送新的请求；每个引用对象花费一个RTT。（串行）<br>（2）流水方式的持久HTTP：HTTP/1.1默认模式；客户端遇到一个引用对象就立刻产生一个请求；有可能所有引用对象只花费一个RTT。（并行，多线程）<br><strong>响应时间模型</strong><br>往返时间RTT：一次往返传播的时间（传播是两主机的距离要有时间，传输是把数据打到电线上要的时间。这里传输时间不计）<br>响应时间：一个RTT用来发起TCP连接，一个RTT用来发送HTTP请求并等待HTTP响应。<br>文件传输时间：2RTT+1个对象传输时间</li><li>HTTP请求报文<br>两种类型：请求，响应<br>格式：ASCII，可读<br>HTTP请求报文：请求行（get,post,head命令） + 首部行（host,user-agent,connection等信息） + 换行回车符（表示结束）<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/1.jpg" width="50%"><br>提交表单输入：post方式（网页通常包括表单输入，包含在实体主体中的输入被提交到服务器），url方式（通过请求行额度url字段上载）<br><code>www.123.com/test?monkeys&amp;banana</code></li><li>HTTP响应报文<br>状态行（协议版本，状态码，状态信息） + 首部行 + 数据（e.g.请求的HTML文件）<br><a href>HTTP响应状态码</a>（待补充）</li><li>用户-服务器状态：cookies<br>四个组成部分：。。。（刷到题再记）</li><li>Web缓存 代理服务器（proxy server）<br>不访问原始服务器，就满足客户请求。<blockquote><p>一类是Gib Mib Kib,代表的是1024进制的计数单位,一类是gb mb kb,代表的是1000进制的计数单位无特殊标注。<br>大部分简写都表示1024进制换算单位，u盘厂商一般是按1000进制换算的，这也是u盘插电脑上显示的内存都会比标注的少的原因。<br>速率按1000，大小按1024。<br>b是bit，B是字节。MBps和Mbps不一样。</p></blockquote></li><li>条件get</li></ol><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h3><p>功能：上传&amp;下载-&gt;文件共享<br>默认端口：21（waiting port）<br>明文传输<br>控制连接（port21，带外传送）&amp;数据连接（port20，带内）<br>FTP特点：控制命令和数据传输分别在两个不同TCP连接上。而HTTP的控制和响应数据在一个连接上。<br>HTTP本身无状态，通过cookies变成有状态协议；FTP是有状态协议。</p><h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><p>协议组成部分：用户代理，邮件服务器，简单邮件传输协议SMTP<br>用户代理：又名“邮件阅读器”，e.g.Foxmail、QQ邮箱，输入和输出邮件保存在服务器。<br>三跳：用户代理发给邮件服务器 -&gt; 邮件服务器发给目标邮件服务器 -&gt; 用户代理POP3存取协议从邮件服务器拉取邮件。(前两跳是推，最后一跳是拉)<br>SMTP协议：使用TCP在客户端和服务器之间传送报文，默认端口号25。传输的三个阶段（握手，传输报文，关闭）。<br>MINE：multimedia mail extension 多媒体邮件扩展。编码和解码。<br>原始的SMTP协议只能传输ASCII字符的邮件，引入MINE扩展后可以传输更多内容。<br>POP3协议：邮件的存取协议。拉邮件。用户确认阶段，事务处理阶段。无状态。本地管理文件夹。<br>IMAP：保留用户状态。远程管理文件夹。<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/2.jpg" width="60%"></p><h3 id="DNS（Domain-Name-System）-域名解析系统"><a href="#DNS（Domain-Name-System）-域名解析系统" class="headerlink" title="DNS（Domain Name System） 域名解析系统"></a>DNS（Domain Name System） 域名解析系统</h3><p>不是直接给人用的，是为其它应用服务的，其它应用最终是给人用的。<br>服务：域名（应用层）和IP地址（传输层）的转换。用于Web,ftp等。<br>必要性：IP地址不便记忆，便于通过域名寻址。<br>需要解决的三个问题：分层命名，分布式解析，增加和删除域名（命名，解析，维护）<br>历史：ARPANET解决方案，存在一个维护站，主机数量太大时难以分配<br>DNS的思想：分层命名，分布式数据库（树状关系），运行在UDP之上，核心的Internet功能但以应用层协议实现。<br>核心部分：互连的路由器,网络的网络，为边缘部分提供服务(连通性和数据交换)，核心功能是路由(决定分组采用的到目标的路径)和转发(将分组从路由的输入链路转到输出链路)。互联网很多核心内容在建立在互联网边缘的端系统的应用之上实现的。（应该是核心部分简单稳定却强大，把复杂易错的精细活交给边缘设备）<br>DNS其它目的：别名转换为规范名字；负载均衡。<br>DNS域名结构：层次树状结构（每个树叶代表主机，用dot区分层次）。Internet根被划分为几百个顶级域名，分为通用的（.com, .edu, .gov…）和国家的（.cn, .us…）；顶级域可以分为若干个二级域……<br>全球共13个根名字服务器，可靠。（10个在美国、1个在英国、1个在瑞典、1个在荷兰）<br>域的划分是逻辑的，不是物理的。<br>DNS：保存资源记录（RR）的分布式数据库，RR格式（name,value,type,ttl）。（TTL:生存时间，决定该资源记录从缓存中删除的时间，默认2天）<br>DNS大致工作过程：应用调用解析器；解析器作为客户向Name Server发出查询报文；Name Server返回响应报文。<br>一台设备上网必须具备四个信息：ip地址，子网掩码，默认网关default gateway，local name server(DNS)。（得到Name和IP的对应关系）</p><h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p>（P2P与C/S模式并列）<br>纯P2P架构：几乎没有一直运行的服务器；任意端系统可以直接通信；利用peer的服务能力，peer节点间歇上网，每次IP地址可能有变化。（e.g.Skype, BitTorrent, KanKan）<br>采用C/S方法将一个F大小的文件分发给N个客户端耗时（下限）：</p><script type="math/tex; mode=display">D_{C-S} \geq max\{\dfrac{NF}{u_{s}},\dfrac{F}{d_{min}}\} （随着N线性增长）</script><p>所有用户都从服务器下载。u是服务器上载速率，d是客户端下载速率。总时间与N呈线性增加关系。<br>采用P2P方法讲一个F大小文件分发给N个客户端耗时：</p><script type="math/tex; mode=display">D_{P2P} \geq max\{\dfrac{F}{u_{s}},\dfrac{F}{d_{min}},\dfrac{NF}{u_{s}+\sum{u_{i}}}\}</script><p>所有peer节点（客户端）都可以上载。N越大，时间越长，但相比C/S节省的时间也越多。（斜率变小）<br>随着N的数量增加，请求资源的节点数量在增加，提供服务的节点数量也在增加，可扩充用户数量比C/S多得多。可扩展性好，但难以维护。</p><p>P2P资源共享的两大问题：如何定位所需资源，如何处理对等方的加入与离开；可能的方案：集中，分散，半分散。</p><p><strong>非结构化P2P</strong><br>peer与peer构成了一个覆盖网，构成一条边，是随机的。<br>非结构化P2P：集中式目录，完全分布式，混合体。<br>集中式目录存在的问题：单点故障，性能瓶颈，侵犯版权。（文件传输是分散的，而定位内容是高度集中的）<br>完全分布式例子：查询洪泛：Gnutella：没有中心服务器，许多Gnutella客户端，覆盖网络（图）。（去中心化）<br>Gnutella：对等方加入。X试图与可用对等方列表上的对等方建立TCP连接，X向Y发送一个Ping报文，收到Ping报文的对等方以Pong报文响应，然后它能建立TCP连接。<br>混合体例子：利用不匀称性：KaZaA<br>每个对等方是组长或属于一个组长，对等方与组长间或组长之间存在TCP连接。<br>每个文件有唯一hash值（散列标识码）作为id，一个描述字段用于查询<br>KaZaA实例：BigTorrent：请求，发送文件块。新的Peer节点加入洪流（bitmap），成为吸血鬼，开始白嫖，先下载稀缺块（稀缺优先策略），并且优先向那些为我提供最好服务的节点提供服务，巧妙地将集体利益和个人利益结合在一起。<br><strong>结构化（DHT）P2P</strong><br>peer与peer构成一个有序的overlay，构成一个环/树。<br>结构化P2P维护一个树状或环状有序拓扑，每个节点用ip对应的16字节hash值作为唯一标识。文件也有对应的hash，节点ID与文件是重叠的 文件在哪些节点之上是约定好的，通过有序的节点与节点之间的拓扑，能很快找到内容所在的位置，实现快速内容分发。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>视频流化服务：视频流量占据着互联网的大部分带宽。挑战：规模性，异构性。解决方案：分布式的、应用层面的基础设施。<br>视频：固定速度显示的图像序列。<br>CBR：constant bit rate 以固定速率编码。<br>VBR：variable bit rate 视频编码速率随时间的变化而变化。<br>（画面变化更多的视频比几乎不变的视频丢失帧率更多）<br>AVS：高级视频编码。<br>存储视频的流化服务：缓冲<br>DASH协议：动态自适应流化，基于HTTP。服务器将视频分割成多个块，每个块独立存储，编码于不同码率，告示文件（manifest file）提供不同块的url。客户端先获取告示文件，周期性地测量服务器到客户端的带宽，查询告示文件，一个时刻请求一个块，HTTP头部指定字节范围。（客户端根据带宽、网络能力、播放需求等一边播放一遍决定后续请求哪些块 -&gt; B站）<br>CDN：Content Distribution Networks<br>挑战：服务器如何通过网络向上百万用户同时流化视频内容。<br>方案1：单个大的超级服务中心（缺点：瓶颈链路带宽小导致停顿，单点故障，视频拷贝多效率低，周边网络拥塞）（评价：简单，但不可扩展）<br>方案2：CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务。<br>（1）enter  deep：将CDN服务器深入到许多接入网（优点：距离近，数量多，速度快）（缺点：管理困难）e.g.Akamai<br>（2）bring home：部署在少数（10个左右）关键位置，采用租用线路将服务器簇连接起来。e.g.Limelight<br>在CDN节点中存储内容的多个拷贝，用户从CDN中请求内容。<br>位于应用层，靠主机与主机之间的配合提供服务。<br>Netflix网飞案例：网飞制作内容，上传至亚马逊云端（Amazon Cloud），卖给多个运营商，包括Akamai CDN, Limelight CDN, Level-3 CDN，来加速内部访问。网飞自己维护认证服务器，完成认证后访问网页，网页也在云端，用户可以自己选也可以自动选择最近的运营商缓存节点，从而得到服务。</p><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>作用：通信<br>Socket编程：socket是传输报文应用层和传输层的门，socket api是创建socket的函数。<br>两种传输层服务的socket类型：TCP可靠，UDP不可靠。<br>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户。<br>TCP服务：从一个进程向另一个进程可靠地传输字节流。<br><strong>TCP套接字编程步骤</strong>：<br>（1）服务器首先运行，等待连接建立。创建欢迎socket，和本地端口捆绑，在欢迎socket上阻塞式等待接收用户的连接。<br>（2）客户端主动和服务器建立连接。创建客户端本地套接字（隐式捆绑到本地port），指定服务器进程的IP地址和端口号，与服务器进程连接。<br>（3）当与客户连接请求到来时，服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket，与客户端通信。允许服务器与多个客户端通信，使用源IP和源端口来区分不同的客户。<br>（4）连接API调用有效时，客户端P与服务器建立了TCP连接。建立<br>（原来的welcome socket和本地端口捆绑，connect socket和客户端IP捆绑；<br>连接后，connect socket关闭，welcome socket仍然守候。）<br>从应用进程角度：TCP在客户端和服务器进程之间提供了可靠的字节流（管道）服务。</p><div class="table-container"><table><thead><tr><th>数据结构 socketaddr_in</th><th>IP地址与port跳转关系的数据结构（标识进程的端节点）</th></tr></thead><tbody><tr><td>sin_family</td><td>地址簇，常量，代表用的TCP/IP协议还是IPX协议</td></tr><tr><td>sin_port</td><td>端口号port</td></tr><tr><td>sin_addr</td><td>IP地址</td></tr><tr><td>sin_zero[8]</td><td>对齐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>数据结构 hostent</th><th></th></tr></thead><tbody><tr><td>*h_name</td><td>主机域名</td></tr><tr><td>**h_aliases</td><td>多个域名别名</td></tr><tr><td>h_length</td><td></td></tr><tr><td>**h_addr_list[i]</td><td>多个IP地址（放到socketaddr_in/sin_addr）</td></tr></tbody></table></div><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>UDP socket<br>客户端与服务器之间没有连接，没有握手。<br>包括信息：我的socket值（本地IP和UDP端口），发送内容，发给谁（对方IP对方端口）。<br>收报文时的两件事：对方发送的内容，对方的端节点。<br>传送的数据可能丢失。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>应用程序体系结构：C/S，PSP，混合。</li><li>应用程序需要的服务器品质描述：可靠性，带宽，延时，安全。</li><li>Internet传输层服务模式：TCP（可靠的、面向连接的服务），UDP（不可靠的数据报）。</li><li>流行的应用层协议：HTTP,FTP,SMTP,POP,IMAP,DNS。</li><li>Socket编程。</li><li>应用层协议报文类型：请求/响应报文：客户端请求信息或服务；服务器以数据、状态码进行响应。</li><li>报文格式：首部（关于数据信息的字段），数据（被交换的信息）。</li><li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序，以及一条报文传输和接收或其它事件采取的动作。</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/06/LearnNet2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（一）——概述</title>
      <link>https://pearlchocolatezy.com/2024/12/28/LearnNet/</link>
      <guid>https://pearlchocolatezy.com/2024/12/28/LearnNet/</guid>
      <pubDate>Sat, 28 Dec 2024 08:17:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;核心知识点概览&quot;&gt;&lt;a href=&quot;#核心知识点概览&quot; class=&quot;headerlink&quot; title=&quot;核心知识点概览&quot;&gt;&lt;/a&gt;核心知识点概览&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;top down 自顶向下，从应用层到物理层。&lt;/li&gt;
&lt;li&gt;每个层次的功能（能力）</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="核心知识点概览"><a href="#核心知识点概览" class="headerlink" title="核心知识点概览"></a>核心知识点概览</h2><ol><li>top down 自顶向下，从应用层到物理层。</li><li>每个层次的功能（能力），和提供的主要服务（能力的一个体现）。功能的范围更广。</li><li>每一层的功能都通过向上层提供的接口向上层提供服务。本层功能的实现要通过层间的接口调用下层的服务。（<font color="purple">下为上服务，上调下实现</font>）</li><li>实例（应用层）<br>（1）支持web应用的HTTP协议<br>（2）支持ftp应用的FTP协议<br>（3）传送和接收电子邮件用的SMTP协议和POP3协议</li><li>传输层提供的两种服务：TCP, UDP。</li><li>TCP：传输控制协议（传输层）。很多应用（应用层）都跑在TCP协议之上，包括FTP协议、telnet、web的应用（浏览器）。</li><li>HTTP在传输层TCP的协议之上。</li><li>浏览器：三次握手原理<br><img class="zy_img_shadow" src="/2024/12/28/LearnNet/1.jpg" width="50%"></li><li>可靠性（reliable）：不出错、不失序、不重复、不丢失（可靠越高，代价越大，比如延迟）</li><li>一般的实时多媒体<font color="purple">（游戏串流、直播）：UDP</font>（对丢失要求不高，但对实时性要求高）</li><li>事务性应用（聊天）：UDP（一次往返）</li><li><font color="purple">FTP</font>：客户端和服务器之间的交互（e.g.<font color="purple">上传下载</font>）</li><li>不同应用之间的交互，不同厂商生产的路由器之间的交互（华为&amp;思科），不同厂商生产的网卡之间的交互（华为&amp;清华）</li><li>传输层为远程的应用进程提供服务，传输层是在网络层提供的端到端的服务基础之上实现的，然后区分为进程到进程（<font color="purple">细分且加强</font>）</li><li>网络层提供源主机到目标主机（端到端,end to end,E2E）之间的数据交互（ip数据报）。网络层的服务在链路层P2P的服务基础之上实现。</li><li><font color="purple">网络层有两种工作方式：传统的方式、现代的SDN方式。</font><br>（1）传统方式：路由协议，IP协议。<br>路由协议：运行在路由协议上的软件称为路由实体，和其它路由器的的路由软件交换路由报文（e.g.到哪个子网），按照某种路由选择算法算出路由表，路由表包括IP子网该怎么走，路由表给IP协议使用。<br>网络层得到基本功能：路由（由路由协议交换路由信息，由路由算法得出路由表），转发（IP协议：根据ip目标查路由表，查到表项后，从合适的的端口转发出去，查不到则按照默认路径转走）。<br>缺点：路由器一旦设立好后不变，无法升级更新。<br>（2）SDN方式：数据平面（交换机），控制平面（网络操作系统）<br>网络应用根据不同的运算，得到不同的流表，下发给交换机，交换机（上载分组匹配）根据匹配完的流表可做的工作是多样化的（block阻止，换字段，泛洪，转发…）。<br>优点：更一般化，IP路由器相当于SDN的一个特例，网络运营商可以编程。</li><li>数据链路层（网卡）提供点到点（point to point,P2P）的服务，在物理层提供的基础之上提供帧到帧的数据。</li><li>选学：网络安全，无线和移动网络，多媒体网络，网络管理。</li><li><font color="red">【自顶向下】：应用层传输层网络层：数据平面网络层：控制平面数据链路层&局域网</font></li></ol><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>目标：<br>（1）了解基本术语和概念<br>（2）掌握基本原理<br>（3）方法：以Internet为例<br>提纲：<br>（1）什么是Internet<br>（2）什么是协议<br>（3）网络边缘<br>（4）接入网、物理媒体<br>（5）网络核心：分组交换、线路交换<br>（6）Internet/ISP结构<br>（7）性能：丢包、延时、吞吐量<br>（8）协议层次、服务模型<br>（9）历史</p><h3 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h3><p>网络：节点和边<br>计算机网络：联网的计算机所构成的系统。节点：主机节点（■）&amp;数据交换节点（●，中转节点，不是源，也不是目标，负责转发数据，e.g.路由器、交换机、中继器），路由器工作在网络层，交换机工作在链路层，中继器工作在物理层。边：接入网链路（access,主机连接到互联网）&amp;主干链路（backbone,路由器之间）。协议：（按层次不同…，遵守同样的协议才能互通）<br>互联网：由以TCP协议和IP协议为主的一簇协议支撑的网络，网络之间任意连接。<br>从构成角度，互联网包括节点和边。<br>从服务角度，互联网是分布式的应用进程（分布式的应用是网络存在的理由），以及为分布式应用进程提供服务的基础设施，提供服务的形式是API（TCP提供有连接的可靠服务，UDP提供无连接的不可靠服务）。<br>物联网：为生产生活提供便利的联网产品。<br>互联网的协议：RFC,IETF。<br>协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收或其它事件方面所采取的动作。</p><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>网络边缘：主机&amp;应用程序（客户端和服务器）<br>网络核心：互联着的路由器&amp;网络的网络。作用：数据交换。<br>网络核心的作用：宏观上，全球范围内的，几十亿个节点之间的，数据交换；微观上，大量单个的路由器及其链路相互构成的分布式系统，由它们的相互配合，来完成从源主机到目标主机之间的发送与接收。<br>接入网、物理媒体：有线或者无线通信链路<br>通过网络核心实现主机与主机之间的联通</p><font color="purple">边缘 接入 核心</font><p>基础设置为分布式应用提供通信服务。<br>应用进程通信的模式：<br>（1）CS模式（客户/服务器模式）：客户端向服务器请求、接收服务。e.g.Web浏览器,email客户端/服务器。<br>（2）对等模式（peer-peer）：每个节点即使客户端又是服务器，解决了CS模式不可扩展的缺点</p><p>网络边缘定义：采用网络设施的面向连接服务。<br>网络边缘目标：在端系统之间传输数据。<br>握手：在数据传输之前做好准备。（面向连接的通信方式；通信状态只在端系统维护，网络不知道）<br>TCP：互联网上面向连接服务。<br>TCP服务特性：可靠性，保序，流量控制，拥塞控制<br>使用在UDP之上的两个进程：无连接服务，不可靠，没有流量控制，没有拥塞控制，实时性。</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心：路由器的网状网络。<br>数据怎样通过网络进行传输：（1）电路交换；（2）分组交换。</p><h4 id="电路交换（线路交换）"><a href="#电路交换（线路交换）" class="headerlink" title="电路交换（线路交换）"></a>电路交换（线路交换）</h4><p>call: 端到端的资源被分配给从源端到目标端的呼叫。<br>为呼叫预留端-端资源。要求建立呼叫连接。<br>一次呼叫采用了某条链路的某条线路（piece）；<br>优点：独享资源，不共享，没人抢，性能有保障；<br>缺点：如果呼叫没有数据发送，被分配的资源就会被浪费；<br>通常被传统网络电话采用。<br>网络资源（如带宽）被分成<font color="purple">片</font><br>将带宽分成片：频分（FDM: frequency-division multiplexing），时分（TDM: time-division multiplexing），波分（WDM: wave-division multiplexing 光纤通信），码分（CDM）。<br>为呼叫分配片。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q：两个节点（主机A和主机B）之间通信的带宽是1.536Mbps，采用时分多路复用，分为24个时隙（时槽，slot），每个用户使用其中第n个时隙。</span><br><span class="line">两个主机在通信前建立线路需要500ms（毫秒），文件大小640k</span><br><span class="line">A：每个用户能获得的带宽（一片的通信能力）=1.536Mbps/24=64Kbps（采用TDM的方式，只能获得这个通信链路的1/24）</span><br><span class="line">①建立连接所需的时间=500ms=0.5s</span><br><span class="line">②文件传输所需的时间=640Kbits/64Kbps=10s</span><br><span class="line">共用时间=0.5s+10s=10.5s</span><br><span class="line">③传播延迟：局域网下，可忽略不计；广域网下，要考虑传播时间</span><br><span class="line">1bit在空间上传输所需的时间=1/64Kbps*30万公里/秒（真空）</span><br></pre></td></tr></table></figure><br>电路交换不适合计算机之间的通信：<br>（1）连接建立时间长；<br>（2）计算机间通信有突发性，使用电路交换浪费的片较多；<br>（3）可靠性不高。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>以分组为单位存储：网络带宽资源不再分为一个个片，传输时使用全部带宽；主机之间传输的数据被分为一个个分组。<br>优点：资源共享，按需存储。</p><p><font color="purple">以存储-转发的方式工作</font><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在一个速率为R bps的链路</span><br><span class="line">一个长度为L bit的分组的存储转发延时=L/R s</span><br><span class="line">若L=7.5Mbits，R=1.5Mbps</span><br><span class="line">三次存储-转发延时=7.5Mbits/1.5Mbps*3=15s</span><br></pre></td></tr></table></figure><br>缺点：排队和延迟：如果到达速率&gt;链路的输出速率，分组将会排队，等待传输；如果路由器缓存用完，分组将会被丢弃。</p><p>网络核心的关键功能：路由（全局，决定分组采用的源到目标路径） &amp; 转发（局部，查路由表，将分组从路由器的输入链路转移到输出链路）</p><p>分组交换：统计多路复用（没有固定的分组模式）</p><p>分组交换适合突发式数据传输：资源共享；简单，不必建立呼叫。<br>分组交换过度使用会造成网络拥塞：分组延时和丢失。对可靠地数据传输需要协议来约束：拥塞控制。</p><p>分组交换按有无网络层的连接分类：数据报网络（主机之间没建立连接，不维护状态，路由器根据分组的目标地址进行路由），虚电路网络（有连接，虚拟电路建立逻辑连接，每个交换节点都有标识）</p><h4 id="分组交换-VS-电路交换"><a href="#分组交换-VS-电路交换" class="headerlink" title="分组交换 VS 电路交换"></a>分组交换 VS 电路交换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q：n人共享带宽为1Mbps的链路，每个用户活跃时为100Kb/s，有P=10%的时候是活跃的，问采用电路交换或分组交换分别支持的用户人数。（Kb/s即Kbps，Kb每秒）</span><br><span class="line">A：①采用电路交换最多支持的用户人数=1Mbps/(100Kbps)=10人</span><br><span class="line">②采用分组交换：假设共有N=35个用户，那么支持10个用户活跃的可能性为</span><br></pre></td></tr></table></figure><p>$1-\sum_{n=0}^{10} \binom{35}{n} P^n (1-P)^{35-n}$ =0.0004=0.04%（概率论二项分布）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用1减后，就是10个以上用户同时活跃的概率；</span><br><span class="line">总共35个用户时，有0.04%的情况下是不够用的，10人以上就超过1Mbps了，有99.96%的概率没问题。</span><br><span class="line">所以，采用分组交换共享性更好。</span><br></pre></td></tr></table></figure></p><h3 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h3><p>怎样接入核心<br>怎样将端系统和边缘路由器连接：住宅接入网，单位接入网（学校，公司），无线接入网<br>接入网的重要概念：带宽（bps, bits per second）</p><ol><li>住宅接入：modem（调制解调器）<br>调制解调器用于将电话信号或光信号转为网络信号。<br>调制解调器分为连接电话线的和连接光缆的，即猫和光猫。<br>接入网：线缆网络<br>混合光纤同轴电缆（HFC，hybrid fiber coax）：非对称<br>线缆和光纤网络将各家庭用户接入到ISP路由器。</li><li>企业接入网络：Eternet（以太网）<br>有线：出口不止一个<br>以太网一般是指有线连接</li><li>无线接入网<br>各无线端系统共享无线接入网络。<br>无线LANs（局域接入，WiFi，接入带宽越来越快）&amp;广域无线接入（4G or 5G）。</li><li>物理媒体<br>Bit（比特）：在传输-接收对间传播。<br>物理链路：在每个传输-接收对，跨越一种物理媒体。<br>导引型媒体：信号沿着固体媒介被导引（同轴电缆、光纤、双绞线）。<br>非导引型媒体：信号自由传播（无线电）。<br>双绞线（TP）：两根绝缘铜线。<br>同轴电缆：两根同心的铜导线，双向，基带电缆（电缆上一个单信道，Ethernet），宽带电缆（电缆上有多个信道，HFC）。<br>光缆：光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输；高速，低误码率，安全。</li><li>物理媒介：无线链路<br>双向<br>传播环境效应：反射，吸收，干扰<br>无线链路类型：地面微波，LAN，wide-area(蜂窝)，卫星（延迟不可忽略）</li></ol><h3 id="1-5-Internet结构和ISP"><a href="#1-5-Internet结构和ISP" class="headerlink" title="1.5 Internet结构和ISP"></a>1.5 Internet结构和ISP</h3><p>ISP：Internet Service Providers<br>关联比较密集的网络称为ISP。<br>端系统通过接入ISPs接入互联网。<br>接入ISP的端系统彼此互联。ISP之间通过互联网接入点IXP完成交换。<br>任何两个端系统可以相互发送分组到对方。<br>ISP提供接入，提供网（学校，企业，无法为全球提供）；ICP提供业务和内容。<br>ISP之间的连接：高层ISP&amp;低层ISP，2个ISP对等接入（不收费），IXP&amp;ISP（不收费），ICP&amp;ISP</p><p>Internet结构：<font color="purple">松散的层次模型</font><br>（1）中心：第一层ISP（点很少，国家/国际覆盖，速率极高，直接与其它第一层ISP相连，与大量的第二层ISP和其他客户网络相连，<font color="purple">global</font>）<br>（2）第二层ISP：更小些的ISP，区域性的（<font color="purple">regional</font>）<br>（3）第三层ISP与其它本地ISP：接入网与端系统最近（<font color="purple">local</font>）</p><h3 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h3><ol><li>分组延时和丢失的原因：<br>在路由器缓冲区的分组队列，<br>（1）分组到达链路的速率超过了链路输出的能力（分组到达时，没有可用的缓冲区）；<br>（2）分组等待排到队头、被传输</li><li><p>四种分组延时：<br>（1）节点处理延时：检查bit级差错；检查分组首部和决定将分组导向何处；<br>（2）排队延时：在输出链上等待传输的时间；依赖于路由器的拥塞程度（随机）；取决于流量强度（越趋近于1，延时越大，且是无限大）；<br>（3）传输延时：打出bit的时间，将分组发送到链路上的时间=L/R，存储转发延时；<br>（4）传播延时：物理延时=d（物理链路的长度）/s（在媒体上的传播速度≈2*10^8m/s）</p><script type="math/tex; mode=display">d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}</script></li><li><p>分组丢失的原因：<br>（1）链路的队列缓冲区容量有限<br>（2）当分组到达一个满的队列时，该分组将会丢失<br>（3）丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</p></li><li>吞吐量：在源端和目标端之间传输的速率（数据量/单位时间）。<br>（1）瞬间吞吐量：在一个时间点的速率<br>（2）平均吞吐量：在一个长时间内的平均值<br>瓶颈链路：端到端路径上，限制端到端吞吐量。<br>最细的部分决定吞吐多少数据。端到端平均吞吐=min{R1,R2…Rn}（R1-Rn为端到端之间的多条链路）<br>e.g.第一跳的链路共8个人用，我获得1/8的带宽（一跳的意思是一个路由）。每条链路都有确定的最小带宽为瓶颈带宽，它限制了节点A到节点B之间的吞吐量。</li></ol><h3 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h3><p>互联网是一个非常复杂的系统。采用分层的方式实现计算机网络的功能。<br>两个应用进程交换应用报文实现各种网络应用（电子交易，远程登录，数据库查询，域名解析，文件上传下载等）</p><ol><li>服务<br>服务：低层实体向上层实体提供它们之间的通信的能力。（服务用户，服务提供者）<br>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的。<br>服务访问点（SAP：Service Access Point)：下层的服务提供者来区分不同上层用户穿过层间的信息，因为服务提供者可能同时向多个上层用户提供服务。</li><li>服务的类型<br>（1）无连接的服务（Connectionless Service）：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃；<br>特点：不可靠、可能重复、可能失序<br>IP分组，数据包<br>适用范围：适合传送零星数据；<br>服务类型：不可靠的数据报、电子方式的函件；有确认的数据报、挂号信；请求回答，信息查询。<br>（2）面向连接的服务（Connection-oriented Service）：建立连接，通信，拆除连接。<br>适用范围：大数据块的传输，不适合小的零星报文<br>特点：保序（不绝对）<br>服务类型：可靠的信息流（传送页面）；可靠的字节流（远程登录）；不可靠的连接（数字化声音）。<br>两个应用进程采用UDP的方式交互，UDP向进程提供的是无连接的服务。</li><li>服务与协议的区别 ★★★<br>（1）服务（Service）：通过相邻层间的接口在系统的内部（Interface上的SAP上，使用SAP是为了一个服务同时向多个用户提供服务），通过原语的形式向上层提供服务。低层实体向上层实体提供它们之间的通信的能力，是通过原语来操作的，垂直。<br>（2）协议（Protocal）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平。<br>服务与协议的联系：<font color="purple">协议的实现借助于下层提供的服务，协议的目的是为了向上层提供服务。<br>（实现本层写一需要借助下层提供的服务，实现本层协议的目的是为了向上层提供更好的服务）<br>协议是水平的，服务是垂直的。（水平协议，垂直服务）<br>服务的形式：原语</font></li><li>数据单元（DU）★★★<br>SDU + ICI = PDU   服务数据单元 + 接口控制信息 = 协议数据单元<br>进入每个子层未被处理的数据称为<font color="purple">服务数据单元</font>(SDU：service data unit)，经过子层处理后形成特定格式的数据被称为<font color="purple">协议数据单元</font>(PDU)<br>上层来了SDU，通过层间接口后，形成了这个SDU在第n层的头部（n-header），加起来形成了第n层的PDU（n-PDU），n-PDU再往下一层又成了下一层的SDU。（只是理论上的完美情况）<br>如果SDU是一个大数据块，SDU到达第n层厚会分成多个块，每一块分别加上n-header，形成多个n-PDU。<br>每一层的PUD都有head和body。body部分一定来自上层的SDU。<br>头部信息，有一部分是ICI附加上去的，有一部分是来自本层。<br>PDU是最常见的数据单元。<br>每一层的数据单元都有特定的称呼：<br>（1）应用层-&gt;应用报文（message）<br>（2）传输层-&gt;报文段（segment，简称：段；TCP:段，UDP:数据报）<br>（3）网络层-&gt;分组（packet，有连接）；数据报（datagram，无连接）<br>（4）链路层-&gt;帧（frame）<br>（5）物理层-&gt;位（bit） 等等</li><li>分层处理和实现复杂系统的好处：<br>（1）概念化：结构清晰，便于标示网络组件，以及描述其相互关系。<br>（2）结构化：模块化更易于维护和系统升级。改变某一层服务的实现不影响系统其它部分。</li><li>分层处理的缺点：效率低</li><li>Internet协议栈（每个层次分别有什么协议）<br>应用层：网络应用，FTP，SMTP，HTTP，DNS（应用层的协议是最多的）<br>传输层：主机之间的数据传输，TCP，UDP，<font color="purple">进程到进程</font>，把网络层提供的可能不可靠的通信服务变为可靠的通信服务<br>网络层：为数据报从源到目的选择路由，IP，路由协议（RIP OSPF BGP），E2E<font color="purple">端到端</font>（End to End）<br>链路层：<font color="purple">相邻</font>网络节点间的数据（以帧为单位）传输，点对点协议PPP，802.11（wifi），Ethernet<br>物理层：在线路上传送bit</li><li>ISO/OSI模型（与TCP/IP模型不同）<br>七层模型：应用层-&gt;<font color="orange">表示层-&gt;会话层</font>-&gt;传输层…<br>表示层：解释传输的数据（e.g.加密，压缩）<br>会话层：数据交换的同步，检查点，恢复<br>这两层的功能在TCP/IP模型中是应用层做的。</li></ol><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>…</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/12/28/LearnNet/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>换电脑后怎样迁移Hexo博客</title>
      <link>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/</link>
      <guid>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/</guid>
      <pubDate>Fri, 06 Dec 2024 00:03:11 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-安装Nodejs&quot;&gt;&lt;a href=&quot;#1-安装Nodejs&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Nodejs&quot;&gt;&lt;/a&gt;1. 安装Nodejs&lt;/h2&gt;&lt;p&gt;安装最新版本的&lt;a href=&quot;https://nodejs.org/z</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1. 安装Nodejs"></a>1. 安装Nodejs</h2><p>安装最新版本的<a href="https://nodejs.org/zh-cn">Nodejs</a>。</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>安装最新版本的<a href="https://git-scm.com/">Git</a>。<br>配置全局email和name：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br></pre></td></tr></table></figure><br>检查配置信息：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></p><h2 id="3-迁移博客文件夹"><a href="#3-迁移博客文件夹" class="headerlink" title="3. 迁移博客文件夹"></a>3. 迁移博客文件夹</h2><ol><li><p>将文件夹迁移到新电脑后，在该文件夹内右键打开Git Bash。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/1.png" width="40%"></p></li><li><p>安装hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>大约需要几分钟的时间。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/2.png" width="60%"><br>然后就可以将博客在本地启动了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>配置新电脑的SSH key<br>在执行<code>hexo d</code>的时候会报<code>Spawn failed</code>错误，原因是新电脑还没有Git全局的SSH key，无法与Github仓库匹配。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/3.png" width="60%"><br><br><code>win+R</code>运行<code>cmd</code>终端，并输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>两个密钥文件将保存到该默认目录下，不需要更改位置；<br>按照提示信息确认目录，以及是否配置密码（可以为空）：<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/4.jpg" width="60%"><br>找到这个目录下的配置文件，上面的是私钥，下面的是公钥：<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/5.png" width="60%"><br>如果博客仓库在GitHub上，菜单栏打开Settings，找到SSH and GPG keys，新建一个SSH key；<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/6.png" width="40%"><br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/7.png" width="60%"><br>使用记事本打开本地的公钥文件（pub文件），全选文字，复制到GitHub。<br><br>然后就可以博客就可以照常更新了~</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Git/">Git</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统概述2</title>
      <link>https://pearlchocolatezy.com/2024/10/16/LearnOS2/</link>
      <guid>https://pearlchocolatezy.com/2024/10/16/LearnOS2/</guid>
      <pubDate>Wed, 16 Oct 2024 14:25:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 中断系统：中断系统是计算机的重要组成部分。中断装置和中断处理程序统称为中断系统。实时控制、故障自动处理、计算机与外围设备间的数据传送</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 中断系统：中断系统是计算机的重要组成部分。中断装置和中断处理程序统称为中断系统。实时控制、故障自动处理、计算机与外围设备间的数据传送往往采用中断系统。中断系统的应用大大提高了计算机效率。</p><p>1.2 进程的互斥：在逻辑上本来完全独立的若干进程，由于竞争同一个资源而产生相互制约关系。</p><p>1.3 进程的同步：进程间共同完成一项任务时直接发生相互作用的关系，在执行时间次序上必须遵循确定的规律。</p><p>1.4 I/O设备控制方式中的“程序控制方式”（PIO: Programmed I/O）：指由用户进程直接控制处理器，或内存和外部设备之间进行信息传送的方式，也称为“忙-等”方式、轮询方式或循环测试方式。这种方式的控制者是用户进程。</p><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><p>3.1 进程进入临界区的调度原则<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</span><br><span class="line">2. 任何时候，处于临界区内的进程不可多于一个，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</span><br><span class="line">3. 进入临界区的进程要在有限时间内退出以便其它进程能及时进入自己的临界区；</span><br><span class="line">4.如果进程不能进入自己的临界区，则应让出CPU避免出现“忙等”现象。</span><br></pre></td></tr></table></figure></p><p>3.2 防止死锁产生的途径<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用某些资源分配策略使死锁的四个条件之一不成立，就能防止死锁。</span><br><span class="line">1. 目前对于“互斥使用资源”条件没有应对策略；</span><br><span class="line">2. 对“占有并等待资源”、“不可抢夺资源”和“循环等待资源”这三个条件，可采用静态分配资源、释放已占资源、抢夺式分配资源和按序分配资源等资源分配策略。</span><br></pre></td></tr></table></figure></p><p>3.3 文件系统为什么要实现“按名存取”？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 要把文件存放到存储介质上或要从存储介质上读出文件，都必须记住存储空间的使用情况、文件存放的物理位置，以及启动相应的存储设备来保存和读出文件。</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/OS/">OS</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/10/16/LearnOS2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库系统原理概述</title>
      <link>https://pearlchocolatezy.com/2024/10/02/LearnDB/</link>
      <guid>https://pearlchocolatezy.com/2024/10/02/LearnDB/</guid>
      <pubDate>Wed, 02 Oct 2024 08:40:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 游标：游标是数据库管理系统(DBMS)中的一种对象，主要用于在处理查询返回结果时逐行读取数据。游标的类型有两种：显示游标（一次读多行</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 游标：游标是数据库管理系统(DBMS)中的一种对象，主要用于在处理查询返回结果时逐行读取数据。游标的类型有两种：显示游标（一次读多行）、隐式游标（一次读一行）。</p><p>1.2 结构化查询语言：一种专门用来与数据库通信的语言，它可以帮助用户操作关系型数据库。例：SQL。</p><p>1.3 触发器：用户定义在关系表上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法。</p><p>1.4 数据库分割：将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 数据库分析与设计阶段的四个环节：需求分析、概念设计、逻辑设计、物理设计。</p><p>2.2 在MySQL中，一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p><p>2.3 视图表是由基本表或其他视图导出的表，是虚表，不对应实际存储的数据。</p><p>2.4 对于填有数据的游标，在MySQL中，可以使用<code>FETCH...INTO</code>语句从中读取数据。</p><p>2.5 完整性约束性条件的作用对象可以是列、元组和表。</p><p>2.6 大数据是指无法在可容忍的时间内用现有信息技术和软、硬件工具对其进行感知、获取、管理、处理的服务和数据聚合。</p><p>2.7 数据的集成是数据库管理系统的主要目的。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 （设计）某高校教师项目信息管理系统的数据库包含三个关系：<br>教师（教师工号，姓名，性别，年龄，职称）<br>项目（项目号，项目名称，级别）<br>申报（教师工号，项目号，工作量）<br>试实现下列操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--(1)使用关系代数查询“省级”级别的项目信息。</span></span><br><span class="line">σ级别<span class="operator">=</span>&quot;省级&quot;(项目)</span><br><span class="line"></span><br><span class="line"><span class="comment">--(2)使用关系代数查询教师的教师工号、姓名和职称。</span></span><br><span class="line">π教师工号,姓名,职称(教师)</span><br><span class="line"></span><br><span class="line"><span class="comment">--(3)使用SQL语句将“王宏”老师的职称改为“教授”。</span></span><br><span class="line"><span class="keyword">update</span> 教师 <span class="keyword">set</span> 职称<span class="operator">=</span>&quot;教授&quot; <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;王宏&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--(4)使用SQL语句查询申报项目名称为“图像采集”的教师工号。（用嵌套查询）</span></span><br><span class="line"><span class="keyword">select</span> 教师工号 <span class="keyword">from</span> 申报 <span class="keyword">where</span> 项目号 <span class="keyword">in</span> (<span class="keyword">select</span> 项目号 <span class="keyword">from</span> 项目 <span class="keyword">where</span> 项目名称<span class="operator">=</span><span class="string">&#x27;图像采集&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--(5)使用SQL语句查询每名教师的总工作量</span></span><br><span class="line"><span class="keyword">select</span> 教师工号, <span class="built_in">sum</span>(工作量) <span class="keyword">as</span> 总工作量 <span class="keyword">from</span> 申报 <span class="keyword">group</span> <span class="keyword">by</span> 教师工号;</span><br></pre></td></tr></table></figure><p>3.2 简述三种典型的并发操作问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 丢失更新。</span><br><span class="line">设有两个事务T1和T2，当他们同时读入一个数据并加以修改时，事务T2的提交结果会破坏事务T1提交的结果。</span><br><span class="line">2. 不可重复读。</span><br><span class="line">两个事务T1和T2，不可重复读是指事务T1读取数据后，事务T2执行更新操作，使事务T1无法再现前一次读取的结果。</span><br><span class="line">3. 读“脏”数据。</span><br><span class="line">设有两个事务T1和T2，事务T1修改某一个数据，并将其写回磁盘，事务T2读取同一个数据后，事务T1由于某种原因被撤销，这时事务T1已修改过的数据恢复原值，事务T2读到的数据就与数据库中的数据不一致，则事务T2读到的数据就为“脏”数据。</span><br></pre></td></tr></table></figure></p><p>3.3 简述关系模型完整性约束的检验方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 执行插入操作时，首先检查实体完整性约束，然后检查参照完整性约束，最后检查用户定义完整性约束。</span><br><span class="line">2. 执行删除操作时，一般只需要对被参照关系检查参照完整性约束。</span><br><span class="line">3. 执行更新操作时，因为更新操作可看成是先执行删除操作，再执行插入操作，因此是上述两种情况的综合。</span><br></pre></td></tr></table></figure></p><p>3.4 简述SQL的核心组成部分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 数据定义语言</span><br><span class="line">2. 数据操纵语言。</span><br><span class="line">3. 数据控制语言。</span><br><span class="line">4. 嵌入式和动态SQL规则。</span><br><span class="line">5. SQL调用和会话规则。</span><br></pre></td></tr></table></figure></p><p>3.5 简述删除存储函数的语句及注意事项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除语句：DROP FUNCTION。</span><br><span class="line">注意事项：</span><br><span class="line">（1）在删除之前，必须确认该存储函数没有任何依赖关系，否则会导致其他与之关联的存储函数无法运行。</span><br><span class="line">（2）为防止因删除不存在的存储函数而引发错误，可在DROP FUNCTION语句中添加关键字“IF EXISTS”。</span><br></pre></td></tr></table></figure></p><p>3.6 简述关系数据模型的优化方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定各属性间的函数依赖关系。</span><br><span class="line">2. 对于各个关系模型之间的数据依赖进行极小化处理，消除冗余的联系。</span><br><span class="line">3. 判断每个关系模式的范式，根据实际需要确定最合适的范式。</span><br><span class="line">4. 按照需求分析阶段得到的处理要求，对某些模式进行合并或分解。</span><br><span class="line">5. 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率。</span><br></pre></td></tr></table></figure></p><p>3.7 （综合）某大学图书管理信息系统需要管理如下信息：<br>图书（图书号，书名，作者，定价）<br>学生（学号，姓名，专业）<br>出版社（出版社名称，地址，电话，邮编）<br>其中：一个出版社可以出版多种图书，但每本图书只能在一个出版社出版；每位学生可以借阅多本图书，每本图书可以供多维学生借阅；学生借书要记录借书日期和还书日期。试完成下列要求：<br>（1）实体关系的E=R图<br><img class="zy_img_shadow" src="/2024/10/02/LearnDB/3.7.1.jpg" alt width="60%"></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant Alice    participant Bob    Alice -&gt;&gt; Bob: 你好，Bob！    Bob --&gt;&gt; Alice: 你好，Alice！  </pre></div><p>（2）转换成关系模式<br>图书（图书号，书名，作者，定价，）</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/SQL-Server/">SQL Server</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/10/02/LearnDB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统概述</title>
      <link>https://pearlchocolatezy.com/2024/09/26/LearnOS/</link>
      <guid>https://pearlchocolatezy.com/2024/09/26/LearnOS/</guid>
      <pubDate>Thu, 26 Sep 2024 14:40:51 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;
&lt;p&gt;1.2 线</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><p>1.2 线程：线程是进程中的一个实体，是处理器调度和分派的基本单位。可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><p>1.3 原语：原语是由若干条指令所组成的一个指令序列。用来实现某个特定的操作功能。具有连续性，不可分割性。在执行时也不可间断，必须在管态下执行，并且常驻内存。</p><p>1.4 创建原语：是指创建一个新的进程，前者称为父进程，后者称为子进程建立进程控制块PCB。</p><p>1.5 DMA (Direct Memory Access)：直接内存访问，是一种完全由硬件执行I/O数据交换的工作方式。</p><p>1.6 通道：通道是一个特殊功能的处理器，它有自己的指令和程序，可以实现对外部设备的统一管理和外部设备与内存之间的数据传送。</p><p>1.7 SPOOLING (Simultaneous Peripheral Operations On-Line)：外部设备联机并行操作(虚拟设备技术)。它是关于慢速字符设备如何与计算机主机交换信息一种技术，通常称为“假脱机技术”。是多道程序设计系统中处理独占I/O设备的一种方法，能将独占设备转变为共享设备，可以提高设备利用率并缩短单个程序的响应时间。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 计算机系统的资源包括两大类：硬件资源和软件资源。</p><p>2.2 操作系统的两大发展方向：宏观应用、微观应用。</p><p>2.3 操作系统启动的引导方式：BIOS引导，UEFI引导。</p><p>2.4 操作系统的启动过程：BIOS自检、系统引导、启动内核、初始化系统。</p><p>2.5 操作系统管理程序运行的状态称为<font color="purple">管态</font>。<br>系统启动时，处理器的初始状态为管态。<br>当处理器处于管态时，可以执行全部指令。<br>当用户程序占用处理器时，应让处理器在<font color="purple">目态</font>下工作。</p><p>2.6 处理器的状态字（PSW）通常包含以下状态代码：(1)CPU的工作状态代码；(2)条件码；(3)中断屏蔽码。</p><p>2.7 所有的子系统都可以包括在<font color="purple">硬件（子）系统</font>和<font color="purple">软件（子）系统</font>。</p><p>2.8 系统软件包括：操作系统、编译系统、数据库。</p><p>2.9 硬件系统：中央处理器、存储系统、中断机制、I/O技术、时钟。</p><p>2.10 内存空间的最小分配单位为<font color="purple">块</font>，这样的块有时被称为一个物理页(Page)。</p><p>2.11 时钟中断处理程序的主要内容：(1)维护软件时钟；(2)处理器调度；(3)控制系统定时任务；(4)实时处理。</p><p>2.12 允许优先级较高的中断打断优先级较低的中断处理过程称为<font color="purple">中断嵌套</font>。</p><p>2.13 时钟分为<font color="purple">硬件时钟</font>和<font color="purple">软件时钟</font>。</p><p>2.14 <font color="purple">系统调用</font>是操作系统提供给编程人员的唯一接口。</p><p>2.15 进程从运行状态进入就绪状态的原因可能是：时间片用完。</p><p>2.16 七状态模型和五状态模型相比，增加了<font color="purple">就绪挂起</font>和<font color="purple">阻塞挂起</font>两个状态。</p><p>2.17 操作系统把所有的PCB用适当方式组织起来。一般的组织方式：线性方式、索引方式、链接方式。</p><p>2.18 同一个进程中的各个线程共享该进程的内存地址空间。</p><p>2.19 对进程在整个生命周期中各种状态之间的转换进行有效的控制通过<font color="purple">进程控制原语</font>来实现。</p><p>2.20 <font color="purple">线程</font>作为调度和分派的基本单位，<font color="purple">进程</font>作为资源拥有的基本单位。</p><p>2.21 线程的实现机制：用户级线程、内核级线程、混合方式。</p><p>2.22 CPU主要的两级调度：进程调度、作业调度。</p><p>2.23 <font color="purple">时间片轮转法</font>主要用于分时系统中的进程调度。</p><p>2.24 <font color="purple">保证调度算法</font>的目标是保证每个进程享用CPU的时间完全一样，即如果系统里一共有n个进程，则每个进程占用CPU的时间为<font color="purple">1/n</font>。</p><p>2.25 <font color="purple">彩票调度算法</font>是一种概率调度算法。</p><p>2.26 基于进程组的调度决策是非常有吸引力的，该方法通常称作<font color="purple">公平共享调度</font>。</p><p>2.27 BSD UNIX系统主要用于<font color="purple">分时交互</font>环境中。</p><p>2.28 Linux系统的调度方式基本上采用<font color="purple">抢占式优先级</font>方式。</p><p>2.29 Windows中的优先级被组织成两段：<font color="purple">实时</font>和<font color="purple">可变</font>。</p><p>2.30 任何情况下，都可以把系统看作是<font color="purple">多服务器排队</font>结构。</p><p>2.31 线程调度常用方法有：加载共享、组调度、专用处理器分配、动态调度。</p><p>2.32 为周期性任务解决多任务调度冲突的一个非常好的方法是<font color="purple">速率单调调度RMS</font>。</p><p>2.33 <font color="purple">优先级逆转</font>是在任何基于优先级的可抢占的调度方案中都能发生的一种现象，但是它与实时调度的上下文关联特别大。</p><p>2.34 <font color="purple">优先级继承协议</font>的基本思想是优先级较低的任务继承任何与它共享同一个资源的优先级较高的任务的优先级。</p><p>2.35 采用动态重定位的系统支持“程序浮动”。</p><p>2.36 存储管理的主要任务包括：内存的分配与回收、内存扩充、存储共享、存储保护。</p><p>2.37 在存储管理中，将绝对地址对应的存储空间称为<font color="purple">物理地址空间</font>，将逻辑地址对应的存储空间称为<font color="purple">逻辑地址空间</font>。</p><p>2.38 通过分区管理，内存真正成为了共享资源，提高了系统得到吞吐量和缩短了周转时间。</p><p>2.39 在可变区分存储管理方案中，解决碎片问题的一个有效办法是采用<font color="purple">紧缩技术</font>，通过移动内存中程序，把<font color="purple">所有空闲碎片</font>的合并成一个连续的大空闲区，置于内存的一端，把<font color="purple">所有程序占用区</font>的放在内存的另一端。</p><p>2.40 采用页式存储管理的主要目的是：提高内存的利用率。</p><p>2.41 大多数操作系统采用的进程页表是二级页表：即由页表页和页目录一起构成进程页表。</p><p>2.42 分页后，逻辑地址由两部分组成：虚拟页号，页内地址。</p><p>2.43 流式文件是有序字符的集合。</p><p>2.44 常用的文件物理结构：索引结构、链接结构、顺序结构。</p><p>2.45 文件按组织形式进行分类：普通文件、目录文件、特殊文件。<br>文件按文件用途进行分类：库函数文件、用户文件。</p><p>2.46 文件常用的存取方法：顺序存取、随机存取。</p><p>2.47 链式结构，有利于文件动态扩充，解决了存储的碎片问题，但不适合随机存取。</p><p>2.48 磁盘空间的分配与回收算法：位示图、空闲块表、空闲块链表。</p><p>2.49 把若干个逻辑记录合成一组，存入一个物理块的工作称为<font color="purple">记录的成组</font>。</p><p>2.50 记录的成组和分解技术是磁盘高速缓存的一种应用，虽然需要代价，但是具有提高<font color="purple">存储空间利用率</font>和减少<font color="purple">启动设备次数</font>的优点。</p><p>2.51 用来解决磁盘速度慢、出现故障的技术是<font color="purple">RAID技术</font>。</p><p>2.52 RAID2和RAID3以<font color="purple">位</font>或<font color="purple">字节</font>作为并行单位。</p><p>2.53 规定用户使用文件的权限的方法：<font color="purple">树形目录结构</font>、<font color="purple">存取控制表</font>。</p><p>2.54 UNIX的文件使用权限管理方案中，对文件存取权限的设置方法：<font color="purple">存取控制矩阵</font>和<font color="purple">二级存取控制</font>。</p><p>2.55 按设备的使用特性分类：（1）输入设备；（2）输出设备；（3）交互式设备；（4）存储设备。</p><p>2.56 设备驱动程序是操作系统底层中唯一知道各种输入输出设备的控制器细节以及其用途的部分。</p><p>2.57 设计I/O软件的一个最关键目标是设备独立性。</p><p>2.58 键盘、终端、打印机等以<font color="purple">字符</font>为单位组织好处理信息的设备。</p><p>2.59 I/O硬件由<font color="purple">物理设备</font>和<font color="purple">电子部件</font>两部分组成。</p><p>2.60 在典型的计算机系统硬件结构中，CPU与内存在最里层，通过总线与第二层的<font color="purple">适配器（接口）</font>部件相连，第三层是<font color="purple">各种外围设备控制器</font>，最外层是外围设备。</p><p>2.61 从功能上看，<font color="purple">设备独立层</font>是I/O软件的主要部分；<br>从代码量上看，<font color="purple">设备驱动层</font>是I/O软件的主要部分。</p><p>2.62 I/O设备管理中，可按照两种方式进行设备分配：<font color="purple">静态分配</font>和<font color="purple">动态分配</font>。</p><p>2.63 两种常用设备分配策略：先来先服务、高优先级优先。</p><p>2.64 设备分配表由<font color="purple">设备类表</font>和<font color="purple">设备表</font>组成。</p><p>2.65 常用的磁盘移臂调度算法：先来先服务调度算法、最短寻找时间优先调度算法、电梯调度算法、单向扫描调度算法。</p><p>2.66 缓冲出把多个缓冲区连接起来统一管理。</p><p>2.67 SPOOLING系统主要包括：输入程序模块、输出程序模块、作业调度程序。</p><p>2.68 Dijkstra把同步问题抽象成一种<font color="purple">生产者-消费者关系</font>。</p><p>2.69 对信号量的PV操作在程序流程上必定是成对出现，不能缺少，缺少了会<font color="purple">死锁</font>。</p><p>2.70 剥夺资源的常用方法：（1）还原算法，即恢复计算结果和状态；（2）建立检查点，用来恢复分配前的状态。</p><p>2.71 死锁产生的必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。</p><p>2.72 <font color="purple">哲学家就餐问题</font>是操作系统中关于进程同步与互斥的经典问题，也是涉及到<font color="purple">死锁</font>的关键问题。<br>在哲学家就餐问题中，为每只筷子设置一个信号量，一个哲学家通过在信号量上执行操作<font color="purple">P</font>抓起一只筷子，通过执行<font color="purple">V</font>操作放下一只筷子。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 操作系统的特性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 并发：在计算机系统中同时存在多个程序，宏观上，这些程序是在同时执行的；微观上，任何时刻只有一个程序在执行，即微观上这些程序在CPU上轮流执行。</span><br><span class="line">2. 共享：操作系统与多个用户的程序共同使用计算机系统中的资源。</span><br><span class="line">3. 虚拟性：虚拟性是一种管理技术，该技术把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物。</span><br><span class="line">4. 异步性：操作系统必须随时对不可预测的次序发生的事件进行响应。</span><br></pre></td></tr></table></figure></p><p>3.2 操作系统的主要功能：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理机管理功能：进程控制，进程同步，进程通信，调度。</span><br><span class="line">2. 存储器管理功能：内存分配，内存保护，地址映射，内存扩充。</span><br><span class="line">3. 设备管理功能：缓冲管理，设备分配，设备处理。</span><br><span class="line">4. 文件管理功能：文件存储空间的管理，目录管理，文件的读写管理和保护。</span><br><span class="line">5. 用户接口：命令接口，程序接口，图形接口。</span><br></pre></td></tr></table></figure></p><p>3.3 微内核结构及其基本原理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 微内核OS结构：能实现OS核心功能的小型内核。并非一个完整的OS，与OS的服务进程（如文件服务器、作业服务器等）共同构成OS。</span><br><span class="line">2. 基本原理：只有最基本的操作系统功能才能放在内核中。不是最基本的服务和应用程序在微内核之上构造，并在用户模式下执行。</span><br><span class="line">3. 微内核通常提供最小的进程和内存管理以及通信功能。微内核的主要功能是提供客户程序和运行在用户空间的各种服务之间进行通信的能力。通信以消息传递形式提供，一般采用客户/服务器模式。</span><br></pre></td></tr></table></figure></p><p>3.4 最常见的控制和状态寄存器：（了解）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 程序计数器（PC:Program Counter）：记录了将要取出的指令的地址。</span><br><span class="line">2. 指令寄存器（IR:Instruction Register）：包含了最近取出的指令。</span><br><span class="line">3. 程序状态字（PSW:Program Status Word）：记录了处理器的运行模式信息等。</span><br></pre></td></tr></table></figure></p><p>3.5 系统软件包括哪些软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统软件包括：系统软件、支撑软件、应用软件。</span><br><span class="line">系统软件：操作系统、编译系统。</span><br><span class="line">支撑软件：数据库、各种接口软件、软件开发工具等。</span><br><span class="line">应用软件：财务管理、人口普查等专用程序。</span><br></pre></td></tr></table></figure></p><p>3.6 简述指令的执行过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 每个取值周期先从存储器中读取一条指令。</span><br><span class="line">2. 在取指令完成后，根据指令类别将程序计数器的值变成下一条指令的地址，通常是自增1。</span><br><span class="line">3. 取到的指令被放在处理器的指令寄存器中。</span><br><span class="line">4. 处理器解释并执行命令。</span><br></pre></td></tr></table></figure></p><p>3.7 简述指令的分类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 访问存储器指令：负责处理器和存储器之间的数据传送。</span><br><span class="line">2. I/O指令：负责处理器和I/O模块之间的数据传送和命令发送。</span><br><span class="line">3. 算术逻辑指令（数据处理指令）：用以执行有关数据的算术和逻辑操作。</span><br><span class="line">4. 控制转移指令：这种指令可以指定一个新的指令的执行起点。</span><br><span class="line">5. 处理器控制指令：这种指令用于修改处理器状态，改变处理器工作方式。</span><br></pre></td></tr></table></figure></p><p>3.8 现代计算机采用的多级存储体系包括哪几部分？简述各部分功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多级存储体系包括寄存器、主存储器、高速缓冲存储器、辅助存储器。</span><br><span class="line">2. 寄存器用来存放处理器的工作信息。</span><br><span class="line">3. 主存储器用来存放当前要执行的程序和数据。</span><br><span class="line">4. 高速缓冲存储器用来存放当前经常要使用的信息。</span><br><span class="line">5. 辅助存储器作为主存储器的扩展，用来存放大量的程序和数据。</span><br></pre></td></tr></table></figure></p><p>3.9 中断响应是什么？中断处理程序主要工作有哪些方面？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器每执行完一条指令后，中断装置立即检查有无中断事件发生。</span><br><span class="line">2. 若有中断事件发生，则暂停现行进程的执行，而让操作系统的中断处理程序占用处理器。中断处理程序主要工作如下：</span><br><span class="line">(1) 保护被中断进程的现场信息；(2)分析中断原因；(3)处理发生的中断事件。</span><br></pre></td></tr></table></figure></p><p>3.10 简述通道的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 当处理器执行到一条“启动外设”指令时，就按指令中给定的参数启动指定的设备。</span><br><span class="line">2. 设备启动后，对该外部设备的控制权转移到通道。</span><br><span class="line">3. 该外部设备与主存储器之间发生的信息传送，由通道控制。</span><br><span class="line">4. 该外部设备工作结束后，会产生形成一个“输入输出操作结束”的I/O中断事件。</span><br></pre></td></tr></table></figure></p><p>3.11 简述时钟的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件时钟的工作原理：电路中的晶体振荡器，每隔一定间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加1的工作。</span><br><span class="line">2. 软件时钟的工作原理：利用内存单元模拟时钟寄存器，采用一段程序来计算响应的脉冲数，对内存时钟寄存器进行加1或减1的工作。</span><br></pre></td></tr></table></figure></p><p>3.12 简述时钟的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在多道程序运行，时钟可以发现死循环，防止机时的浪费。</span><br><span class="line">2. 在分时系统中，用时钟实现时间片轮转运行。</span><br><span class="line">3. 在实时系统中，按要求的时间间隔输出信号控制设备。</span><br><span class="line">4. 定时唤醒外部事件。</span><br><span class="line">5. 记录用户和系统所需要的绝对事件，即年、月、日。</span><br></pre></td></tr></table></figure></p><p>3.13 简述系统调用的分离<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个操作系统的功能分为两大部分：一部分是系统自身所需要的，另一部分功能是作为服务提供给用户的，有关这部分功能可以从操作系统所提供的系统调用上体现出来。</span><br><span class="line">1. 进程控制类系统调用。</span><br><span class="line">2. 文件操作类系统调用。</span><br><span class="line">3. 进程通信类系统调用。</span><br><span class="line">4. 设备管理类系统调用。</span><br><span class="line">5. 信息维护类系统调用。</span><br></pre></td></tr></table></figure></p><p>3.14 在七状态模型中，什么是阻塞状态？什么是阻塞挂起状态？两个状态之间如何转换<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 阻塞状态：进程在内存并等待某事件的出现。</span><br><span class="line">2. 阻塞挂起状态：进程在外存并等待某事件的出现。</span><br><span class="line">3. 没有进程处于就绪状态或就绪进程要求更多内存资源时，就会把阻塞状态编程阻塞挂起状态。</span><br><span class="line">4. 当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程激活，由阻塞挂起状态变成阻塞状态。</span><br></pre></td></tr></table></figure></p><p>3.15 进程具有哪些特性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 并发性：一个进程可以同其他进程一道向前推进。</span><br><span class="line">2. 动态性：进程有其生命周期，且进程的状态是不断变化的。</span><br><span class="line">3. 独立性：一个进程是一个相对完整的资源分配单位。</span><br><span class="line">4. 交往性：一个进程在运行过程中可能会与其他进程发生直接的或间接的相互作用。</span><br><span class="line">5. 异步性：每个进程按照各自独立的、不可预知的速度向前推进。</span><br><span class="line">6. 结构性：一个进程由程序、数据和进程控制块三部分组成。</span><br></pre></td></tr></table></figure></p><p>3.16 线程与进程的关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 线程是进程中可独立执行的子任务。</span><br><span class="line">2. 一个进程中可以有一个活多个线程。</span><br><span class="line">3. 同一进程中的各线程共享分配给进程的主存空间。</span><br><span class="line">4. 进程是资源分配单位，线程是调度和执行单位。</span><br><span class="line">5. 一个进程内的线程共享分配给该进程的资源。</span><br></pre></td></tr></table></figure></p><p>3.17 进程调度的主要功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 保存现场：记录系统中所有进程得到执行状况。</span><br><span class="line">2. 挑选进程：根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它。</span><br><span class="line">3. 恢复现场：为选中的进程恢复现场信息。</span><br></pre></td></tr></table></figure></p><p>3.18 在选择调度策略时应该考虑什么因素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 设计目标</span><br><span class="line">2. 公平性</span><br><span class="line">3. 均衡性</span><br><span class="line">4. 统筹兼顾</span><br><span class="line">5. 优先级</span><br><span class="line">6. 开销</span><br></pre></td></tr></table></figure></p><p>3.19 进程最短剩余时间优先调度算法的基本思路和实现方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最短进程优先算法的抢占版本是最短剩余时间优先(SRTN)算法。</span><br><span class="line">使用这个算法，调度程序总是选择其剩余运行时间最短的那个进程运行。</span><br><span class="line">当一个新的进程到达时，其整个时间同当前进程的剩余时间作比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短进程获得良好的服务。</span><br></pre></td></tr></table></figure></p><p>3.20☆ 某单CPU系统有如下一批处于就绪状态的进程。<br>(1) 给出<font color="purple">FCFS(先来先服务)</font>和<font color="purple">SJF(最短作业优先)</font>算法个进程的开始事件、完成时间、周转时间。<br>(2) 计算在各算法下的平均周转时间</p><p><table>    <th rowspan="2">进程进入就绪队列的先后顺序</th> <th rowspan="2">运行时间</th> <th colspan="3">FCFS</th> <th colspan="3">SJF</th>    <tr>        <td>开始时间</td> <td>完成时间</td> <td>周转时间</td> <td>开始时间</td> <td>完成时间</td> <td>周转时间</td>    </tr>    <tr>        <td>1</td> <td>10</td> <td class="td3_20">0</td> <td class="td3_20">10</td> <td class="td3_20">10</td> <td class="td3_20">9</td> <td class="td3_20">10</td> <td class="td3_20">19</td>    </tr>    <tr>        <td>2</td> <td>1</td> <td class="td3_20">10</td> <td class="td3_20">1</td> <td class="td3_20">11</td> <td class="td3_20">0</td> <td class="td3_20">1</td> <td class="td3_20">1</td>    </tr>    <tr>        <td>3</td> <td>2</td> <td class="td3_20">11</td> <td class="td3_20">2</td> <td class="td3_20">13</td> <td class="td3_20">2</td> <td class="td3_20">2</td> <td class="td3_20">4</td>    </tr>    <tr>        <td>4</td> <td>1</td> <td class="td3_20">13</td> <td class="td3_20">1</td> <td class="td3_20">14</td> <td class="td3_20">1</td> <td class="td3_20">1</td> <td class="td3_20">2</td>    </tr>    <tr>        <td>5</td> <td>5</td> <td class="td3_20">14</td> <td class="td3_20">5</td> <td class="td3_20">19</td> <td class="td3_20">4</td> <td class="td3_20">5</td> <td class="td3_20">9</td>    </tr></table><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平均周转时间：</span><br><span class="line">FCFS：(10+11+13+14+19)/5=13.4</span><br><span class="line">SJF：(19+1+4+2+9)/5=7</span><br></pre></td></tr></table></figure></p><p>3.21 加载共享的缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中心队列占据了必须互斥访问的存储器区域，被抢占的线程可能不在同一个处理器上恢复执行。如果一个程序的线程间需要高度的合作，所涉及的进程切换就会严重影响性能。</span><br></pre></td></tr></table></figure></p><p>3.22 存储管理中交换技术的实现原理及主要作用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交换技术又称对换技术。</span><br><span class="line">进程从内存移到磁盘，并再移回内存称为交换。</span><br><span class="line">交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。交换技术的目的是尽可能达到“足够快地交换进程，以使当处理器调度程序想重新调度处理器时，总有进程在内存中处于就绪（准备执行）状态”的理想状态，从而提高内存利用率。</span><br></pre></td></tr></table></figure></p><p>3.23 虚拟页式存储管理的优缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：由于它不要求进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。这既提高了内存的利用率，又有利于组织多道程序执行。</span><br><span class="line">缺点：存在页面空间的浪费问题。这是由于各种程序代码的长度是各不相同的，但页面的大小是固定的，所以在每个程序的最后一页内总有一部分空间得不到利用。如果页面较大，则由此引起的存储空间的损失仍然较大。</span><br></pre></td></tr></table></figure></p><p>3.24 文件系统的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 统一管理文件的存储空间，实施存储空间的分配与回收。</span><br><span class="line">2. 实现文件从名字到外存地址空间的映射，即实现文件的按名存取。</span><br><span class="line">3. 实现文件信息的共享，并提供文件的保护措施。</span><br><span class="line">4. 向用户提供一个方便使用的接口。</span><br><span class="line">5. 系统维护及向用户提供有关信息。</span><br><span class="line">6. 保持文件系统的执行效率，文件系统在操作系统中占的比例最大。</span><br><span class="line">7. 提供I/O的统一接口。</span><br></pre></td></tr></table></figure></p><p>3.25 什么是逻辑文件？什么是物理文件？简述逻辑文件的几种形式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 用户组织的文件称为逻辑文件，存放在存储介质上的文件称为物理文件。</span><br><span class="line">2. 流式文件是由一串顺序的字符流组成的，记录式文件是由若干逻辑记录组成的。</span><br></pre></td></tr></table></figure></p><p>3.26☆ 某UNIX操作系统采用i结点管理文件的存储空间，假设磁盘大小为2048字节，每个地址占64位（8个字节），i结点包括13个地址项，其中10个地址用来存直接地址，一个地址项存一次间接地址，一个地址项存二次间接地址，一个地址项存三次间接地址。问系统能管理的单个文件最大长度是多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">磁盘块大小=2048字节=2×1024字节=2×1KB=2KB</span><br><span class="line">10个直接地址表示的文件大小=10×2KB=20KB                  直接地址指向磁盘块</span><br><span class="line">每个地址占8字节</span><br><span class="line">每个盘块中存放2^8=256个盘块号</span><br><span class="line">1个一次间接地址存放文件大小=1×256×2KB=512KB             间接地址指向直接地址</span><br><span class="line">1个二次间接地址存放文件大小=1×256×256×2KB=128MB         二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">1个三次间接地址存放文件大小=1×256×256×256×2KB=32GB      三级间接-&gt;二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">所以一个文件的最大长度=20KB+512KB+128MB+32GB</span><br></pre></td></tr></table></figure></p><p>3.27☆ 假定某系统中，磁带的记录密度为每英寸1200个字符，每个逻辑记录长为200个字符，块与块之间的间隙为0.5英寸。问，为了使磁带空间利用率达到70%，采用记录成组操作时的块因子应为多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设块因子为x。</span><br><span class="line">每条记录所占磁带空间=200/1200=1/6英寸</span><br><span class="line">(x*1/6)/(x*1/6+0.5)=0.7</span><br><span class="line">解得：x=7</span><br><span class="line">成组操作时块因子是7。</span><br></pre></td></tr></table></figure></p><p>3.28 简述UNIX的目录文件的存取权限及其含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读：允许读该目录。</span><br><span class="line">写：允许修改目录内容。</span><br><span class="line">执行：允许搜索该目录。</span><br></pre></td></tr></table></figure></p><p>3.29 通道有哪三种类型？简述三种通道的优缺点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 选择通道</span><br><span class="line">优点：以数据块为单位进行传输，传输效率高。</span><br><span class="line">缺点：通道利用率低。</span><br><span class="line">2. 数组多路通道</span><br><span class="line">优点：以数据块为单位进行传输，传输率高；又具有多路并行操作的能力，通道利用率高。</span><br><span class="line">缺点：控制复杂。</span><br><span class="line">3. 字节多路通道</span><br><span class="line">优点：多路并行操作能力与数组多路通道相同。</span><br><span class="line">缺点：以字节为单位交替进行的，个设备轮流占用一个很短的时间片，效率低。</span><br></pre></td></tr></table></figure></p><p>3.30☆ 假设对磁盘的请求为柱面号95、180、35、120、10、122、64、68，磁头的初始位置为30，求在下列移臂调度算法下的服务顺序和移动臂需要移动的距离。<br>（1）最短寻找时间优先调度算法。<br>（2）移动臂由外向里移动（向柱面号增大的方向）的电梯调度算法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 最短寻找时间优先调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;10-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180</span><br><span class="line">移动臂需要移动的距离=(35-30)+(35-10)+(64-10)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)=200(柱面)</span><br><span class="line">(2) 移动臂由外向里移动的电梯调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180-&gt;10</span><br><span class="line">移动臂需要移动的距离=(35-30)+(64-35)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)+(180-10)=320(柱面)</span><br></pre></td></tr></table></figure><br>3.31 磁盘驱动调度包括什么调度？各涉及什么时间？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">磁盘驱动调度包括移臂调度和旋转调度。</span><br><span class="line">分别涉及寻找时间和延迟时间。</span><br></pre></td></tr></table></figure></p><p>3.32 简述关于磁盘的电梯调度算法与单向扫描调度算法的含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 电梯调度算法是从移动臂当前位置开始沿移动方向去选择最近的柱面请求，当移臂方向向上无请求时，就改变移臂的移动方向再做类似处理。</span><br><span class="line">2. 单向扫描调度算法总是从0号柱面开始向里扫描，为请求的柱面提供服务，到达最后一个柱面再把读写头快速返回0号柱面（返回过程不做服务），返回后可再进行扫描和服务。</span><br></pre></td></tr></table></figure></p><p>3.33 磁盘驱动调度和调度原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘执行一次输入输出所需时间是：寻找时间、延迟时间、传送时间。</span><br><span class="line">采用一定得到调度策略以决定各等待访问者的执行次序，称为驱动调度。</span><br><span class="line">磁盘驱动调度就需要优化寻找时间和延迟时间，就是移臂调度和旋转调度。</span><br></pre></td></tr></table></figure></p><p>3.34 什么是死锁？产生死锁的额两个主要原因？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">死锁是指在多道程序系统中的一种现象，一组进程中的每个进程均无限期地等待被该进程中的另一个进程所占用且永远不会释放的资源。</span><br><span class="line">产生死锁的原因：</span><br><span class="line">（1）竞争资源，系统资源在分配时出现失误，进程间对资源的相互争夺而造成僵局。</span><br><span class="line">（2）多道程序运行时，进程推进顺序不合理。</span><br></pre></td></tr></table></figure></p><style>    .td3_20{        color:midnightblue;    }</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/OS/">OS</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/09/26/LearnOS/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JavaWeb：JSP概述</title>
      <link>https://pearlchocolatezy.com/2024/09/05/LearnJSP/</link>
      <guid>https://pearlchocolatezy.com/2024/09/05/LearnJSP/</guid>
      <pubDate>Thu, 05 Sep 2024 11:55:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 JSP (Java Serve Pages)：一种动态网页技术标准。部署在网络服务器上，以Java为脚本语言，根据客户算发送的请求，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 JSP (Java Serve Pages)：一种动态网页技术标准。部署在网络服务器上，以Java为脚本语言，根据客户算发送的请求，动态地生成HTML等格式文档，返回客户端。JSP文件（.jsp后缀）在运行时会被编译成Servlet代码。可利用JavaBean和标签库技术复用常用的功能代码。</p><p>1.2 TCP/IP (Transmission Control Protocol/Internet Protocol)：传输控制协议/网际协议，在多个不同网络间实现信息传输。TCP/IP协议包含FTP、SMTP、UDP、TCP、IP等。是Internet最基本的协议。是一个四层的体系结构，包含应用层、传输层、网络层和数据链路层，每一次包含不同的协议。</p><p>1.3 HTTP (Hypertext Transfer Protocol)：超文本传输协议。一个简单的请求-响应协议，指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。HTTP协议和TCP/IP技术共同支撑起WWW技术的发展。Web服务器需要监听在80/TCP端口。</p><p>1.4 FTP (File Transfer Protocol)：文件传输协议。一种在网络中进行文件传输的广泛使用的标准协议，允许用户通过客户端软件与服务器进行交互，实现文件的上传、下载和其他操作。</p><p>1.5 DNS (Domain Name System)：域名系统。是将域名和IP地址相互映射的一个分布式数据库。</p><p>1.6 HTML (Hyper Text Markup Language)：超文本标记语言，标准通用标记语言下的一个应用。包括一系列标签，可以将网络上的文档格式统一。是标记语言，不是编程语言。</p><font color="purple">注意将HTTP和HTML区分开！</font><p>1.7 超链接：从一个网页指向另一个目标的连接关系，这个目标可以是另一个网页、也可以是相同网页上的同位置，可以是一个图片、电子邮件地址、文件、应用程序。而在一个网页中用来超链接的对象，可以是一段文本或一个图片。当浏览者单击已链接的文字或图片，链接目标将显示在浏览器上，并根据目标的类型来打开或运行。</p><p>1.8<br>Javac：JDK中用来编译Java源文件的工具。<br>Javap：Java类文件的反汇编器。<br>Javah：用于生成C语言头文件的工具。</p><p>1.9<br>B/S结构 (Browser/Server)：浏览器/服务器模式。一种网络结构模式。Web浏览器是客户端最主要的应用软件，这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如Edge、Chrome等，服务群安装Sql Server、MYSQL、Oracle等数据库，浏览器通过Web Server同数据库进行数据交互。<br>C/S结构 (Client/Server)：客户端/服务群模式。应用程序最大的特点是在没和用户端安装程序。特点是用户端程序一致，便于控制，服务器端和用户本地数据容易交互，通信速度快。缺点是每个用户都要安装客户端，比较繁琐，且不能很好地跨系统平台。</p><p>1.10 WEB-INF：Java文件代码的编译输出目录。由以下部分组成：lib目录，存放.jar或.zip文件（目录WEB-INF\lib）；web.xml，Web应用初始化配置文件。WEB-INF内的文件对用户不可见。JSP文件通常位于WEB-INF文件夹之外。</p><p>1.11 J2EE (Java 2 Platform Enterprise Edition)：Java 2企业版，是一个用于开发企业级应用的中间件基础架构。</p><p>1.12 Cookie：存储在用户本地终端上的数据。通常用户存储特定用户的会话信息，每个用户的Cookie是独立的，因此无法通过Cookie在不同用户间共享数据。可以保存在硬盘上或内存里。Cookie永远不会以任何方式执行，不会造成严重的安全威胁。Cookie数据存储功能由<font color="purple">浏览器</font>提供，所有Cookie功能都必须要有浏览器支持才行。【概念与使用：Cookie为浏览器提供的 功能，是一种可将联机用户的数据存储在客户端计算机上的技术，要运用Cookie必须先建立一个Cookie对象来存储字符串数据，再将Cookie对象传送到客户端。】</p><p>1.13 JavaBean：一种特殊的Java程序，用于包装特定的功能的程序代码，可以被JSP网页重复使用，本身无法独立运行，是JSP网页程序组件化的核心。</p><p>1.14 JSTL (JSP Standard Tag Library)：JSP标准标签库，提供给Java Web开发人员一个标准通用的标签库。</p><p>1.15 tld文件：jsp自定义web标签库，包含标签的名称、描述、搬到、使用方式等。主要存放在WEB-INF目录下。</p><p>1.16 BeanUtils：BeanUtils是Apache commons组件的成员之一，主要用于简化JavaBean封装数据的操作。它可以给JavaBean封装一个字符串数据，也可以将一个表单提交的所有数据封装到JavaBean中。</p><p>1.17 常量：常量是用来代替一个数或字符串的名称。</p><p>1.18 窗口对象：窗口对象是一种顶级对象，可以用这个对象去发现窗口的URL或构造按钮，在浏览器中模拟Back和forward按钮，这几个按钮通过用户的网络冲浪历史记录转到不同的URL。</p><p>1.19 数据库管理系统：数据库管理系统是用来操纵和管理数据库的系统软件。</p><p>1.20 Parameter对象：一个Parameter对象代表了一个因为参数化查询或存储过程而与Command对象相关的参数或参量，很多Provider支持带参数的命令。</p><p>1.21 Session对象：JSP里有很多内部对象，Session对象就是其中之一，它用来保存每个用户的信息，以便跟踪每个用户的操作状态。其中Session信息保存在容器里，Session的id保存在客户机的Cookie中。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 Web结构的两个主要部分：浏览器、服务器。</p><p>2.2 网络上通用的三种通信协议：HTTP、FTP、MAIL。（MAIL有疑问）</p><p>2.3 静态网页*.html中的脚本代码只能在客户端运行。</p><p>2.4 JSP和Servlet的主要区别：JSP侧重于视图，允许Java和HTML组合成一个文件；Servlet侧重于控制逻辑，主要用于生成HTML页面。</p><p>2.5 JSP页面转译后，将创建一个servlet文件。JSP的实质是Servlet。</p><p>2.6 JSP文件不能脱离服务器单独运行。</p><p>2.7 脚本语言通常需要解释器才能运行，不是解释型语言。例：JS,JSP,Python,ASP</p><p>2.8 目前在客户端运行的两种主要动态Script语言：JavaScript, VBScript。</p><p>2.9 JSP文件的组成：HTML文件，Java程序片段，JSP标记。</p><p>2.10 MVC设计模式将应用程序分为：模型，视图，控制器。</p><p>2.11 Web应用程序使用的三层体系结构：表示层，业务层，数据层。</p><p>2.12 WebContent文件夹主要存放：JSP文件，HTML文件。</p><p>2.13 在Eclipse开发项目中，src目录用来存放<font color="purple">java源文件</font>。</p><p>2.14 Tomcat的全局配置文件，修改Tomcat服务默认使用的端口号的文件：server.xml。</p><p>2.15 当多个用户请求同一个JSP页面时，Tomcat服务器为每个客户启动一个<font color="purple">线程</font>。</p><p>2.16 JDK不是一个Eclipse插件，是Java开发工具包，是Java开发环境的核心组件。</p><p>2.17 要根据Eclipse版本选择相应版本JDK。</p><p>2.18 Tomcat可以被视作一个单独的Web服务器，是由Apache开发的一个Servlet容器。</p><p>2.19 除了开发工具外，还要安装一个支持Java Servlet的<font color="purple">Web服务器</font>，或在现有Web服务器上安装<font color="purple">Servlet</font>软件包。</p><p>2.20 Tomcat是一个流行的开源Servlet容器，它实现了Java Servlet和JavaServer Pages (JSP) 规范。</p><p>2.21 JSP的三个指令元素：<code>&lt;%@page%&gt;</code>，<code>&lt;%@include%&gt;</code>，<code>&lt;%@taglib%&gt;</code>。</p><p>2.22 JSP中的forward标签用于将请求转发给其他JSP页面（简写：<font color="purple">页面跳转</font>）。</p><p>2.23 <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#37;&#x40;&#x69;&#110;&#99;&#x6c;&#117;&#x64;&#x65;&#x25;">&#37;&#x40;&#x69;&#110;&#99;&#x6c;&#117;&#x64;&#x65;&#x25;</a>只允许包含静态文件，<code>&lt;jsp:include&gt;</code>允许包含静态和动态文件。</p><p>2.24 动作元素<code>&lt;jsp:setProperty&gt;</code>作用为<font color="purple">设置javabean对象的属性</font>。</p><p>2.25 在JSP页面中，列表框的name属性值为“city”，且允许多选，若要一次性读取所有选中项并存放于数组str中，则对应的java语句为<code>String[] str=request.getParameterValues(&quot;city&quot;);</code>。</p><p>2.26 <code>&lt;jsp:forward...&gt;</code>标记的page属性值，可以是相对路径也可以是静态路径。</p><p>2.27 response.sendRedirect(“”)方法，可以实现本网站内的页面跳转，也可以用于夸网页跳转，可以在URL中附加查询参数。</p><p>2.28 response.addHeader方法，用于向HTTP响应头中添加额外的头部信息，而非修改。</p><p>2.29 在Web程序中，Cookie保存在客户端，session保存在服务器端。</p><p>2.30 可以在不同用户间共享数据的方法：文件系统、数据库、ServletContext对象。</p><p>2.31 Servlet API中用于处理Cookie的核心类：Javax.sevlet.http.Cookie。</p><p>2.32<br>获取Cookie：request.getCookies<br>发送Cookie：response.addCookie</p><p>2.33 实现会话追踪的四种方式：使用持续Cookie、重写包含额外参数的URL、建立含有数据的隐藏表单字段、使用内建session对象（最常用）。</p><p>2.34 大多数Web应用框架中，session默认使用Cookie技术进行会话追踪。</p><p>2.35 设置session访问超时时间的方法：setMaxInactiveInterval()。</p><p>2.36 sessionID将通过<font color="purple">会话</font>来维持。</p><p>2.37 编写一个简单的JavaBean类可以遵循以下步骤：<br>（1）类必须用public修饰。<br>（2）类必须有一个无参的构造方法。<br>（3）所有的属性必须私有化。<br>（4）私有化的属性必须通过public的方法进行访问。</p><p>2.38 JavaBean可以保存状态。</p><p>2.39 静态类只能实例化一次，普通类可以有多个实例化对象。JavaBean是一个类，遵循前述规则。</p><p>2.40 JavaBean是一种<font color="purple">java</font>，通过封装<font color="purple">属性</font>和<font color="purple">方法</font>成为具有某种功能或者出于某个业务的对象，简称Bean。</p><p>2.41 在Tomcat中，所有编译好的JavaBean都需要放在某个应用目录下的<font color="purple">WEB-INF/classes</font>目录之下。</p><p>2.42 JSP开发网站的两种模式：<font color="purple">jsp+javabean</font>、<font color="purple">jsp+javabean+servlet</font>。</p><p>2.43 如果你想用JavaBean设计一个网站计数器，那么该Bean的scope应当设为<font color="purple">application</font>。</p><p>2.44 按功能JavaBean可以分为<font color="purple">可视化JavaBean</font>和<font color="purple">非可视化JavaBean</font>。</p><p>2.45 如何在网站中载入JavaBean：<code>&lt;jsp:useBean id=id-name scope=scope-name class=class-name /&gt;</code>。</p><p>2.46 JavaBean可以声明哪些不同的生命周期：request、session、page、application。</p><p>2.47 JavaBean程序除了必须有一个无传入值的建构式之外，还必须是一个公开的类，并以set及get开头的方法来设置于取得属性。</p><p>2.48 字节流类为处理字节式输入输出提供了丰富的环境，字节流的处理单元为<font color="purple">1</font>个字节。<br>字符流提供了处理任何类型输入输出操作的功能，字符流的处理单元为<font color="purple">2</font>个字节的Unicode字符。</p><p>2.49 JSP网页使用File类之前，将载入的命名空间：<font color="purple">java.io</font>。</p><p>2.50 文件上传通常需要post方法而非get。</p><p>2.51 处理表单数据使用multipart/form-data类，而非HttpRequest。</p><p>2.52 Java中的四个输入/输出抽象类：InputStream、OutputStream、Writer、Reader。</p><p>2.53 JSP应用程序配置文件的根元素：<code>&lt;web-app&gt;</code>。</p><p>2.54 JDBC的主要任务：与数据库建立连接、发送SQL语句、处理结果。</p><p>2.55 (JDBC)想创建一个不敏感可滚动且不可更新的结果集，参数选择：Result.TYPE_SCROLL_INSENSITIVE、Result.CONCUR_READ_ONLY。</p><p>2.56 (JDBC)在可更新的结果集中插入一条新纪录，首先要将游标移动到一个可更新得到行，调用<code>moveToInsertRow()</code>。</p><p>2.57 sun开头的是access数据库加载的驱动。</p><p>2.58 数据库服务与Web服务器需要部署在同一台计算机上。</p><p>2.59 数据库连接池配置繁琐，所以应该利用数据库连接池来优化数据库连接的管理，而不是在每页上都重新建立连接。</p><p>2.60 Java中以字节流<font color="purple">InputStream</font><font color="purple">OutStream</font>来读写二进制数据和字符数据，他们都包含在<font color="purple">java.io</font>中。</p><p>2.61 一般互联网软件开发分为五个基本阶段：规划、设计、建设和测试、投入使用、<font color="purple">运行和维护</font>。</p><p>2.62 一个Servlet可以映射多个路径。</p><p>2.63 Servlet可以在以下三个不同作用域存储数据：请求HttpServlet、会话HttpSession、上下文ServletContext。</p><p>2.64 如果某个类要成为Servlet，则它应该继承HttpServlet、GenericServlet接口、Servlet类。</p><p>2.65 在Web容器中，Http请求与响应对象实例：HttpServletRequest、HttpServletResponse。（是Java Servlet Api的核心部分）</p><p>2.66 ServletContext比Session范围要大。</p><p>2.67 转发步骤：在Servlet中得到RequestDispatch对象，再调用该对象的forward方法。</p><p>2.68 Servlet中的两种异常处理机制：<font color="purple">程序式异常处理机制</font><font color="purple">声明式异常处理机制</font>。</p><p>2.69 对Web应用来说，驻留在服务器内，在源数据和目的数据间对Web请求和Web响应的头属性和内容体进行操作的一种特殊Web组件：<font color="purple">过滤器</font>。</p><p>2.70 过滤器对象使用<font color="purple">FilterChain</font>对象调用过滤器链中的下一个过滤器或者是目标资源。</p><p>2.71 在J2EE中，使用Servlet过滤器时，需要在web.xml通过<code>&lt;filter-mapping&gt;</code>元素将过滤器映射到Web资源。</p><p>2.72 在一个Filter中，处理filter业务的是<code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>。</p><p>2.73 EL中，隐含对象<font color="purple">param</font>与<font color="purple">paramValues</font>可直接用来存取表单传递的参数。</p><p>2.74 系统初始化数据存放于WEB-INF文件夹的<font color="purple">web.xml</font>，隐含对象<font color="purple">initParam</font>可用来对其进行访问。</p><p>2.75 JSTL提供的标签分为五大类：核心标签、i18n国际化格式标签、SQL标签、XML标签、函数标签。</p><p>2.76 在JSTL核心标签中，网页数据的存取操作行为是由out、set、remove三个标签所设置的。</p><p>2.77 在JSTL中，<code>&lt;c:url&gt;</code>用来设置一个超级链接。</p><p>2.78 在JSTL中，流程控制标签用来控制程序运行的流程，<code>&lt;c:choose&gt;</code>搭配<code>&lt;when&gt;</code>与<code>&lt;otherwise&gt;</code>，来进行多重判断。</p><p>2.79 在JSTL中，<code>&lt;c:forEach&gt;</code>标签通过属性值begin、end、step控制循环的间隔数及起始与结束值。</p><p>2.80 在JSTL中，<code>&lt;c:out&gt;</code>标签使用value属性表示要输出的内容。</p><p>2.81 在JSTL中，<code>&lt;c:set&gt;</code>标签的作用：将EL表达式的值存储在一个变量中。</p><p>2.82 在JSTL中，与存活期范围有关的四个隐含对象分别为：pageSource、requestScope、sessionScope、applicationScope。</p><p>2.83 Tomcat服务器默认的HTTP端口为8080。</p><p>2.84 数据库设计的原则：数据独立性、数据完整性、数据一致性、数据冗余最小化、数据安全性、性能优化。</p><p>2.85 系统功能结构图的设计原则：分解-协调原则、自顶向下原则、信息隐蔽与抽象原则、一致性原则、明确性原则、模块化设计原则。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 URL与通信协议的差异：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. URL (Uniform Resource Locator)：全球资源定位器。是可以从互联网上得到资源的位置和方法的一种表示，是互联网上的标准资源地址。互联网上每个文件都有唯一URL。当用户想要打开远程网站主机上的网页时，必须指定其URL，即网址。</span><br><span class="line">2. 通信协议：在网络上彼此通信必须遵循的沟通方式。只有双方都使用相同的通信协议，才能建立连接通道。</span><br></pre></td></tr></table></figure></p><p>3.2 客户端与服务器端网页语言的不同：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 在客户端执行的网页语言内嵌在HTML中，这类文件通常扩展名为.html。当浏览器向服务器请求打开网页时，服务器会将整份网页传送至客户端，由浏览器进行网页程序解释操作，并将结果显示在浏览器窗口中。</span><br><span class="line">2. 在服务器端执行的网页语言必须由服务器中的解释器来做解释操作，最后再将解释的结果以HTML的格式传送至客户端，直接显示在浏览器中。服务器端网络语言得到出现，才真正实现了让用户通过网络与网站进行沟通的目的。</span><br></pre></td></tr></table></figure></p><p>3.3 JSP页面访问数据库的过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 用户通过浏览器指定URL，向网页服务器请求特定的网页内容。</span><br><span class="line">2. 服务器加载指定的JSP网页，用网页解释器解读其中的JSP程序代码。</span><br><span class="line">3. 根据JSP代码中运算逻辑，存取数据库内容，建立所需的内容信息。</span><br><span class="line">4. 处理好的数据用于创建HTML抢野，返回至客户端的网页浏览器进行解释。</span><br><span class="line">5. 浏览器取得文件，解释其中HTML即Script代码。</span><br><span class="line">6. 显示网页。</span><br></pre></td></tr></table></figure></p><p>3.4 HTML网页，JavaScript网页，JSP网页运作上的差异：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. HTML网页只能提供静态的多媒体信息，无法与联机用户做数据交换等动态交流。</span><br><span class="line">2. JavaScript内嵌于网页上，与HTML混用创造动态网页效果，目前浏览器普遍支持这一网页语言，可以有效地进行一些客户端的网页工作。</span><br><span class="line">3. HTML网页和JavaScript网页只运行在浏览器端。</span><br><span class="line">4. 执行JSP页面时，把JSP文件先翻译为Servlet形式的Java类型字节码文件，然后通过Java虚拟机运行。JSP网页运行在服务器端。</span><br></pre></td></tr></table></figure></p><p>3.5 Java相关技术：Servlet，JavaBean，JSP之间的关联与运作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 每个JSP页面在被系统调用之前，必须先被Servlet容器解析成一个Servlet文件。Servlet是一种纯粹以Java语言编写，符合标准规范的Java应用程序，在网站服务器运行的时候被加载，在客户端浏览器针对服务器提出内容要求时，作出动态响应。Servlet用于创建动态网页的功能强大，但不易开发，因此发展出JSP这一服务器端网页技术。当浏览器请求JSP网页时，文本文件被编译成Servlet加载，然后产生动态网页内容。</span><br><span class="line">2. JavaBean是一组包含特定功能的Java组件。当一个JSP网页需要引用此功能时，直接引用相关JavaBean组件即可。JavaBean最重要的概念在于将程序逻辑与创建页面的程序代码分开，网页只负责收集数据及页面元素的放置，而JavaBean组件包含更重要的逻辑运算。这样使JSP页面更便于维护和建构。</span><br></pre></td></tr></table></figure></p><p>3.6 客户端与服务器端在网页结构中所扮演的角色：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 要打开和浏览网页上的网页文件，必须通过浏览器程序，而使用浏览器打开网页的这一端，称为客户端。网站为上线用户提供打开网页的服务，因此用户也可称为客户。</span><br><span class="line">2. 提供浏览器服务的一方称作服务器端。用来放置这些网页信息的计算机，称为服务器。服务器并不只存放网页信息，任何可提供网络服务的计算机都是服务器，例如提供网页信息的称为网页服务器，提供文件上传与下载的称为文件服务器。</span><br></pre></td></tr></table></figure></p><p>3.7 为什么在客户端双击.jsp文件不能运行JSP？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsp文件本身是一种html+jsp标签+java代码的集成技术，jsp文件运行在服务端，所以需要web容器才能运行，浏览器才可以访问jsp网页。</span><br></pre></td></tr></table></figure></p><p>3.8 安装JDK有什么用？是否需要掌握JDK命令的使用方法？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. JDK是java软件开发包的简称，要想开发java程序就必须安装JDK。没有JDK则无法编译java程序。</span><br><span class="line">2. 在集成开发环境中，不需要掌握JDK命令的使用方法。</span><br></pre></td></tr></table></figure></p><p>3.9 Tomcat服务器的优点：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Tomcat运行时占用系统资源小，扩展性好，支持负载均衡与邮件服务等开发应用系统常用的功能；</span><br><span class="line">2. Tomcat是一个开源的服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。</span><br></pre></td></tr></table></figure></p><p>3.10 如何在HTML网页中嵌入JSP程序代码？怎样定义JSP中的声明区和嵌入区？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 在JSP网页中必须在&lt;%与%&gt;符号间嵌入程序代码。</span><br><span class="line">2. JSP声明的语法格式为：</span><br><span class="line">&lt;%! declaration;[declaration;]... %&gt;</span><br><span class="line">&lt;%! 声明;[声明;]... %&gt;</span><br><span class="line">  脚本代码的语法格式如下：</span><br><span class="line">&lt;% code fragment %&gt;</span><br><span class="line">&lt;% 代码 %&gt;</span><br></pre></td></tr></table></figure></p><p>3.11 JSP的三个指令元素及其用途：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. page指令：可用来设置JSP网页的特性，如：编码方式、引用类、缓冲区等。</span><br><span class="line">2. include指令：可用来将HTML、文本文件或JSP程序加载当前的JSP网页。</span><br><span class="line">3. taglib指令：可用来引用一个自定义的标签库。</span><br></pre></td></tr></table></figure></p><p>3.12 JSP中include指令与include动作的区别是什么？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. include指令是指把其他页面Java代码加进来，跟本页面代码合并在一起，相当于将源码从其他页面复制过来，再编译。由于本页面已经编译过了，以后其他页面更改时，本页面不改变。</span><br><span class="line">2. &lt;jsp:include&gt;动作是指两个页面的代码运行完后，再把其他页面运行后的HTML结果页面加到本页面HTML结果页面中来，所以是运行时包含，并且还可以传递参数给被包含的页面。</span><br></pre></td></tr></table></figure></p><p>3.13 JSP网页可以使用的特殊操作元素有哪些？其中<code>&lt;jsp:forward&gt;</code>与<code>&lt;jsp:param&gt;</code>操作元素各有什么功能？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 可使用的特殊操作元素有&lt;jsp:param&gt;、&lt;jsp:include&gt;、&lt;jsp:forward&gt;、&lt;jsp:plugin&gt;。</span><br><span class="line">2. &lt;jsp:forward&gt;可将当前浏览器显示网页的网址重新导向新的网址。</span><br><span class="line">3. &lt;jsp:param&gt;主要用来传递参数给JSP程序，而由程序取得参数值。</span><br></pre></td></tr></table></figure></p><p>3.14☆ 编写一个JSP程序，计算10!，并显示出结果。要求先声明计算阶乘的方法，再调用该方法，最后再页面上输出结果。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body bgcolor=cyan&gt;</span><br><span class="line">&lt;font size=<span class="number">5</span>&gt;</span><br><span class="line">&lt;!--&lt;%! %&gt;用于声明变量或定义函数--&gt;</span><br><span class="line">&lt;%!<span class="type">long</span> <span class="title function_">jiecheng</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">long</span> p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">p=p*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">/*采用递归方法计算10!的阶乘</span></span><br><span class="line"><span class="comment">int digui(int x)&#123;</span></span><br><span class="line"><span class="comment">int z;</span></span><br><span class="line"><span class="comment">if(x == 1) z=1;</span></span><br><span class="line"><span class="comment">else z=x*digui(x-1);</span></span><br><span class="line"><span class="comment">return z;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;<span class="number">10</span>的阶乘是&lt;/p&gt;&lt;%=jiecheng(<span class="number">10</span>)%&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.15☆ 在JSP页面中编写静态包含文件，要求程序包含两个文件，主文件静态包含一个能够计算数据的算术平方根的页面。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--文件staticinclude.jsp--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;font size=<span class="number">5</span>&gt;</span><br><span class="line">&lt;p&gt;请输入正整数&lt;/p&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=text nam=zhengshu&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=submit name=submit value=提交&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span>(request.getParameter(<span class="string">&quot;zhengshu&quot;</span>)!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> i=integer.parseInt(request.getParameter(<span class="string">&quot;zhengshu&quot;</span>));</span><br><span class="line">您输入的数是：&lt;%=i%&gt;&lt;br&gt;</span><br><span class="line">它的平方根是：&lt;%=Math.sqrt(i)%&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">out.print(e.getMessage();)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--主文件main.jsp--&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;font size=<span class="number">5</span>&gt;</span><br><span class="line">此页面静态包含staticinclude.jsp页面</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;staticinclude.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.16☆ 编写动态页面并传递数据。要求程序包含两个文件，主文件加载次文件，并将随机产生的0-1之间的数据传递给它，并在页面上显示出来。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body bgcolor=cyan&gt;</span><br><span class="line">&lt;font size=<span class="number">8</span>&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String str=request.getParameter(<span class="string">&quot;number&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(str==<span class="literal">null</span>) str=<span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="type">double</span> n=Double.parseDouble(str);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;您传过来的数值是：&lt;/p&gt;&lt;%=n%&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.17☆ 计算三角形的面积。由用户输入三角形的三条边，判断这三条边能否构成一个三角形，若能构成三角形，输出三角形的面积。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;% request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>); %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body bgcolor=cyan&gt;</span><br><span class="line">&lt;font size=<span class="number">5</span>&gt;</span><br><span class="line">请输入三角形的三条边</span><br><span class="line">&lt;form method=post name=three&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=text name=first required=<span class="string">&quot;required&quot;</span> value=&lt;%=request.getParameter(<span class="string">&quot;first&quot;</span>)%&gt;&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=text name=second required=<span class="string">&quot;required&quot;</span> value=&lt;%=request.getParameter(<span class="string">&quot;second&quot;</span>)%&gt;&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=text name=third required=<span class="string">&quot;required&quot;</span> value=&lt;%=request.getParameter(<span class="string">&quot;third&quot;</span>)%&gt;&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=submit name=submit value=提交&gt;&lt;/p&gt;</span><br><span class="line">&lt;!--&lt;%! %&gt;用于声明变量或定义函数--&gt;</span><br><span class="line">&lt;!--一个JSP文件中即使用多个 &lt;% %&gt; 或 &lt;%! %&gt; 分隔开的代码，它们本质上是在同一上下文中的--&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">String f,s,t,sub,msg;</span><br><span class="line"><span class="type">double</span> f1,s1,t1,area,length,p;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">f=request.getParameter(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">s=request.getParameter(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">t=request.getParameter(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">sub=request.getParameter(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(sub!=<span class="literal">null</span> &amp;&amp; sub.equals(<span class="string">&quot;提交&quot;</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(f) || f==<span class="literal">null</span>)&#123;</span><br><span class="line">msg += <span class="string">&quot;请重新输入第一条边！&quot;</span>+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">f1=Double.parseDouble(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">msg += <span class="string">&quot;您输入的第一条边有误&quot;</span>+e.getMessage()+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(s) || s==<span class="literal">null</span>)&#123;</span><br><span class="line">msg += <span class="string">&quot;请重新输入第二条边！&quot;</span>+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">s1=Double.parseDouble(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">msg += <span class="string">&quot;您输入的第二条边有误&quot;</span>+e.getMessage()+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(t) || t==<span class="literal">null</span>)&#123;</span><br><span class="line">msg += <span class="string">&quot;请重新输入第三条边！&quot;</span>+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1=Double.parseDouble(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">msg += <span class="string">&quot;您输入的第三条边有误&quot;</span>+e.getMessage()+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(msg!=<span class="string">&quot;&quot;</span> || msg!=<span class="literal">null</span>)&#123;</span><br><span class="line">out.print(msg);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((f1+s1&gt;t1) &amp;&amp; (f1+t1&gt;s1) &amp;&amp; (s1+t1&gt;f1))&#123;</span><br><span class="line"><span class="comment">//海伦公式</span></span><br><span class="line">p=(f1+s1+t1)/<span class="number">2</span>;<span class="comment">//半周长</span></span><br><span class="line">area=Math.sqrt(p*(p-f1)*(p-s1)*(p-t1));</span><br><span class="line">length=f1+s1+t1;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;三角形的面积是：&lt;%=area%&gt;&lt;/p&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;三角形的周长是：&lt;%=length%&gt;&lt;/p&gt;&lt;br&gt;</span><br><span class="line">&lt;%</span><br><span class="line">sub=<span class="literal">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">out.print(<span class="string">&quot;您输入的三条边长不构成三角形，请重新输入&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;/font&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.18 JSP中的内建对象包含哪些？简述这些对象在JSP的主要功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. request：取得客户端数据与系统的信息。</span><br><span class="line">2. response：响应客户端信息。</span><br><span class="line">3. application：记录与处理上线者共享的数据。</span><br><span class="line">4. session：记录与处理上线者的个别数据。</span><br><span class="line">5. out：控制数据输出的操作。</span><br><span class="line">6. config：取得JSP编译后Servlet的信息。</span><br><span class="line">7. pageContext：存取与处理系统运行时期的各项信息。</span><br><span class="line">8. page：表示当前的JSP网页。</span><br></pre></td></tr></table></figure></p><p>3.19 <code>response.sendRedirect()</code>和动作元素<code>&lt;jsp:forward&gt;</code>的区别是什么？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. response.sendRedirect()会在客户端呈现跳转后的URL地址，这种跳转称为客户端跳转。使用response.sendRedirect()将重定向的URL发送到客户端，浏览器再根据这个URL地址重新发起请求。此时的request和response都和第一次不同。</span><br><span class="line">2. 使用动作元素完全是在服务器上进行，浏览器地址保持不变，这种称为服务器跳转。没有产生新的request和response，可以用request来传递参数。</span><br><span class="line">3. response.sendRedirect()想带参数的话，可以将URL地址写成xxx.jsp?param1=aaa&amp;...。&lt;jsp:forward&gt;能够使用&lt;jsp:param/&gt;标签向目标文件传送参数和值，目标文件必须是动态的，能够处理参数。</span><br><span class="line">4. &lt;jsp:forward&gt;后面的语句不会被执行也不会继续发送到客户端。response.sendRedirect()后面的语句会继续执行，除非前面有return。</span><br><span class="line">5. &lt;jsp:forward&gt;是在服务器内部进行转换，只发送给客户端最后转到的页面，速度较快。response.sendRedirect()需要服务器与客户端之间的往返，可以转到任何页面，包括网络有效域名，速度较慢。</span><br></pre></td></tr></table></figure></p><p>3.20 session对象的生命周期在哪些状况下会结束：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 用户关闭当前使用的浏览器程序。</span><br><span class="line">2. 关闭网页服务器。</span><br><span class="line">3. 用户未向服务器提出请求超过预设的时间，Tomcat服务器预设为30分钟。</span><br><span class="line">4. 运行程序结束session。</span><br></pre></td></tr></table></figure></p><p>3.21 application与session对象存储数据变量的方式有？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application：记录联机用户共享的数据。</span><br><span class="line">session：记录联机用户的个别数据。</span><br></pre></td></tr></table></figure></p><p>3.22 Cookie的常见用途<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 网站浏览人数管理。使用Cookie，网站可以测定多少人访问过，多少是老用户，一个用户多久访问一次网站。通常网站设计者借助后台数据库来实现这一目的。当用户第一次访问，网站在数据库建一个新的ID， 并把ID通过Cookie传给用户。用户再次来访时，网站把用户ID对应的计数加1，得到用户的来访次数或判断用户是新用户还是老用户。</span><br><span class="line">2. 按照用户喜好定制网页外观。有的网站设计者为用户提供了改变网页内容、布局和颜色的权力，允许用户输入自己的信息，通过这些信息定制网页外观。</span><br><span class="line">3. 在电子商务站点中实施购物篮等功能。可以使用Cookie记录用户ID，当你往购物篮里放新东西时，网站能记录下来，买单时网站通过数据库检索你的购物篮的所有选择。</span><br></pre></td></tr></table></figure></p><p>3.23 Cookie如何保存在计算机上？文件如何命名？文件的内容是什么？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，Cookie随着用户关闭浏览器自动消失。</span><br><span class="line">如果使用setMaxAge()方法，设置Cookie对象的存在期限，这样Cookie会保存在硬盘中的Cookies文件夹，如“C:\Documents and Settings\Administrator\Cookies”，如文件“administrator@ch06[1].txt”。</span><br></pre></td></tr></table></figure></p><p>3.24☆ 在JSP中使用Cookie，并设置Cookie的存活时间为10分钟。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html; charset=gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;操纵Cookie示例—写入Cookie&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;操纵Cookie示例—写入Cookie&lt;/h2&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;mycookie&quot;</span>,<span class="string">&quot;COOKIE_TEST&quot;</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">600</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">out.print(<span class="string">&quot;已经把Cookie写入客户端&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.print(e);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.25 Cookie与session不同点：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session与Cookie同样用来记录上线用户的个别数据。</span><br><span class="line">两者的差异在于session是存在于服务器端，而Cookie则是存在于客户端。</span><br></pre></td></tr></table></figure></p><p>3.26 非MVC模式在JSP开发中的定义及其主要特点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 非MVC模式是JSP开发中的一种传统模式。在这种模式下，JSP页面直接调用JavaBeans组件来处理业务逻辑和数据库交互。</span><br><span class="line">2. 非MVC模式的主要特点：</span><br><span class="line">（1）将页面展示和业务逻辑混合在一起，不易于维护。</span><br><span class="line">（2）页面和JavaBeans之间通过使用JSP标签进行交互，耦合度较高。</span><br><span class="line">（3）页面开发者需要对JavaBeans和JSP都很熟悉。</span><br></pre></td></tr></table></figure></p><p>3.27 比较MVC与非MVC模式在Web开发中的不同点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 职责分配。</span><br><span class="line">非MVC：所有的逻辑、数据处理和界面渲染都在一个文件中（通常是PHP文件），使代码混杂，难以维护。</span><br><span class="line">MVC：将应用程序分为三个主要部分，模型（M）负责处理数据，视图（V）负责界面展示，控制器（C）负责业务逻辑和用户输入的流程控制。每一部分有明确的职责分配，是代码更加模块化和可维护。</span><br><span class="line">2. 代码重用。</span><br><span class="line">非MVC：不适用。</span><br><span class="line">MVC：模型、视图、控制器可以分别在不同的应用程序中重用，提高了代码可重用性。</span><br><span class="line">3. 分离关注点。</span><br><span class="line">非MVC：否。所有逻辑都在一个文件中，难以分离关注点。</span><br><span class="line">MVC：通过分离模型、视图和控制器，可以轻松实现不同的关注点分离。</span><br><span class="line">4. 测试友好性。</span><br><span class="line">非MVC：不适用。</span><br><span class="line">MVC：模型和视图的高度分离是它们更容易进行单元测试。</span><br><span class="line">5. 扩展性。</span><br><span class="line">非MVC：不适用。</span><br><span class="line">MVC：模型和视图可以独立地进行扩展，增加新的模型或视图不会影响其它部分。</span><br><span class="line">6. 复杂度。</span><br><span class="line">非MVC：简单、容易上手，但是复杂应用开发困难。</span><br><span class="line">MVC：开始时复杂，但是适合大型和复杂的应用开发。</span><br></pre></td></tr></table></figure></p><p>3.28 如何利用File类进行文件目录的操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用File类进行文件目录的操作首先必须建立一个File对象，将所要操作文件或是目录完整路径当作参数传入，当File对象建立后，JSP网页便可以利用这个对象调用File类的所有方法，以进行各种文件目录的操作。</span><br></pre></td></tr></table></figure></p><p>3.29 文件存取操作的操作过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先利用File类建立一个参照指定文件的目录的File实体对象，接下来利用FileWriter和FileReader这两个类，进行指定文件的读写，负责将数据写入文件，而FileReader的read则用来读取文件中的数据。</span><br></pre></td></tr></table></figure></p><p>3.30 (JDBC)说明Statement和ResultSet接口的意义，以及它们生成的对象在JSP程序处理数时，分别扮演什么角色<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Statement：Statement接口主要提供一些运行SQL的方法，以及设置运行SQL后返回ResultSet类型对象的属性。由此接口所生成的对象在JSP中，同样是用来运行各种SQL指令与设置ResultSet对象的属性。</span><br><span class="line">2. ResultSet：ResultSet接口下所定义的方法大都是用来控制ResultSet对象中指针的移动的，以取得其中的数据元素。</span><br></pre></td></tr></table></figure></p><p>3.31 (JDBC)举例说明Statement运行SQL指令的三种方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. execute()：运行一般SQL指令，例如建立数据库、修改数据表等。</span><br><span class="line">2. executeQuery()：运行以SELECT语句开头的描述，同时返回一个包含查看结果的ResultSet对象。</span><br><span class="line">3. executeUpdate()：修改数据表内容，例如新增、删除、修改数据等。</span><br></pre></td></tr></table></figure></p><p>3.32 (JDBC)如何一次运行多段SQL<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先建立一个Statement对象，将多个想要运行的SQL指令以addBatch()方法加到批处理文档中，最后引用executeBatch()方法运行。</span><br></pre></td></tr></table></figure></p><p>3.33 分页显示技术的优劣<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 使用游标走位，丢弃不属于页面的数据。</span><br><span class="line">2. 使用缓存结果集，一次查询所有数据。</span><br><span class="line">3. 使用数据库提供的定位集SQL语句，返回指定行的数据。</span><br></pre></td></tr></table></figure></p><p>3.34 数据库管理系统的主要功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据定义功能。</span><br><span class="line">2. 数据操纵功能。</span><br><span class="line">3. 数据库的运行管理。</span><br><span class="line">4. 数据库的建立和维护。</span><br></pre></td></tr></table></figure></p><p>3.35 Servlet的生命周期<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 装载Servlet。</span><br><span class="line">2. 创建Servlet实例。</span><br><span class="line">3. Web容器调用Servlet的Init()方法，对Servlet进行初始化。（Init方法只能调用一次）</span><br><span class="line">4. Servlet初始化之后，将一直存在于容器中，service()响应客户端请求。</span><br><span class="line">(1) 如果客户端发送GET请求，容器调用Servlet的doGet方法处理并响应请求。</span><br><span class="line">(2) 如果客户端发送POST请求，容器调用Servlet的doPost方法处理并响应请求。</span><br><span class="line">(3) 或者统一用service()方法处理来响应用户请求。</span><br><span class="line">5. Web容器决定销毁Servlet时，先调用Servlet的destroy()方法，通常在关闭web应用之前销毁Servlet。（destroy方法仅执行一次）</span><br><span class="line">（Web容器是指存放代码的服务器）</span><br><span class="line"></span><br><span class="line">一系列事件按先后顺序为：加载类、实例化、初始化、请求处理、销毁。</span><br></pre></td></tr></table></figure></p><p>3.36 Servlet和JSP的关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Servlet是服务器端运行的一种Java应用程序。当浏览器端有请求则将其结果传递给浏览器。在JSP中使用到的所有对象都将被转换为Servlet或者非Servlet的Java对象，然后被执行，所以执行JSP实际上与执行Servlet是一样的。</span><br></pre></td></tr></table></figure></p><p>3.37 开发一个Servlet所需的步骤<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 编写Servlet实例。</span><br><span class="line">2. 在web.xml文件中配置该Servlet。</span><br><span class="line">3. 编写其它文件。</span><br></pre></td></tr></table></figure></p><p>3.38 HttpSession接口的功能和使用方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. HttpSession接口是Servlet提供会话追踪解决方案。HttpSession对象存放在服务器端，只是对Cookie和url重写技术的封装应用。</span><br><span class="line">2. 使用HttpSession进行会话控制的过程：</span><br><span class="line">(1) 获得一个HttpSession实例对象。</span><br><span class="line">(2) 访问和设置与会话相关关联信息。</span><br><span class="line">(3) 废弃会话数据。</span><br></pre></td></tr></table></figure></p><p>3.39 编写一个利用HttpSession接口的用户登录的Servlet，当用户已经登录时，返回欢迎信息，否则转向登录页面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：编写Servlet实例SessionServlet.java</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用HttpSession管理会话的登录Servlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">doPost(request,response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line"><span class="keyword">throws</span> ServletException, IOExcetion&#123;</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=GB2312&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;title&gt;使用HttpSession管理会话的登录页面&lt;/title&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取会话对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">//从会话对象中读取数据</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isLogin</span> <span class="operator">=</span> (Boolean)session.getAttribute(<span class="string">&quot;isLogin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isLogin == <span class="literal">null</span>)&#123;</span><br><span class="line">isLogin = Boolean.FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">passward</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;pass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isLogin.booleanValue())&#123;</span><br><span class="line"><span class="comment">//从会话对象中读取数据</span></span><br><span class="line">user = (String)session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">loginTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(session.getCreationTime());</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;h2&gt;欢迎您，&quot;</span>+user+<span class="string">&quot;！&lt;/h2&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;h2&gt;您的登录时间是：&quot;</span>+loginTime+<span class="string">&quot;！&lt;/h2&gt;&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((user != <span class="literal">null</span>) &amp;&amp; (password != <span class="literal">null</span>))&#123;</span><br><span class="line"><span class="comment">//在会话对象中保存数据</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">session.setAttribute(<span class="string">&quot;isLogin&quot;</span>,Boolean.TRUE);</span><br><span class="line"><span class="type">Date</span> <span class="variable">loginTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(session.getCreationTime());</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;h2&gt;欢迎您，&quot;</span>+user+<span class="string">&quot;！&lt;/h2&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;h2&gt;您的登录时间是：&quot;</span>+loginTime+<span class="string">&quot;！&lt;/h2&gt;&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;h2&gt;请在下面输入登录信息&lt;/h2&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;form method=\&quot;post\&quot; action=\&quot;login\&quot;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;table&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;td&gt;用户名：&lt;/td&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;td&gt;&lt;input name=\&quot;user\&quot; type=\&quot;text\&quot;&gt;&lt;/td&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;td&gt;密码：&lt;/td&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;td&gt;&lt;input name=\&quot;cancel\&quot; type=\&quot;reset\&quot; value=\&quot;重置\&quot;&gt;&lt;/td&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.printIn(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二步：在web.xml文件中配置该Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">&lt;!--ServerInfoServlet definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>getSession<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getSession<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.SessionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SessionServlet definition--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getSession<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/getSession<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>3.40 Filter接口、FilterConfig接口和FilterChain接口的功能分别是什么？提供的方法有哪些？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所有的过滤器在开发中必须实现javax.servlet.Filter接口，并且提供一个公开的不带参数的构造方法。接口定义了init()、doFilter()、destroy()三个方法。</span><br><span class="line">当容器对Filter对象进行初始化时，容器调用Filter的init()方法，并传入一个实现FilterConfig接口的对象。Filter可以使用该对象获得一些有用信息。</span><br><span class="line">FilterConfig接口包含以下方法：getFilterName()、getInitParameter()、getInitParameterNames()、getServletContext()。</span><br><span class="line">过滤器对象使用FilterChain对象调用过滤器链中的下一个过滤器或者是调用目标资源。FilterChain接口仅定义一个方法：public void doFilter(ServletRequest req, ServletResponse res)。</span><br></pre></td></tr></table></figure></p><p>3.41 如何编写并配置过滤器<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 开发jsp页面。</span><br><span class="line">2. 编写过滤器类。</span><br><span class="line">3. 在web.xml文件中添加配置过滤器的代码。</span><br><span class="line">4. 验证过滤器运行效果。</span><br></pre></td></tr></table></figure></p><p>3.42☆ 编写一个过滤器LogFilter.java，对Request请求进行过滤，记录请求的访问时间戳、从请求获取远程地址、从请求获取远程主机名、客户请求的资源URL、客户用的浏览器，并记录到日志文件中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写LogFilter.java</span></span><br><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> Implements Filter&#123;</span><br><span class="line">    FilterConfig filterConfig;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterconfig)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.filterConfig=filterconfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>&#123;</span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException&#123;</span><br><span class="line">            <span class="type">long</span> startTime=System.currentTimeMillis();<span class="comment">//访问时间戳</span></span><br><span class="line">            String remoteAddress=request.getRemoteAdd();<span class="comment">//从请求获取远程地址</span></span><br><span class="line">            String remoteHost=request.getRemoteHost();<span class="comment">//从请求获取远程主机名</span></span><br><span class="line">            HttpServletRequest httpRequest=(HttpServletRequest)request;</span><br><span class="line">            String reqURL=httpRequest.getRquestURL();<span class="comment">//客户请求的资源URL</span></span><br><span class="line">            String browser=httpRequest.getHeader(<span class="string">&quot;User-Agent&quot;</span>);<span class="comment">//客户用的浏览器</span></span><br><span class="line">            chain.doFilter(request.response);</span><br><span class="line">            <span class="type">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> workTime=endTime-startTime;</span><br><span class="line">            ServletContext sc=filterConfig.getServletContext();</span><br><span class="line">            sc.log(<span class="string">&quot;Request from IP:&quot;</span>+remoteAddress+<span class="string">&quot;(&quot;</span>+remoteHost+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;Using browser (&quot;</span>+browser+<span class="string">&quot;)&quot;</span>+<span class="string">&quot; and wanted to access resource &quot;</span>+reqURL+<span class="string">&quot; and used &quot;</span>+workTime+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中添加如下代码部署监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filters.LogFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>LogFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>3.43 什么是过滤器？什么是监听器？分别应用在哪些方面？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对Web应用来说，过滤器就是驻留在服务器端，在源数据和目的数据间，对Web请求和Web响应的头属性和内容体进行操作的一种特殊Web组件。</span><br><span class="line">2. Servlet监听器是Web应用程序事件模型的一部分，Servlet监听器用于监听一些Web应用中重要事件的发生，监听器对象可以在事件发生前、发生后，Servlet容器就会产生相应的事件，Servlet监听器用来处理这些事件。</span><br></pre></td></tr></table></figure></p><p>3.44<br>ServletContextListener接口的功能和提供的方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletContextListener接口的功能和提供的方法：在Web应用程序启动时需要执行一些初始化任务，可以编写实现ServletContextListener接口的监听器类。</span><br><span class="line">ServletContextListener接口中定义了两个事件处理方法，contextInitialize()和contextDestroy()。</span><br></pre></td></tr></table></figure><br>ServletContextAttributeListener接口的功能和提供的方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletContext的属性是由Web应用程序中所有的Servlet所共享的。为保证属性在整个Web应用范围内的一致性，有必要监视ServletContext对象任何属性的改变。ServletContextListener接口就是为这一目的而设立的。</span><br><span class="line">ServletContextAttributeListener接口共提供了三种方法，attributeAdd()、attributeRemoved()、attributeReplaced()。</span><br></pre></td></tr></table></figure><br>HttpSessionBindingListener接口的功能和提供的方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果一个对象实现了HttpSessionBindingListener接口，当该对象被绑定到Session中或从Session中删除时，Servlet容器会通知该对象，该对象在接收到通知后做初始化操作或清除状态操作。</span><br><span class="line">HttpSessionBindingListener接口提供如下方法，valueBound()、valueUnbound()、HttpSessionBindingEvent()。</span><br></pre></td></tr></table></figure></p><p>3.45 JSP乱码如何解决，列出几种解决方案<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. JSP页面出现的中英文乱码。</span><br><span class="line">MyEclipse中默认的编码为ISO-8859-1，而ISO-8859-1不支持中文的编码，所以jsp文件内出现中文就不能保存了。只要在页面上加上支持中文的编码格式，如pageEncodeing=&quot;gb2312&quot;。</span><br><span class="line">2. 表单提交中文乱码。</span><br><span class="line">Tomcat中，对于以post方式提交的表单编码格式默认为ISO-8859-1，它无法编码中文。需要在取得表单参数时设置编码方式，如request.setCharacterEncoding(&quot;gb2312&quot;)。</span><br></pre></td></tr></table></figure></p><p>3.46☆ 编写一个监听器ContextListener.java，监听Web应用的启动和停止，并记录到日志文件中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span>&#123;</span><br><span class="line">ServletContext context=sce.getServletContext();</span><br><span class="line">context.log(context.getServletContextName()+<span class="string">&quot; initialated.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">com.mycompany.servlet.ContextListener</span><br><span class="line"><span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 在Tomcat中部署包含侦听器的Web应用。</span><br><span class="line">2. 启动Tomcat，则侦听器就会在日志文件中添加一行信息。</span><br><span class="line">3. 关闭Tomcat，侦听器同样会在日志文件中添加一行信息。</span><br></pre></td></tr></table></figure></p><p>3.47 在EL中访问变量的值可以使用如下的EL元素：<code>$&#123;变量名&#125;</code>，如果没有指定变量的有效范围，JSP容器会依次到那几个范围内查找该变量？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pageScope]、[requestScope]、[sessionScope]、[applicationScope]。</span><br></pre></td></tr></table></figure></p><p>3.48 如何用隐含对象获取表单参数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">隐含对象param与paramValues被设计用来提供使用request之外的一个选择，这两个最大的好处便是简化了request参数数据的存取。</span><br><span class="line">取值的范例程序：$&#123;param.yarValue&#125;</span><br><span class="line">param内容包含当前网页所有的request参数，这段程序代码取的其中名为yearValue的参数值。</span><br></pre></td></tr></table></figure><br>|EL对象|Request对象|<br>|——-|——-|<br>|<code>$&#123;param.paraName&#125;</code>|request.getParameter(paraName)|<br>|<code>$&#123;paramValues.paraName&#125;</code>|request.getParameterValues(paraName)|</p><p>3.49 简述JSTL与一般的JSP技术有何差异<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用JSTL实现动态JSP页面的最大特点在于简单，避免了使用脚本片段带来的许多问题，Web应用开发人员利用JSTL可以取代之间嵌入页面的代码片段，提高程序可读性和可维护性。</span><br></pre></td></tr></table></figure></p><p>3.50 JSTL的优点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在页面里使用JSTL标签可以是美工像处理HTML标签一样对待，增加了可读性。</span><br><span class="line">2. 将业务封装到JSTL可以很方便地重用。</span><br><span class="line">3. 将数据与显示分离。</span><br><span class="line">4. 简化了JSP的Web应用系统的开发，并且使得JSP页面的编程风格同一，易于维护。</span><br><span class="line">5. 可以对其进行自定义扩展。</span><br></pre></td></tr></table></figure></p><p>3.51 在Tomcat中安装使用JSTL的步骤</p><p>3.52 在JSTL中，<code>&lt;c:if&gt;</code>和<code>&lt;c:choose&gt;</code>这两种标签都可以用来进行流程判断，请说明它们的差异和用法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;c:if&gt;标签用于进行条件判断，只有当其test属性指定的Boolean表达式值为true时才会处理其本体的内容，否则不执行。</span><br><span class="line">2. &lt;c:choose&gt;标记用来处理多个可选条件下的选择。&lt;c:choose&gt;标记需要和&lt;c:when&gt;、&lt;c:otherwise&gt;标记配套使用，并且&lt;c:when&gt;、&lt;c:otherwise&gt;必须依附在&lt;c:choose&gt;标签下。</span><br></pre></td></tr></table></figure></p><p>3.53☆ 使用标准标签库中的<code>&lt;c:foreach&gt;</code>标签、<code>&lt;c:i&gt;</code>标签和<code>&lt;c:out&gt;</code>标签列出1-100中能被2整除不能被3整除的数字。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;sum&quot;</span> value=<span class="string">&quot;0&quot;</span>/&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;s&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;100&quot;</span> step=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;s%2==0 &amp;&amp; s%3!=0&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;condition&quot;</span>&gt;</span><br><span class="line">输出：&lt;c:out value=<span class="string">&quot;$&#123;s&#125;&quot;</span>/&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.54 说明如何使用JSTL提供电费标签设置联机信息<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--使用&lt;sql:setDataSource&gt;标记来指定数据源：--&gt;</span><br><span class="line">&lt;sql:setDataSource </span><br><span class="line">&#123; </span><br><span class="line">dataSource=<span class="string">&quot;dataSource&quot;</span> | url=<span class="string">&quot;jdbcUrl&quot;</span></span><br><span class="line">[driver=<span class="string">&quot;driverClassName&quot;</span>]</span><br><span class="line">[user=<span class="string">&quot;userName&quot;</span>]</span><br><span class="line">[<span class="keyword">var</span>=<span class="string">&quot;varName&quot;</span>]</span><br><span class="line">[scope=<span class="string">&quot;&#123;page|request|session|application&#125;&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;!--url属性用于指定链接的url，driver属性用于指定 驱动程序，dataSource属性为数据源。--&gt;</span><br></pre></td></tr></table></figure></p><p>3.55 使用JSTL标准标记库中的标记输出1-100的数字之和。<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;sum&quot;</span> value=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">&lt;c:forEach begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;100&quot;</span> step=<span class="string">&quot;1&quot;</span> varStatus=<span class="string">&quot;st&quot;</span>&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;sum&quot;</span> value=<span class="string">&quot;$&#123;sum+st.count&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;c:out value=<span class="string">&quot;$&#123;sum&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>3.56 创建自定义标签有哪几种方式？如何使用自定义标签？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 创建自定义标签：</span><br><span class="line">(1) 传统标签的开发；</span><br><span class="line">(2) Simple标签的开发。</span><br><span class="line">2. 在标签库定义完成后，我们就可以在JSP页面中引用自定义标签：</span><br><span class="line">(1) 在JSP文件中通过taglib指令引入标签库；</span><br><span class="line">(2) 在JSP页面通过标签前缀和标签名使用标签。</span><br></pre></td></tr></table></figure></p><p>3.57 列举编写自定义标签的步骤<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 编写标签处理类。</span><br><span class="line">2. 在tld文件中配置标签。</span><br><span class="line">3. 在web.xml文件中配置标签库信息。</span><br><span class="line">4. 在JSP页面引用标签。</span><br></pre></td></tr></table></figure></p><p>3.58☆ 使用Tag接口编写一个输出welcome的自定义标签<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WelcomeTag.java</span></span><br><span class="line"><span class="keyword">package</span> demo.tag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义标签 WelcomeTag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.targext.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeTag</span> <span class="keyword">implements</span> <span class="title class_">Tag</span>&#123;</span><br><span class="line"><span class="keyword">private</span> PageContext pageContext;</span><br><span class="line"><span class="keyword">private</span> Tag parent;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WelcomeTag</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置标签的JSP页面上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPageContext</span><span class="params">(PageContext pageContext)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.pageContext=pageContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置上一级标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Tag parent)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.parent=parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Tag <span class="title function_">getParent</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始标签时的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doStartTag</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">throws</span> JspException&#123;</span><br><span class="line"><span class="keyword">return</span> Tag.SKIP_BODY;<span class="comment">//返回SKIP_BODY，表示不计算标签体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束标签时的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doEndTag</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">throws</span> JspException&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">pageContext.getOut().write(<span class="string">&quot;Welcome!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JspTagException</span>(<span class="string">&quot;IO Error:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Tag.EVAL_PAGE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--标签库描述文件mytag.tld--&gt;</span><br><span class="line">……</span><br><span class="line">&lt;tag&gt;</span><br><span class="line">&lt;name&gt;welcome&lt;/name&gt;</span><br><span class="line">&lt;tag-class&gt;ch15.Welcome&lt;/tag-class&gt;</span><br><span class="line">&lt;body-content&gt;empty&lt;/body-content&gt;</span><br><span class="line">&lt;/tag&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置web.xml--&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib-url</span>&gt;</span>/mytag.tld<span class="tag">&lt;/<span class="name">taglib-url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib-location</span>&gt;</span>/WEB-INF/mytag.tld<span class="tag">&lt;/<span class="name">taglib-location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--JSP页面引用标签 WelcomeTag.jsp--&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">&quot;text/html;charset=gb2312&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> url=<span class="string">&quot;/WEB-INF/mytag.tld&quot;</span> prefix=<span class="string">&quot;my&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;测试自定义标签&lt;/h2&gt;</span><br><span class="line">&lt;my:welcome /&gt;&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;my:welcomeloop count=<span class="string">&quot;3&quot;</span>&gt;</span><br><span class="line">&lt;p style=<span class="string">&quot;color:red;&quot;</span>&gt;JSP爱好者&lt;/p&gt;</span><br><span class="line">&lt;/my:welcomeloop&gt;</span><br><span class="line">&lt;% String outValue=<span class="string">&quot;, Welcome!&quot;</span>; %&gt;</span><br><span class="line">&lt;my:mytag b=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">&lt;my:mytag2 value=<span class="string">&quot;&lt;%=outValue%&gt;&quot;</span>&gt;JSP爱好者&lt;/my:mytag2&gt;</span><br><span class="line">&lt;/my:mytag&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>3.59☆ 通过继承TagSupper类实现输出welcome的自定义标签</p><p>3.60☆ 通过BodyTagSupport类实现welcome的迭代输出</p><p>3.61 评价Web服务器性能的步骤<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 管理多用户的数据库。</span><br><span class="line">2. 管理用户权限及保证数据的安全性。</span><br><span class="line">3. 管理和处理用户的请求，用户请求包括请求队列、响应请求、通知服务完成、返回结果。</span><br><span class="line">4. 维护数据库，包括备份和恢复。</span><br></pre></td></tr></table></figure></p><p>3.62 JavaBean编写要求<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 所有的JavaBean必须放在一个包（Package）中。</span><br><span class="line">2. JavaBean必须生成public class类，文件名应该与类名称一致。</span><br><span class="line">3. 所有属性必须封装，一个JavaBean类不应有公共实例变量，类变量都为private。</span><br><span class="line">4. 属性值应该通过一组存取方法（getXxx:setXxx）来访问：对于每个属性，应该有一个带匹配共用getter和setter方法的专用实例变量。</span><br><span class="line">5. JavaBean类：须有一个空的构造函数，类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个属性的设置方法来设置属性的默认值。</span><br></pre></td></tr></table></figure></p><p>3.63 Servlet执行时一般实现哪几个方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void init(ServletConfig config)</span><br><span class="line">public ServletConfig getServletConfig()</span><br><span class="line">public String getServletInfo()</span><br><span class="line">public void service(ServletRequest request, ServletResponse response)</span><br><span class="line">public void destroy()</span><br></pre></td></tr></table></figure></p><p>3.64 互联网作为全球信息系统的三大特征<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Internet中的计算机通过全球性的唯一地址逻辑地连接在一起，这个地址是建立在网间协议（IP）或今后其他协议基础之上的。</span><br><span class="line">2. Internet中的计算机之间的通信使用的是TCP/IP协议。</span><br><span class="line">3. Internet可以为公共用户或个人用户提供高水平的信息服务，这种服务是建立在上述通信及相关的基础设施之上的。</span><br></pre></td></tr></table></figure></p><p>3.65 系统功能结构图设计步骤<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 从新系统数据流程图出发导出初始结构图。即首先把整个系统看作一个模块，然后对其逐层分解。分解时，要遵守划分模块的基本原则和完成数据流程图所规定的各项任务及其处理顺序。每分解出一层模块，都熬标明信息传递情况并考虑每一模块的实现方法，同时还要考虑系统结构的层数。</span><br><span class="line">2. 对系统结构图进行改进。即从提高模块的对象目标出发，检查每一个模块，是否还可以降低关联度，提高聚合度，如果可以，就要对其改进，直到理想为止。</span><br></pre></td></tr></table></figure></p><p>3.66 Web页面的处理过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 页面的一次往返处理。页面被提交到服务器端，执行响应的事件处理代码，重建页面，然后返回到客户端。</span><br><span class="line">2. 页面重建。每一次页面被请求，或者页面被提交到服务器，运行环境将执行必要的代码，重建整个页面，把结果页面送到浏览器，然后抛弃页面的变量、控件的状态和属性等页面信息。</span><br></pre></td></tr></table></figure></p><p>3.67 纯Servlet方案中存在的问题<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 开发和维护应用程序的所有部分需要有深厚的Java编程知识。</span><br><span class="line">2. 改变应用程序的外观和风格，或者加入对某种新类型客户机的支持时，都需要重新编译Servlet代码。</span><br><span class="line">3. 很难利用网页开发工具的优势来设计应用程序界面。</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/JSP/">JSP</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Servlet/">Servlet</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/09/05/LearnJSP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>回杭的日子4</title>
      <link>https://pearlchocolatezy.com/2024/08/24/BackToHangzhou4/</link>
      <guid>https://pearlchocolatezy.com/2024/08/24/BackToHangzhou4/</guid>
      <pubDate>Sat, 24 Aug 2024 12:24:48 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;img class=&quot;zy_img_shadow&quot; src=&quot;/2024/08/24/BackToHangzhou4/linyin.jpg&quot; alt=&quot;带好友游玩灵隐寺&quot; width=&quot;40%&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img class=&quot;zy_img</description>
        
      
      
      
      <content:encoded><![CDATA[<p><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/linyin.jpg" alt="带好友游玩灵隐寺" width="40%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/sushi.jpg" alt="这家素食店味道不错" width="40%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/tianpindian.jpg" alt="一家甜品店 澄沙ann" width="40%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/bafei.jpg" alt="芭菲" width="60%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/longjingxiaren.jpg" alt="龙井虾仁" width="60%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/huangyuniangao.jpg" alt="黄鱼年糕" width="60%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/mianbaobowuguan.jpg" alt="面包博物馆" width="60%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/xihu.jpg" alt="船上游湖" width="60%"><br><br><br><img class="zy_img_shadow" src="/2024/08/24/BackToHangzhou4/santanyinyue.jpg" alt="三潭印月" width="40%"></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/%E6%9D%AD%E5%B7%9E/">杭州</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/08/24/BackToHangzhou4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
