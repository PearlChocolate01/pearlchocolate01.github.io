<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Mon, 23 Jun 2025 14:50:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>04747-Java（七）——输入和输出流</title>
      <link>https://pearlchocolatezy.com/2025/06/21/04747-07/</link>
      <guid>https://pearlchocolatezy.com/2025/06/21/04747-07/</guid>
      <pubDate>Sat, 21 Jun 2025 14:10:53 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;OutputStream的常用方法write(int i),close(),flush()表示将字节i写入到数据流中，将输出流关闭，刷新输出流并强制写出所有缓冲的输出字节。&lt;/li&gt;
&lt;li&gt;Jav中所有涉及数据流的操作中，都会引入包&lt;i id=&quot;answer2</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>OutputStream的常用方法write(int i),close(),flush()表示将字节i写入到数据流中，将输出流关闭，刷新输出流并强制写出所有缓冲的输出字节。</li><li>Jav中所有涉及数据流的操作中，都会引入包<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">java.io</i>。</li><li>请说明输入数据流中方法read()和方法read(byte[] b)的作用是什么：【背】<br>方法read()的作用是：从输入流中读取一个字节的二进制数据。<br>方法read(byte[] b)的作用是：将多个字节读到数组中,填满整个数组。</li><li>Java中把不同的输入、输出源抽象为<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">流</i>。</li><li><p>什么是数据流，数据流分为哪些类，各类的特点是什么：【背】<br>数据流是指一组有顺序的、有起点和终点的字节集合。<br>数据流分为输入数据流和输出数据流,输入数据流只能读不能写,输出数据流只能写不能读。<br>从数据流中读取数据时,必须有一个数据源与该数据流相连。</p></li><li><p>不是所有对象都可以序列化。</p></li><li>接口Serilizable中没有定义任何方法，只作为一个标记指示实现该接口的类可以进行序列化。</li><li>一般在关闭输出流之前，应先使用flush()方法，强制输出剩余数据。</li><li>缓冲区的大小可变。</li><li>使用输入数据流中的read()方法，读取结束时返回-1。</li><li>对象序列化可以保存的是非静态成员变量。<br>（对象的序列化是将对象的状态转换为字节流，以便保存到文件或通过网络传输。<br>序列化关注的是对象的状态，而非类的状态。静态成员变量属于类本身，而非静态成员变量是每个实例对象独有的状态信息。）</li><li>为什么在关闭缓冲区输出流之前应执行flush方法？【背】<br>对于缓冲区输出流,当执行写入操作时,数据以块为单位进入缓冲区,当缓冲区的块空间被填满数据时才会真正将数据写到了输出流中。在最后一次执行写入操作后,缓冲区的块空间可能未被填满,所以此时没有将块中的数据真正的写入到输出流中,未真正的执行输出操作,此时若直接向该缓冲区输出流,则块中的数据会丢失。所以,在关闭缓冲区输出流之前,应先使用flush()方法,强制将剩余的数据写入到输出流中。</li><li>请简述过滤器数据流的概念及其种类：【背】<br>一个过滤器数据流在创建时与一个已经存在的数据流相连,这样在从这样的数据流中读取数据时,它提供的是对一个原始输入数据流的内容进行了特定处理的数据。<br>过滤器数据流有缓冲区数据流和数据数据流两种。</li><li>FilelnputStream和FileOutputStream的数据源或数据终点都应当是<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">文件</i>。</li><li>顶层容器都有一个<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">内容窗格</i>。</li><li>Java如何实现对象的序列化？【背】<br>Java中有一个接口java.io.Serializable，接口Serializable中没有定义任何方法,只是作为一个标记来指示实现该接口的类可以进行序列化,当一个类声明实现了Serializable接口时,表明该类的对象是可以序列化的,否则不能序列化。</li><li>写Java基本数据类型需要用<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">DataOutputStream</i>。</li><li>请写出采用缓冲式输入方式，按行输入文件内容的步骤：<br>先创建FilcReaer对象(1分),<br>再利用FileReader对象创建BufferedReader对象(1分),<br>然后对该对象使用readLine()方法(1分)。</li><li>字节流和字符流<br>处理字节流：BufferInputStream &amp; BufferOutputStream，FileInputStream &amp; FileOutputStream，ObjectInputStream &amp; ObjectOutputStream。<br>处理字符流：InputStreamReader &amp; OutputStreamWriter（<strong>InputStreamReader和OutputStreamWriter是字符流和字节流之间的桥梁</strong>，InputStreamReader将字节流转字符流，OutputStreamWriter将字符流转字节流）。</li><li>程序要采用缓冲式输入，只要先创建FileReader对象，再利用FileReader对象创建BufferedReader对象，习惯称为FileReader对象接到BufferedReader对象上。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferReader br;</span><br><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;abc.txt&quot;</span>);</span><br><span class="line">br=<span class="keyword">new</span> <span class="title class_">BufferReader</span>(fr);<span class="comment">//BufferReader实例的参数只能是Reader结尾的类型</span></span><br><span class="line">String s=br.readLine();</span><br></pre></td></tr></table></figure></li><li><code>System.in</code>用于控制台输入数据读取<br>转为代码中字符处理的过程：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br></pre></td></tr></table></figure></li><li>读c盘下java文件夹中的1.data，输出文件名、内容、文件大小：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\java\\1.data&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;文件名：&quot;</span>+f.getName());</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line">BufferReader br=<span class="keyword">new</span> <span class="title class_">BufferReader</span>(isr);</span><br><span class="line">System.out.println(<span class="string">&quot;文件内容：&quot;</span>);</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span>((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小：&quot;</span>+f.length)</span><br></pre></td></tr></table></figure></li><li>请说明Java基本字符流中读者、写者出现的原因及作用：<br>有些程序设计语言使用ASCI字符集,而Java使用Unicode字符集表示字符和字符串。<br>ASCII字符集以一个字节表示一个字符,可以认为一个字符就是一个字节。<br>Java使用两个字节表示一个字符,这时字节与字符就不再相同。Java为实现与其他程序语言及不同平台的交互,提供了一种新的数据流处理方案,称为读者和写者。读者和写者的作用是在字节流和字符流之间作中介,在构造方法中应指定一定的平台规范,以便把以字节方式表示的流转换为特定平台上的字符表示。</li><li>FileWriter类的作用是<i id="answer24_1" class="answer" onclick="showOrHide('24_1')">字符流文件写操作</i>。</li><li>Java语言使用的字符集是<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">Unicode</i>。</li><li><p>在BufferReader类中，能实现按行输入的方法为<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">readLine</i>。</p></li><li><p>File类不能实现的：写入数据；读写文件；getContent()；</p></li><li>File类的重命名文件方法是<code>f.renameTo(nf);</code>，获取文件名<code>getName()</code>，获取文件路径名<code>getPath()</code>。</li><li>File类的getParent()方法的作用是：获取文件父级目录名称。</li><li>Java提供的随机访问文件的类为<i id="answer30_1" class="answer" onclick="showOrHide('30_1')">RandomAccessFile</i>，该类读取一个字符的方法是<i id="answer30_2" class="answer" onclick="showOrHide('30_2')">readChar()</i>，向文件写入一个字符的方法是<i id="answer30_3" class="answer" onclick="showOrHide('30_3')">writeChar()</i>。</li><li>FileInputStream的read0方法读取各字符的ASCII码</li><li>能够输入输出对象的流称为<i id="answer32_1" class="answer" onclick="showOrHide('32_1')">对象流</i>。</li><li>序列化，反序列化</li><li>InputStream类能从输入流中读一个字节的二进制数据的方法是<i id="answer34_1" class="answer" onclick="showOrHide('34_1')">read</i>，能将一个字节的二进制数据写入输出流的是<i id="answer34_2" class="answer" onclick="showOrHide('34_2')">write</i>。</li><li>Java中的缓冲区字符输入流类是<i id="answer35_1" class="answer" onclick="showOrHide('35_1')">BufferedReader</i>，缓冲区字符输出流类是<i id="answer35_2" class="answer" onclick="showOrHide('35_2')">BufferedReader</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/21/04747-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（七）——软件生存周期过程与管理</title>
      <link>https://pearlchocolatezy.com/2025/06/21/02333-7/</link>
      <guid>https://pearlchocolatezy.com/2025/06/21/02333-7/</guid>
      <pubDate>Sat, 21 Jun 2025 12:48:53 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;按过程主体，软件生存周期分为：基本过程，支持过程，组织过程。&lt;/li&gt;
&lt;li&gt;软件基本过程：获取过程，供应过程，开发过程，运行过程，维护过程。&lt;/li&gt;
&lt;li&gt;软件验证过程的任务：需求验证，设计验证，代码验证，集成验证，文档验证。&lt;/li&gt;
&lt;li&gt;简述软件</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>按过程主体，软件生存周期分为：基本过程，支持过程，组织过程。</li><li>软件基本过程：获取过程，供应过程，开发过程，运行过程，维护过程。</li><li>软件验证过程的任务：需求验证，设计验证，代码验证，集成验证，文档验证。</li><li>简述软件验证过程中，过程实现的任务：【背】<br>（1）确定项目<font color="blue">是否需要</font>一项验证工作以及独立程度。<br>（2）如果项目承担验证工作,则应为验证软件产品建立相应的<font color="blue">验证过程</font>。<br>（3）如果项目需要独立的验证工作,则应选择一个<font color="blue">有资格的组织</font>负责进行验证。<br>（4）基于以上有关范围、粒度、复杂性和至关重要性分析,确定需要验证的生存周期活动和软件产品,并应为所选择的生存周期活动和软件产品<font color="blue">选择适当的验证活动</font>和任务以及执行这些任务相关的方法、技术<font color="blue">和工具</font>。<br>（5）基于所确定的验证任务,开发验证计划并建立相应的<font color="blue">文档</font>。<br>（6）<font color="blue">实现</font>验证计划。</li><li>什么是验证和确认，以及它们的区别？【背】<br>（1）验证就是证实一个过程或项目的每一软件工作产品/服务是否正确地反映了所规约的需求。；（1分）<br>（2）确认就是证实所期望使用的软件工作产品是否满足其需求；（1分）<br>（3）区别：验证是通过提供的客观证据、证实规约的需求是否得以满足；确认是通过提供的客观证据，证实有关特定期望的使用或应用的需求是否得以满足。（3分）</li><li>软件生存周期过程分为<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">5</i>个基本过程，<i id="answer4_2" class="answer" onclick="showOrHide('4_2')">8</i>个支持过程，<i id="answer4_3" class="answer" onclick="showOrHide('4_3')">4</i>个组织过程。</li><li>软件生存周期的七个过程组：<br>需求分析过程：意图是建立系统软件部分需求。<br>软件确认过程：证实期望使用的软件产品是否满足其需求。</li><li>增量模型：快速构建第一版产品的好方法；适合在项目一开始增加一两个需求，可减少需求变更。</li><li>螺旋模型：适合开发风险大需求不确定的项目；引入<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">风险分析</i>。</li><li>喷泉模型：支持面向对象技术。</li><li>瀑布模型：适合开发小组非常熟悉项目需求；有自上而下相互衔接的固定顺序。</li><li>简述演化模型及其适用场合：【背】<br>（1）演化模型是在用户提出待开发系统的核心需求的基础上，开发人员按照这一需求，首先开发一个核心系统投入运行，根据用户反馈，实施迭代，每次迭代均由需求、设计、编码、测试、集成等阶段组成，通过增加或修正，产生软件产品的增量，最终完成软件产品的开发。<br>（2）一定程度上可减少软件开发活动盲目性;<br>（3）该模型主要针对事先不能完整定义需求的软件开发。</li><li>简述瀑布模型各阶段：【背】<br>（1）系统需求；（1分）<br>（2）软件需求；（1分）<br>（3）需求分析；（1分）<br>（4）设计；（1分）<br>（5）编码；（1分）<br>（6）测试；（1分）<br>（7）运行。（1分）</li><li>简述瀑布模型概念及其主要问题：<br>定义：瀑布模型将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作,形如瀑布流水,最终得到产品。(1分)<br>问题：<br>（1）要求客户能够完整、正确和清晰地表达他们的需求;并要求开发人员一开始就要理解这一应用。(1分)<br>（2）由于需求的不稳定性,使设计、编码和测试阶段都可能发生延期;并且当项目接近结束时,出现了大量的集成和测试工作。(1分)<br>（3）在开始的阶段中,很难评估真正的进度状态;并且直到项目结束之前都不能演示系统的能力。(1分)<br>（4）在一个项目的早期阶段,过分地强调了基线和里程碑处的文档;并可能需要花费更多的时间用于建立一些用处不大的文档。(1分)</li><li>简述螺旋模型概念及其特点：<br>（1）螺旋模型是瀑布模型与演化模型的基础上加入两者所忽略的风险分析所建立的一种软件开发模型。(2分)<br>（2）螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。(3分)</li><li>项目管理计划的主体是<i id="answer16_1" class="answer" onclick="showOrHide('16_1')">过程管理计划</i>。</li><li>支持生存周期过程具有重要作用的计划：<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">软件工程管理</i>计划，<i id="answer17_2" class="answer" onclick="showOrHide('17_2')">软件配置管理</i>计划，<i id="answer17_3" class="answer" onclick="showOrHide('17_3')">软件质量保证</i>计划，<i id="answer17_4" class="answer" onclick="showOrHide('17_4')">软件验证和确认</i>计划，<i id="answer17_5" class="answer" onclick="showOrHide('17_5')">软件度量</i>计划。</li><li>简述选择一个合适项目的生存周期模型的步骤：【背】<br>（1）标识开发项目可用的SLCM（软件生命周期管理）。<br>（2）在所期望的最终系统和开发环境中,识那些会影响SLCM选择的属性。<br>（3）标识为选择生存周期模型所需要的任何约束,包括外部的或是内部的。<br>（4）基于以往的经验和组织能力,评估第一步所选择的那几个SLCM。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/21/02333-7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（六）——软件测试</title>
      <link>https://pearlchocolatezy.com/2025/06/13/02333-6/</link>
      <guid>https://pearlchocolatezy.com/2025/06/13/02333-6/</guid>
      <pubDate>Fri, 13 Jun 2025 13:47:56 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;调试是为了证明程序员的正确。&lt;/li&gt;
&lt;li&gt;调试的结果一般是不可预见的。&lt;/li&gt;
&lt;li&gt;调试是不受时间约束的。&lt;/li&gt;
&lt;li&gt;测试从一个侧面证明程序员的“失败”。&lt;/li&gt;
&lt;li&gt;测试以已知条件开始。&lt;/li&gt;
&lt;li&gt;静态软件评估技术：评审，代码</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>调试是为了证明程序员的正确。</li><li>调试的结果一般是不可预见的。</li><li>调试是不受时间约束的。</li><li>测试从一个侧面证明程序员的“失败”。</li><li>测试以已知条件开始。</li><li>静态软件评估技术：评审，代码检查（走查），静态分析（形式化证明）。</li><li>测试的首要目标是<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">预防错误</i>。</li><li>集成测试的目标是为了发现<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">与接口有关的错误</i>。</li><li>软件测试是一个有程序的过程，包括测试<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">设计</i>、测试<i id="answer9_2" class="answer" onclick="showOrHide('9_2')">执行</i>、测试<i id="answer9_3" class="answer" onclick="showOrHide('9_3')">结果比较</i>。</li><li>软件评估分为<i id="answer10_1" class="answer" onclick="showOrHide('10_1')">静态评估</i>，<i id="answer10_2" class="answer" onclick="showOrHide('10_2')">动态评估</i>。</li><li>依据程序逻辑结构的测试技术<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">白盒测试技术</i>。<br>包括：路径测试技术。</li><li>黑盒测试技术又称功能测试技术，包括：事务处理流程技术，定义域测试技术，状态测试技术；等价划分类，边界值分析，因果图。<br>黑盒测试定义：将被测软件看成黑盒子，只通过外部的输入和输出来发现软件中的错误。</li><li>测试度量：语句覆盖≤分支覆盖≤条件组合覆盖≤路径覆盖</li><li>条件覆盖：条件覆盖是白盒测试中的一种方法，其核心要求是设计测试用例，使得程序中每个判定表达式中的每个条件的所有可能结果（如真/假）至少被执行一次‌。</li><li>路径覆盖：路径覆盖是白盒测试中的一种方法，其核心要求是设计足够多的测试用例，确保程序的每条可能执行路径都至少被执行一次（若程序存在循环结构，则每个循环至少需经过一次）。</li><li>简述边界值分析在设计测试用例时可以遵循的原则：【难背】<br>（1）如果某个输入条件规定了输入值的范围，则应选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据；（1分）<br>（2）如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数作为测试数据；（1分）<br>（3）如果程序的规格说明中，输入域或输出域是有序集合，则选取集合的第一个元素、最后一个元素以及典型元素作为测试用例；（1分）<br>（4）如果程序中使用了内部数据结构，则应当选择这个内容数据结构的边界上的值作为测试用例；（1分）<br>（5）分析规格说明，找出其他可能的边界条件。（1分）</li><li>简述因果图方法生成测试用例的基本步骤：【难背】<br>（1）通过对软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符；（1分）<br>（2）分析原因与结果之间以及原因与原因之间对应的关系，并画出因果图；（1分）<br>（3）在因果图上标识出一些特定的约束或限制条件；（1分）<br>（4）把因果图转换成判定表；（1分）<br>（5）为判定表的每一列设计测试用例。（1分）</li><li>简述边界值分析与等价类划分技术的区别：【难背】<br>（1）边界值分析与等价类划分技术的区别在于：边界值分析着重边界的测试，应选取等于、刚刚大于或刚刚小于边界的值作为测试数据；（3分）<br>（2）而等价类划分是选取等价类中的典型值或任意值作为测试数据。（2分）</li><li>软件测试技术可分为两大类：<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">白盒测试技术</i>和<i id="answer18_2" class="answer" onclick="showOrHide('18_2')">黑盒测试技术</i>。</li><li>路径测试技术的基本要点：<br>（1）采用控制流程图来表达被测试程序模型,揭示程序中的控制结构。(2分)<br>（2）通过合理地选择一组穿过程序的路径,以达到某种测试度量。(2分)</li><li>白盒测试常用到的覆盖技术：语句覆盖，分支覆盖，条件覆盖，条件组合覆盖，路径覆盖。</li><li>在设计软件测试用例之前应<i id="answer22_1" class="answer" onclick="showOrHide('22_1')">建立环境模型</i>、<i id="answer22_2" class="answer" onclick="showOrHide('22_2')">被测对象模型</i>、<i id="answer22_3" class="answer" onclick="showOrHide('22_3')">错误模型</i>。</li><li>语句覆盖：至少执行程序中所有语句一次。</li><li>分支覆盖：至少将程序中的每个分支执行一次。</li><li>合理的测试序列：单元测试，集成测试，有效性测试，系统测试。<br>单元测试：考虑模块的局部数据结构，首先测试数据流，必须为每个模块单元测试开发<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">驱动</i>模块和<i id="answer25_2" class="answer" onclick="showOrHide('25_2')">承接/桩</i>模块。<br>集成测试：发现与接口有关的错误，以主控模块作为测试驱动模块，主要缺点是需要设计承接模块，用于模块组合功能和软件结构检验的测试，每当组合一个模块要进行<i id="answer25_3" class="answer" onclick="showOrHide('25_3')">回归</i>测试，可采用<i id="answer25_4" class="answer" onclick="showOrHide('25_4')">自顶向下</i>和<i id="answer25_5" class="answer" onclick="showOrHide('25_5')">自底向上</i>两种集成方式递增组装软件。<br>有效性测试：发现软件实现功能与需求规格说明书不一致。</li><li>软件测试是一个有程序的过程，包括<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">测试设计</i>、<i id="answer26_2" class="answer" onclick="showOrHide('26_2')">测试执行</i>、<i id="answer26_3" class="answer" onclick="showOrHide('26_3')">测试结果比较</i>。</li><li>简述软件测试步骤中合理的软件测试序列及每个序列的关注点：<br>（1）合理的测试序列:单元测试、集成测试、有效性测试和系统测试。<br>（2）单元测试关注每个独立的模块。<br>（3）集成测试关注模块的组装。<br>（4）有效性测试关注检验是否符合用户所见的文档。<br>（5）系统测试关注检验习题中所有元素之间的协作是否合适,整个系统的性能、功能是否达到。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/13/02333-6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（六）——继承与多态</title>
      <link>https://pearlchocolatezy.com/2025/06/12/04747-06/</link>
      <guid>https://pearlchocolatezy.com/2025/06/12/04747-06/</guid>
      <pubDate>Thu, 12 Jun 2025 12:41:14 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;Java仅支持单重继承。&lt;/li&gt;
&lt;li&gt;如果一个类有父类，那么父类只能有一个，这条限制称为&lt;i id=&quot;answer2_1&quot; class=&quot;answer&quot; onclick=&quot;showOrHide(&#39;2_1&#39;)&quot;&gt;单重继承&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;子类不能继</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>Java仅支持单重继承。</li><li>如果一个类有父类，那么父类只能有一个，这条限制称为<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">单重继承</i></li><li>子类不能继承父类的构造方法。</li><li>允许用已定义的类来定义一个新类，新类称作<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">子类</i>。</li><li>在Java中如何判断两个对象各个属性（成员变量）的值是否相同？<br>在Java中要判断两个对象的属性(成员变量)的值是否相同,需要在类声明中对equals方法进行覆盖,即重新修改这个方法,重写的equals方法中对对象中的值是否相等一一判断。</li><li>请说明父类与子类的联系与区别：<br>大的更一般的类可以看作父类,包含在其中的特殊的、具体的类是子类。<br>子类与父类的关系是:<strong>子类对象“is a”父类对象。</strong>从层次关系上讲,子类继承自父类,父类的对象引用可以指向子类对象,反之则不行。从成员上讲,子类可以比父类拥有更多的成员变量和成员方法,这些成员变量和成员方法是子类独有的,父类不具有也不能使用。但是反过来,父类中具有公共、保护权限的成员变量和成员方法同时也属于子类,子类可以使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类对象引用指向子类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">a.eat(); <span class="comment">// 输出：Dog is eating</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判断父类变量指向的是不是子类实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;<span class="comment">//判断父类变量指向的是不是子类实例</span></span><br><span class="line">Dog d=(Dog) a;<span class="comment">//将父类变量转换成对应的子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java允许将一个子类的对象赋给父类的变量（子类对象可以作为父类对象使用），这称为<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">对象转型（向上转型）</i>。</li><li>什么是继承：<br>将一个已有类中的数据和方法保留,并加上自己特殊的数据和方法,从而构成一个新类。</li><li>简述通过继承，子类可以获得的好处：【难背】<br>（1）子类可以拥有父类的所有属性和方法(2分)；<br>（2）也可以扩展原有代码、生成新的类、原有代码可以不必重写(1分)。</li><li>类A某个成员变量的类型是类B，则类A<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">has a</i>类B。</li><li>方法覆盖：要求子类定义方法所用的名字、返回类型及参数列表和父类中的方法使用的完全一样，也就是具有相同的方法签名，从逻辑上看就是子类方法中的成员方法将隐藏父类中的同名方法。<br>名词解释：使用类的继承关系，可以从已有的类产生新的类。在原有特性的基础上，增加了新的特性。父类中原有的方法可能不能满足新的要求，因此需要修改父类中已有的方法。</li><li>重载的方法属于同一个类，覆盖的方法分属于<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">父类、子类</i>。</li><li>简述关键字super的作用：【难背】<br>如果子类重写了父类中的方法，但在子类中还想使用父类中被隐藏的方法，可以使用super关键字，另外，在子类的构造方法中也可以使用super关键字，其功能为调用父类的构造方法。<br>使用super关键字时要注意两个问题：<br>首先，使用super.method()调用父类中的方法method(),将执行父类方法中的所有操作，其中可能会包括一些原本不希望进行的操作，所以调用时要谨慎。<br>其次，由继承性的机制可以知道，super.method()语句所调用的方法不一定是在父类中加以描述的，它也可能是父类从它的祖先中继承来的。因此，有可能需要按继承层次关系依次向上查询才能找到。</li><li>方法覆盖的两条原则：【难背】<br>（1）覆盖方法的允许范围不能小于原方法。<br>（2）覆盖方法所抛出的异常不能比原方法多。</li><li>如果一个抽象类除了抽象方法外什么都没有，则使用接口更合适。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>用关键字<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">final</i>修饰的类是终极类，不能有子类。</li><li>接口及其实现的基础语法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>什么是抽象类、抽象方法？在使用过程中有什么注意事项？【难背】<br>定义时只定义了方法但没有定义具体实现的类称为抽象类，在Java中通过关键字abstract把一个类定义为抽象类。<br>每一个未被定义具体实现的方法也用关键字abstract修饰，这样的方法称为抽象方法，只有抽象类才有抽象方法。<br>在使用抽象类和抽象方法时要注意的事项有：不能用抽象类作为模板创建对象，必须定义抽象类的子类后，用子类作为模板才能创建实例。对于抽象方法不能进行调用，子类将抽象方法实现以后才可以调用。</li><li>接口中所有的方法都是抽象方法，没有方法体。</li><li>一个类可以实现多个接口，从而实现了多重继承。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, ..., 接口N &#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口可以定义自己的成员变量和方法，但成员变量必须赋初值且不可改变（系统会自动添加final和static关键字）。</li><li>实现接口必须实现该接口的所有方法。</li><li>接口可以继承。</li><li>简述抽象类与接口的联系与区别：【难背】<br>抽象类是指类中定义了方法但没有具体实现的类，抽象类代表一些基本行为，但又无法或不宜在这个类中对这些行为加以具体实现，而希望在子类中根据实际情况去实现。<br>接口是体现抽象类功能的另一种方式，可将其想象为一个“纯”的抽象类，接口中所有的方法都是抽象方法，都没有方法体，接口与抽象类都用来定义多个类的共同属性。<br>接口还可以实现与抽象类不同的功能，具体来说，Java不支持多重继承，一个类只能从唯一的一个类继承，但允许一个类实现多个接口，从而实现了多重继承的功能，并具有更加清晰的结构。</li><li>一个接口能够包含的元素有<i id="answer27_1" class="answer" onclick="showOrHide('27_1')">成员变量</i>，默认修饰符是<i id="answer27_2" class="answer" onclick="showOrHide('27_2')">abstract</i>；<i id="answer27_3" class="answer" onclick="showOrHide('27_3')">成员方法</i>，默认修饰符是<i id="answer27_4" class="answer" onclick="showOrHide('27_4')">static,final</i>。</li><li>子类中修改父类中已有的同名方法，称为方法<i id="answer28_1" class="answer" onclick="showOrHide('28_1')">覆盖/重写</i>。</li><li>同一个类中，具有不同签名的同名方法是<i id="answer29_1" class="answer" onclick="showOrHide('29_1')">重载</i>方法。</li><li>接口中的抽象方法不能是私有或受保护的方法。</li><li>Java中实现多重继承的机制是<i id="answer31_1" class="answer" onclick="showOrHide('31_1')">使用接口</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/12/04747-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（五）——面向对象方法RUP</title>
      <link>https://pearlchocolatezy.com/2025/06/11/02333-5/</link>
      <guid>https://pearlchocolatezy.com/2025/06/11/02333-5/</guid>
      <pubDate>Wed, 11 Jun 2025 08:59:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[面向对象方法RUL] --&gt; A1[RUP的特点]
    A --&gt; A2[核心工作流]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[面向对象方法RUL] --> A1[RUP的特点]    A --> A2[核心工作流]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><p>RUP：Rational Unified Process，统一软件开发过程</p><ol><li>面向对象符号体系。</li><li>三个突出特征：以<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">用况</i>为驱动、以<i id="answer1_2" class="answer" onclick="showOrHide('1_2')">体系结构</i>为中心的<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">迭代、增量式</i>开发。</li><li>RUP四个阶段：初始阶段 -&gt; 精化阶段 -&gt; 构造阶段 -&gt; 移交阶段。<br>精化阶段：估算成本进度，减少风险，至少要完成的阶段。<br>构造阶段：形成最终的系统体系结构基线，确保产品可以开始向客户交付，具有初始操作能力。<br>移交阶段：确保有一个实在的产品发布给客户。</li><li>一个核心工作流包括：需求获取、分析、设计、实现、测试。</li><li>RUP利用UML提供的术语和工具定义了<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">需求获取层</i>、<i id="answer5_2" class="answer" onclick="showOrHide('5_2')">系统分析层</i>、<i id="answer5_3" class="answer" onclick="showOrHide('5_3')">设计层</i>、<i id="answer5_4" class="answer" onclick="showOrHide('5_4')">实现层</i>，并给出了各层模型间的映射。</li><li>简述RUP设计模型以及包含的元素：【难背】<br>RUP的设计模型是RUP设计的主要结果，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入。（1分）<br>它包括以下元素：<br>（1）设计子系统和服务子系统，以及它们的依赖、接口和内容；（1分）<br>（2）设计类，以及它们具有的操作、属性、关系及其实现需求；（1分）<br>（3）用况细化；（1分）<br>（4）体系结构描述。（1分）</li><li>为什么UML要同RUP一起才称得上是软件开发的方法学？【难背】<br>（1）一种软件开发方法学，至少由三部分组成：用于表达基本信息的术语，用于组织基本信息的表达格式，用于在不同抽象层之间进行映射的过程指导。<br>（2）UML仅包含前两方面的内容，因此它只是一种可视化的建模语言，而不是一种特定的软件开发方法学。<br>（3）RUP给出的是一种基于UML的过程指导，满足软件开发方法学的第三项内容。<br>因此UML要同RUP一起才称得上是一种软件开发的方法学。</li><li>RUP的<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">部署模型</i>包含节点和主动类到节点的初始映射。</li><li>RUP从两个角度描述软件结构：系统设计模型，表达物理分布的<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">系统部署模型</i>。</li><li>简述建造一个系统需求获取模型的活动（RUP创建系统用况模型应进行的活动，0.5分/个），以及各活动的输入和输出：【难背】<br>（1）活动:发现描述参与者和用况。输入:业务模型或领域模型,补充需求,特征表。输出:用况模型[概述],术语表;(1分)<br>（2）活动:赋予用况优先级。输入:用况模型[概述],补充需求,术语表。输出:体系结构描述[用况模型视角];(1分)<br>（3）活动:精化用况。输入:用况模型[概述],补充需求,术语表。输出:用况[精化];(1分)<br>（4）活动:构造人机接口原型（用户界面原型）。输入:用况[精化],用况模型[概述],补充需求,术语表。输出:人机接口原理;(1分)<br>（5）活动:用况模型结构化。输入:用况[精化],用况模型[概述],补充需求,术语表。输出:用况模型[精化]。(1分)</li><li>RUP中创建系统的分析模型，一般应进行<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">体系结构</i>分析、<i id="answer11_2" class="answer" onclick="showOrHide('11_2')">用况</i>分析、<i id="answer11_3" class="answer" onclick="showOrHide('11_3')">类的</i>分析、<i id="answer11_4" class="answer" onclick="showOrHide('11_4')">包的</i>分析4项活动。</li><li>RUP中的分析类分为：<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">边界类</i>、<i id="answer12_2" class="answer" onclick="showOrHide('12_2')">实体类</i>、<i id="answer12_3" class="answer" onclick="showOrHide('12_3')">控制类</i>。</li><li>简述RUP需求获取的基本步骤：【难背】<br>（1）列出候选的特征、(1 分)<br>（2）理解系统语境、(1 分)<br>（3）捕获系统功能需求、(2 分)<br>（4）捕获非功能需求。 (1 分)</li><li>RUP采用<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">Use Case</i>技术来获取需求，其目标是使用UML中的<i id="answer14_2" class="answer" onclick="showOrHide('14_2')">用况</i>、参与者以及依赖等术语来抽象客观实际问题，形成系统的需求获取模型。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/11/02333-5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（五）——数组和字符串</title>
      <link>https://pearlchocolatezy.com/2025/06/10/04747-05/</link>
      <guid>https://pearlchocolatezy.com/2025/06/10/04747-05/</guid>
      <pubDate>Tue, 10 Jun 2025 12:44:04 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;5-1-数组&quot;&gt;&lt;a href=&quot;#5-1-数组&quot; class=&quot;headerlink&quot; title=&quot;5.1 数组&quot;&gt;&lt;/a&gt;5.1 数组&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数组是相同类型的元素按一定顺序排列的集合。&lt;/li&gt;
&lt;li&gt;数组声明时不用说明容量，声明时不分</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><ol><li>数组是相同类型的元素按一定顺序排列的集合。</li><li>数组声明时不用说明容量，声明时不分配内存。</li><li>声明数组的格式：<code>类型 数组名[];</code></li><li>数组初始化的两种方法：静态初始化，动态初始化。</li><li>初始化数组的格式：<br>静态初始化：<code>类型 数组名[]=&#123;值1,值2,...&#125;;</code><br>动态初始化：<code>类型 数组名[]=new 类型[数组大小];</code></li><li>简述声明数组和创建数组的区别：<br>（1）声明数组是指定义一个数组，定义的格式为：类型 数组名[]。声明数组时不会为数组分配内存，声明的数组名只是引用变量，用来指向一个数组，还不能访问数组的任何元素。<br>（2）创建数组是指对声明过的数组进行分配空间，对其进行初始化，给数组的元素赋初值，创建数组以后可以使用数组的元素。数组创建分为静态初始化和动态初始化两种。静态初始化使用一对大括号{ }将初值括起来，每个元素对应一个引用。动态初始化使用运算符new为数组分配空间。</li><li>访问数组元素时需注意哪些问题：<br>（1）数组必须已经初始化,具有内存空间。<br>（2）访问数组元素通过数组名加上下标,即数组 名[下标数字]的形式进行,下标数字是从0 开始。<br>（3）数组初始化后其大小是固定不变的,所以访 问数组元素时需注意下标数字的必须小于数组的 length属性的值,否则会抛出越界异常。</li></ol><h3 id="5-2-字符串"><a href="#5-2-字符串" class="headerlink" title="5.2 字符串"></a>5.2 字符串</h3><ol><li>“==”与equals()的区别：<br>运算符“==”判定两个字符串对象是否是同一实例，内存中的存储空间是否相同。<br>方法equals()判定两个字符串的值是否相等。</li><li>substring(3,5)表示从位置3开始，到位置5结束，不含位置5。</li><li>简述String类和StringBuffer类在对象分配内存时的区别：<br>String类分配内存时,按照对象中所含字符的实际个数等量分配。<br>StringBuffer类对象分配内存时,除去字符所占空间外,再另加16个字符大小的缓冲区。</li><li>StringBuffer类用于处理<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">可变字符串</i>。</li><li>用字符数组创建字符串语句：<code>String s=new String(chars);</code></li></ol><h3 id="5-3-Vector类"><a href="#5-3-Vector类" class="headerlink" title="5.3 Vector类"></a>5.3 Vector类</h3><ol><li>Vector类的实例可以保存不同类型的数据。</li><li>Vector类可认为是动态数组，空间大小可变。</li><li><code>Vector v=new Vector(100,50);</code>50表示在v初始化的空间用尽后以50为单位递增空间。</li><li>简述数组与Vector的显著区别：<br>（1）数组初始化(创建)后其容量大小固定不变,不能缩小或追加空间。而 Vector类实例的大小可以根据需要来改变。<br>（2）Vector保存的数据类型与数组也不一样,数组只能保存同一种数据,而 Vector实例可以保存不同类型的数据。<br>（3）数组元素的类型可以是基本数据类型,也可以是类对象,而 Vector类实例只能保存类的对象,不能保存基本类型的数据。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/10/04747-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（四）——面向对象程序设计</title>
      <link>https://pearlchocolatezy.com/2025/06/08/04747-04/</link>
      <guid>https://pearlchocolatezy.com/2025/06/08/04747-04/</guid>
      <pubDate>Sun, 08 Jun 2025 09:06:42 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;类中可以不显示定义构造方法。&lt;br&gt;（可以不手动写，编译器会自动生成一个无参的）&lt;/li&gt;
&lt;li&gt;可以创建不带参数的构造方法。&lt;/li&gt;
&lt;li&gt;构造方法不能从父类继承。&lt;/li&gt;
&lt;li&gt;构造方法有返回值。（可以是对象的实例自己，可以是void）&lt;/li&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>类中可以不显示定义构造方法。<br>（可以不手动写，编译器会自动生成一个无参的）</li><li>可以创建不带参数的构造方法。</li><li>构造方法不能从父类继承。</li><li>构造方法有返回值。（可以是对象的实例自己，可以是void）</li><li>构造方法的调用方式与普通方法不同。</li><li>方法签名包括：方法名，参数列表。</li><li>重载方法的返回值可以相同也可以不同。</li><li>重载方法返回值类型不可作为区分重载方法的依据。<br>原因：选择哪个重载方法是在执行方法之前进行的，此时还不知道返回值是什么，所以不能确定返回值的类型。</li><li>如果方法的形参是引用类型，调用方法时，实参传递的内容：<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">将实参的首地址传给形参</i>。从方法返回时，对实参的影响：<i id="answer9_2" class="answer" onclick="showOrHide('9_2')">对形参的修改也即修改了实参</i>。</li><li>静态方法不能直接引用实例变量。</li><li>被整个类共享的变量为<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">静态变量</i>。</li><li>不需要创建对象就可以调用的方法为<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">静态变量</i>。</li><li>int,char,void,byte的包装类分别为<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">Interger</i>，<i id="answer13_2" class="answer" onclick="showOrHide('13_2')">Character</i>，<i id="answer13_3" class="answer" onclick="showOrHide('13_3')">Void</i>，<i id="answer13_4" class="answer" onclick="showOrHide('13_4')">Byte</i>。</li><li>简述包装类的用途：<br>当想用处理对象一样的方式来处理基本类型的数据时，必须将基本类型值包装成一个对象。</li><li>包装类定义在<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">java.lang</i>包中。</li><li>自动将基本数据类型转换为对应的包装类的过程为<i id="answer16_1" class="answer" onclick="showOrHide('16_1')">装箱</i>。</li><li>自动将包装类的对象转换为基本类型的过程为<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">拆箱</i>。</li><li>类中定义的静态成员，用static修饰，只分配一次内存，不同实例的该成员共享一块内存。<br>（Java中没有全局变量的概念，所有变量都必须属于某个类。）</li><li>类中含有的两部分元素：数据成员变量，成员方法。</li><li>类的修饰词<br>private：只能被类内部访问。<br>protected：只能被类所在包访问。（默认）<br>public：公共的，可以被所有对象访问。</li><li>子类构造方法调用父类构造方法，调用语句必须写在子类构造方法的第一行。</li><li>Java程序中源文件名必须根据文件中的<i id="answer22_1" class="answer" onclick="showOrHide('22_1')">共有类名</i>来定义。</li><li>简述构造方法重载：<br>在进行对象实例化时可能遇到许多不同情况，要求针对给定的不同参数，调用不同的构造方法，此时可以通过在一个类中同时定义若干个构造方法来实现。</li><li>简述类的概念：<br>现实世界中存在很多同类的对象，它们来自同一种原型或模板，或具有一些共性，可抽象提取为类。</li><li><i id="answer25_1" class="answer" onclick="showOrHide('25_1')">new</i>运算符可自动调用构造方法。</li><li>调用方法时传给方法的值称为<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">实参</i>。</li><li>Java中实例变量与静态变量的区别是什么？<br>Java运行中系统生成类的每个实例对象时,会为每个对象的实例变量分配内存,然后才可以访问实例变量,而且不同对象的内存空间相互独立。<br>静态变量是不依赖于特定对象,系统只在类定义时为静态成员分配内存,此时还没有创建对象,也没有对对象进行实例化。以后生成该类的实例对象时,将不再为静态成员分配内存,不同对象的静态变量将共享同一块内存空间。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/08/04747-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（四）——面向对象方法UML</title>
      <link>https://pearlchocolatezy.com/2025/06/05/02333-4/</link>
      <guid>https://pearlchocolatezy.com/2025/06/05/02333-4/</guid>
      <pubDate>Thu, 05 Jun 2025 09:50:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[面向对象方法UML] --&gt; A1[UML术语表]
    A --&gt; A2[UML的模型表达格式]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mer</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[面向对象方法UML] --> A1[UML术语表]    A --> A2[UML的模型表达格式]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><h3 id="4-1-UML术语表"><a href="#4-1-UML术语表" class="headerlink" title="4.1 UML术语表"></a>4.1 UML术语表</h3><ol><li>UML表达关系的术语中，包含是一种特殊的<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">依赖</i>。</li><li><i id="answer2_1" class="answer" onclick="showOrHide('2_1')">UML</i>是面向对象技术发展中一个重要的里程碑。</li><li>关联的多重性是指类中对象参与一个关联的数目。</li><li>术语<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">依赖</i>可用于表达客观世界中各种各样事物之间的关系。</li><li>UML术语表：<br><code>+</code>：公共可见的（public）<br><code>-</code>：对该关联之外的任何对象而言，该端的对象是不可见的<br><code>#</code>：该端的对象只有另一端的“子孙”是可以访问的（protected）<br><code>~</code>：在同一包中声明的类是可访问的</li><li>接口使用注意以下问题：（选择）<br>（1）接口只可以被其他类目使用，而其本身不能访问其他类目。<br>（2）接口描述类的外部可见操作，通常是该类的一个特定有限行为。<br>（3）接口不描述其中操作的实现，也没有属性和状态。<br>（4）接口之间没有关联、泛化、实现和依赖，但可以参与泛化、实现和依赖。</li><li>为了描述模型化包之间的关系，UML给出了<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">引入</i>依赖和<i id="answer7_2" class="answer" onclick="showOrHide('7_2')">访问</i>依赖。</li><li>UML关系术语：<br><font color="midnightblue">关联：表示类与类之间的联系。方向箭头实线表示。<br>泛化：表示一般与特殊的关系。用带空心三角箭头的直线表示。<br>细化：一个类目规约了保证另一个类目执行的契约。<br>依赖：表示一个类使用另一个类的对象。用带箭头的虚线表示。<br>聚合：表示整体与部分的关系，部分可独立存在。用带空心菱形的直线表示。<br>组合：表示整体与部分的关系，部分对象与整体对象有相同的生命周期。用带实心菱形的直线表示。<br>实现：表示类与接口的关系。用带箭头的虚线表示。</font><br><strong>关联、泛化、细化都是一类特定的依赖。</strong></li><li>在类的关联中，对于一个给定的类目，可以通过<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">导航</i>。</li><li>用于描述关联的一定内涵的术语是<i id="answer10_1" class="answer" onclick="showOrHide('10_1')">关联名</i>。</li><li>关联的一端的类目对另一端的类目的一种呈现，称为<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">角色</i>。</li><li>泛化的四个约束：<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">完整</i>、<i id="answer12_2" class="answer" onclick="showOrHide('12_2')">不完整</i>、<i id="answer12_3" class="answer" onclick="showOrHide('12_3')">互斥</i>、<i id="answer12_4" class="answer" onclick="showOrHide('12_4')">重叠</i>。</li><li>类是一组具有相同<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">属性</i>、<i id="answer13_2" class="answer" onclick="showOrHide('13_2')">操作</i>、<i id="answer13_3" class="answer" onclick="showOrHide('13_3')">关系</i>、<i id="answer13_4" class="answer" onclick="showOrHide('13_4')">语义</i>。</li><li>类的泛化关系中，如果一个类有多个父类，则说明它使用了<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">语义</i>。</li><li>UML中，实线椭圆表示<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">用况</i>。</li><li>一种软件开发方法学至少由三部分组成：<br>（1）用于表达基本信息的术语<br>（2）用于组织基本信息的表达格式<br>（3）不同抽象层之间进行映射的过程指导</li><li>类中对象参与一个关联的数目，称为该关联的<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">多重性</i>。</li><li>协作是一个交互，涉及交互<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">各方</i>、交互<i id="answer18_2" class="answer" onclick="showOrHide('18_2')">方式</i>、交互<i id="answer18_3" class="answer" onclick="showOrHide('18_3')">内容</i>三要素。</li><li>节点具有<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">记忆</i>能力和<i id="answer19_2" class="answer" onclick="showOrHide('19_2')">处理</i>能力。</li><li>UML表达客观事物之间关系的术语及定义 <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）为了表达各类客观事物之间的关系，UML给出了表达关系的基本术语：关联、泛化、细化、依赖；（1分）<br>（2）关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。（1分）泛化是一般性类目和它的较为特殊性类目之间的一种关系。（1分）细化是类目之间的语义关系，其中一个类目规约了保证另一个类目执行的契约。（1分）依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。（1分）</li></ol><h3 id="4-2-UML的模型表达格式"><a href="#4-2-UML的模型表达格式" class="headerlink" title="4.2 UML的模型表达格式"></a>4.2 UML的模型表达格式</h3><ol><li>用况图（USE CASE图）：可以表达系统功能模型的图形化工具（背）；可用于概念模型和软件模型的动态结构。</li><li>类图：可用于描述概念模型和软件模型的静态结构。</li><li>状态图：从一个状态到另一个状态的控制流建模工具；支持生存周期的建模。</li><li>交互图：支持系统交互的建模。</li><li>UML两类图形化工具：结构图，行为图。</li><li>创建一个系统类图的步骤：（选择）<br>（1）模型化待建系统中的概念，形成类图中的基本元素；<br>（2）模型化待建系统中的各种关系，形成该系统的初始类图；<br>（3）模型化系统中的协作，给出该类图的最终类图；<br>（4）模型化逻辑数据库模式。</li><li>用况图的六个模型元素：主题、用况、参与者、关联、泛化、依赖。（背）<br>用况图模型元素之间的关系：用况图中，关联是操作者和用况之间的唯一关系。操作者之间的关系可以是泛化。用况之间可以有泛化、扩展和包含，其中包含和扩展是依赖的变体。（背）</li><li>UML中的事件类型：信号事件，调用事件，时间事件，变化事件。（背）<br>UML中的事件通常分为：内部事件，外部事件。</li><li>用况之间的关系：扩展，包含，泛化。</li><li>类图包含：类，接口，关联，泛化，依赖等关系。</li><li>简述状态图中的一个转换涉及的内容：<br>（1）源状态：发生状态转移的那个状态。<br>（2）转移触发器：满足其监护条件，则使状态发生转移。<br>（3）监护条件：布尔表达式，表达式为真，则触发转移；表达式为假，则不发生转移。<br>（4）效应：一种可执行的行为。<br>（5）目标状态：转移完成后所处的状态。</li><li>状态图的状态：初态，终态，通常状态。</li><li>简述创建系统类图所涉及的工作：<br>（1）创建一个系统的类图依赖于所使用的方法学；（1分）<br>（2）涉及以下4方面的工作：<br>模型化待建系统中的概念，形成类图中的基本元素；（1分）<br>模型化待建系统中的各种关系，形成该系统的初始类图；（1分）<br>模型化系统中的协作，给出该系统的最终类图：（1分）<br>模型化逻辑数据库模式。（1分）</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/05/02333-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（三）——流程控制语句</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-03/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-03/</guid>
      <pubDate>Mon, 02 Jun 2025 06:53:08 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;简述Java中异常的分类及其概念：&lt;br&gt;Java中异常可分为三类,分别为：受检异常、运行时异常、错误。&lt;br&gt;受检异常是程序执行期间发生的严重事件的后果。&lt;br&gt;运行时异常通常是程序中逻辑错误的结果。&lt;br&gt;错误是指发生了不正确的情况,这些情况都比较严重,一般</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>简述Java中异常的分类及其概念：<br>Java中异常可分为三类,分别为：受检异常、运行时异常、错误。<br>受检异常是程序执行期间发生的严重事件的后果。<br>运行时异常通常是程序中逻辑错误的结果。<br>错误是指发生了不正确的情况,这些情况都比较严重,一般程序很难处理。</li><li>如果程序中有package语句，那么该语句一定是源文件中的<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">第一条非注释语句</i>。</li><li>Java中，通常用<i id="answer3_1" class="answer" onclick="showOrHide('3_1')"> classpath （环境变量）</i>指定搜寻包的路径。</li><li>简述package语句和import语句的区别：<br>(1)package语句为包语句,每个文件最多只有一个,且必须放在文件开始的地方(2分)。<br>(2)import语句为引入语句,可以没有,也可以有多个,如果有,必须放在所有类定义的前面(2分)</li><li>Java规定switch语句不允许使用浮点型或long型,表达式的结果必须是int型或char型,当用byte型或short型时,要进行提升。</li><li>Java中有哪几种流程控制语句：赋值语句、分支语句、循环语句、跳转语句。</li><li>continue语句的作用是<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">立即结束本次循环</i>。</li><li>while语句和do语句的区别：<br>while语句先计算条件表达式的值,当值为真时,重复执行循环体语句,直到条件表达式为假时结束。如果第一次检查时条件表达式为假,则循环体语句一次也不执行。<br>do语句首先执行循环体语句,然后判定条件表达式的值,当值为真时,重复执行循环体语句,直到表达式的值为假时结束循环。不论条件表达式的值是真是假,do循环中的循环体都至少执行一次。</li><li>分支语句有：if，switch。</li><li>简述break语句的基本用法：<br>break语句可用于3类语句中：<br>第一类是在 switch语句中,第二类是在for、while及do等循环体中,第三类是在语句块中。<br>在switch语句及循环体语句中, break的语义是跳过本块中余下的所有语句, 转到块尾, 执行其后的语句。第三种使用方法是在块中和标号配合使用,其语义是跳出标号所标记的语句块,继续执行后面的语句。这种形式的break语句多用于嵌套块中,控制从内层跳到外层块之后。</li><li>Java语言中对异常进行处理时，不论是否捕获到异常，对于finally后面的语句都要执行。</li><li>Scanner类提供的许多方法，可用来方便地<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">读入不同类型的输入值</i>。</li><li>一般地，如果一个方法引发了一个异常，而它自己又不处理，就要由<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">throw抛出交给调用者处理</i>。</li><li>Java把程序运行过程中遇到的非致命的、通过某种修正后程序还能继续执行的错误称为<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">异常</i>。</li><li>简述程序员处理异常的方法：<br>Java语言中,程序员处理异常的方法有两种,一种是使用try块和 catch块,捕获到所发生的异常类,并进行相应的处理。<br>另一种方法是,程序员不在当前方法内处理异常,而是把异常抛出到调用方法中。当不能使用合理的方式来解决不正常或意外事件的情形下,才抛出异常。</li><li>说明嵌套的if语句中，if与else的个数应满足的条件及else语句的对应规则：<br>if的个数不少于else的个数。else与离它最近的未匹配的if语句对应。</li><li>简述try-catch块的处理过程：<br>（1）如果try块内没有发生异常，则try块内的语句全部执行，然后执行catch块后的语句。<br>（2）如果在try块内发生了某类异常，则执行立即转到对应的catch块，执行其中的语句去处理异常。<br>（3）不论是否捕获到异常，总要执行finally后面的语句。 </li><li>Java类库中的每个异常都有一个存取方法，可返回抛出异常时创建的描述字符串，该方法的名字是<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">getMessage()</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（二）——数据和表达式</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-02/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-02/</guid>
      <pubDate>Mon, 02 Jun 2025 06:52:59 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;包的命名要求：层次关系以点分割；通常用小写字母。&lt;/li&gt;
&lt;li&gt;Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）&lt;/li&gt;
&lt;li&gt;关键字的作用：&lt;br&gt;f</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>包的命名要求：层次关系以点分割；通常用小写字母。</li><li>Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）</li><li>关键字的作用：<br>final：用于声明常量变量。<br>static：用于声明静态变量或方法，表明该成员属于类本身不属于实例；不能用于声明常量变量，但<code>static final</code>结合使用可以定义常量变量。<br>protected：一种访问修饰符，用于控制类成员的访问权限，允许同一个包内或通过继承的子类访问该成员。<br>super：用于引用父类的成员。<br>class：用于定义类。<br>long：用于声明长整型变量。<br>new：用于创建新对象。</li><li>Java中的保留关键字：<br> 基本类型关键字<pre><code> byte short int long float double boolean char</code></pre> 控制语句关键字<pre><code> if else switch case default while do for break continue return</code></pre> 类、对象和接口定义关键字<pre><code> class interface extends implements this super new instanceof</code></pre> 包和导入关键字<pre><code> package import</code></pre> 访问控制关键字<pre><code> public protected private</code></pre> 异常处理关键字<pre><code> try catch finally throw throws</code></pre> 其他关键字<pre><code> static final abstract synchronized volatile transient native strictfp assert</code></pre> <a href="https://blog.csdn.net/weixin_48958956/article/details/140869156">Java关键字简介</a></li><li>简述包的概念及其命名要求：<br>（1）概念：包是类的容器,包的设计人员利用包来划分名字空间,以避免类名冲突。<br>（2）命名要求：包的名字有层次关系,各层之间以点分隔。包层次必须与Java开发系统的文件系统结构相同。通常包名中全部用小写字母。</li><li>Java程序的结构可以包含哪些内容：<br>一个Java程序的结构可以包含以下5方面的内容:<br>（1）package语句:包语句,每个文件最多只有一个,且必须放在文件开始的地方。<br>（2）import语句:引入语句,可以没有,也可以有多个,如果有 import语句,必须放在所有类定义的前面。<br>（3）具有 public权限的类定义:每个文件中最多有一个。<br>（4）类定义:每个文件中包含的非 public权限的类定义的个数没有限制。<br>（5）接口定义:每个文件中包含的接口定义个数没有限制。</li><li>变量取值范围<br>byte：-128~127<br>int：-2,147,483,648到2,147,483,647（$-2^(31)$~$2^(31)-1$）<br>long：-9,223,372,036,854,775,808（$-2^(63)$）到9,223,372,036,854,775,807（$2^(63)-1$）（‌字面量表示‌：若数值超出int范围（如大于2147483647），需在末尾添加L或l后缀（推荐大写L以避免与数字1混淆），例：long a=9876543210编译错误）</li><li>变量占用内存<br>byte：8位<br>short：16位<br>int：32位<br>long：64位</li><li>运算符优先级：括号 &gt; 基本运算 &gt; 移位 &gt; 大小对比 &gt; 逻辑&amp;&amp; &gt; 逻辑|| &gt; 三元运算</li><li><code>&gt;&gt;</code>是算术右移操作符，用于将二进制值向右移动指定位数，同时保留符号位。<br>例：求解<code>85&gt;&gt;1</code>：85转为二进制为（短除法）01010101，右移一位为00101010，再转为十进制（乘法）为42。<br>简单计算：右移一位相当于除以2，且向下取整。</li><li>表达式由<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">运算符</i>和<i id="answer11_2" class="answer" onclick="showOrHide('11_2')">操作数</i>组成。</li><li>Java可以声明变量的地方及其区别：<br>声明变量的地方有两处,一处是在方法内,另一处是在类定义内。方法内定义的变量称为自动变量,也称为局部变量、临时变量或栈变量。类中定义的变量就是类的成员变量。</li><li><i id="answer13_1" class="answer" onclick="showOrHide('13_1')">null</i>表示引用不指向任何对象。</li><li>Java中数据类型转换的分类及其适用情况：<br>Java中的数据类型转换分为自动转换和强制转换两类。转换的一般原则是位数少的类型转换为位数多的类型,这称为自动类型转换。当位数多的类型向位数少的类型进行转换时,需要在程序中明确指明,这种转换称为强制类型转换。</li><li>基本数据类型什么时候有自己的内存空间：<br>基本数据类型的变量在声明之后,系统会自动在内存中分配相应的存储空间,即声明后即有自己的内存空间。</li><li>简述二元逻辑论中“短路”操作功能：<br>进行二元逻辑运算时,先计算运算符左侧表达式的值(2分)<br>如果使用该值能得到整个表达式的值,则跳过运算符右侧表达式的计算(1分),<br>否则计算运算符右侧表达式,并得到整个表达式的值(1分)。</li><li>Java中的基本数据类型byte、char、float、long和short在参与表达式计算时，能够进行自动类型变换的类型顺序依次是什么：依次是byte、short、char、long、float。</li><li><code>&amp;</code>按位与运算的结果是按位“皆1则1”。</li><li>Java逻辑与和逻辑或运算符有一个特殊的功能，当左侧操作数能决定表达式的值时，则跳过右侧操作数的运算。这个功能是<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">短路操作</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-02/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
