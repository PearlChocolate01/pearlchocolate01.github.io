<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Mon, 30 Jun 2025 16:00:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>04747-Java（十）——多线程</title>
      <link>https://pearlchocolatezy.com/2025/06/29/04747-10/</link>
      <guid>https://pearlchocolatezy.com/2025/06/29/04747-10/</guid>
      <pubDate>Sun, 29 Jun 2025 08:24:40 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;进程是程序的一次执行（进程本身不是程序），对应了代码加载、执行至执行完毕的一个完整过程，或者说是程序在处理机中的一次运行。&lt;/li&gt;
&lt;li&gt;进程既包括其所要执行的命令，又包括执行指令所需的任何系统资源，如CPU、内存空间、I/O端口等。&lt;/li&gt;
&lt;li&gt;Ja</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>进程是程序的一次执行（进程本身不是程序），对应了代码加载、执行至执行完毕的一个完整过程，或者说是程序在处理机中的一次运行。</li><li>进程既包括其所要执行的命令，又包括执行指令所需的任何系统资源，如CPU、内存空间、I/O端口等。</li><li>Java中线程的状态共有4种，分别为:新建、可运行状态、死亡、阻塞。</li><li>Java对被阻塞的线程是如何处理的？【背】<br>在Java中，所有被阻塞的线程按次序排列，组成一个阻塞队伍。而所有就绪但没有运行的线程则根据其优先级进入一个就绪队列，当CPU空闲时，如果就绪队列不空，队列中第一个具有最高优先级的线程将运行。当一个线程被抢占而停止运行时，它的运行状态被改变并放到就绪队伍的队尾；同样，一个被阻塞的线程就绪后通常也放到就绪队列的队尾。</li><li>线程：线程是进程执行过程中产生的多条执行线索，是比进程单位更小的执行单位，线程在形式上同进程十分相似，都是用一个按序执行的语句序列来完成特定的功能，不同的是，线程没有入口，也没有出口，自身不能自动运行，必须栖身于某一个进程中，由进程触发执行，并且属于同一进程的线程共享该进程的系统资源。【背】</li><li>要让某个子类对象实现多线程：声明实现Runnable接口,在类内实现run()方法,声明和创建线程对象,并让该对象调用start()方法。</li><li>线程的结构都包含哪些部分，作用分别是什么？【背】<br>在Java中,线程由虚拟CPU、执行的代码、处理的数据三部分组成。<br>虚拟CPU的作用是控制整个线程的运行,<br>执行的代码的作用是由Thread类控制按序运行,<br>处理的数据的作用是传递给 Thread类,由代码在执行过程中进行处理。</li><li>用 Thread类的子类创建线程的过程是什么？【背】<br>(1)从Thread类派生出一个子类,在类中一定要实现run()<br>(2)用派生出的子类创建一个对象。<br>(3)用start()方法启动线程。</li><li>请说明创建线程两种方法的适用条件：【背】<br>（1）适用于采用实现 Runnable接口的情况:因为Java只允许单重继承,如果一个类已经继承了 Thread,就不能再继承其他类,这就被迫采用实现 Runnable的方法。另外,由于原来的线程采用的是实现 Runnable接口的方法,可能会出于保持程序风格的一贯性而继续使用这种方法。<br>（2）适用于采用继承 Thread方法的情况:当一个run()方法置于 Thread类的子类中时,this实际上引用的是控制当前运行系统的 Thread实例,部分代码比较简洁,所以许多Java程序员愿意使用继承 Thread的方法。</li><li>使用 synchronized 修饰一个方法时，整个方法会被同步。这意味着同一时间只有一个线程可以访问这个方法。</li><li>请写出用Thread类的子类创建线程并启动线程所包含的步骤：<br>(1)从Thread类派生出一个子类。(1分)<br>(2)实现run()。(1分)<br>(3)用该类创建一个对象。(1分)<br>(4)用start()方法启动线程。(1分)</li><li>notify()/notifyAll()可以将等待队列中线程唤醒。</li><li>sleep()/wait()/join()可以将线程挂起。</li><li>yield()强制终止线程的执行。</li><li>同优先级的线程按“先进先出”调度原则。</li><li>线程优先级的高低可能影响线程执行的先后顺序,但不是阻塞的原因。</li><li>Java对线程的调度采取优先级策略。</li><li>Java中断线程执行的方法：interrupt</li><li>运行状态的线程执行stop方法后进入死亡状态。</li><li>编译器在编译阶段无法检测到死锁。</li><li>synchronized修饰操作共享数据的一个变量或一个方法。</li><li>Java中如何实现“对象互斥锁”？【背】<br>Java语言中,有两种方法可以实现“对象互斥锁”,一是用关键字volatile来声明一个共享数据(变量),二是用关键字 synchronized来声明操作共享数据的一个方法或一段代码。</li><li>请写出在Java语言中，关键字synchronized的作用：【背】<br>（1）使用关键字synchronized定义临界段(1分),<br>（2）能对共享对象的操作上锁(2分)</li><li>wait可以释放当前当前线程持有的对象互斥锁。</li><li>线程的四种状态：新建，可运行状态，死亡，阻塞。</li><li>wait和sleep常引起阻塞。</li><li>调用start可使线程出于可运行。</li><li>线程优先级：级别最低是1，默认级别是5，最高级别是10。</li><li>sleep和yield可以给同等优先级的其他线程一个运行的机会。</li><li>Thread的静态方法currentThread可以引用正在运行的线程。</li><li>Thread类的setPriority可以设置线程优先级。</li><li>Thread中代表最高优先级的常量：MAX_PRIORITY</li><li>synchronized可以阻止多个线程同时访问同一个条件变量。</li><li>用关键字synchronized标识的代码段或方法即为“对象互斥锁”锁住的部分。</li><li>synchronized语句的参数必须是this。</li><li>当持有锁定标志的线程运行完synchronized()调用包含的程序块后，这个标志将会被：自动返还。</li><li>什么时候需要考虑线程的互斥问题？【背】<br>当同时运行的线程需要共享数据时需要考虑线程的互斥问题。</li><li>在调用一个对象的wait方法时，必须持有该对象的：锁定标识。</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/29/04747-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（八）——集成化能力成熟度模型(CMMI)</title>
      <link>https://pearlchocolatezy.com/2025/06/29/02333-8/</link>
      <guid>https://pearlchocolatezy.com/2025/06/29/02333-8/</guid>
      <pubDate>Sun, 29 Jun 2025 07:35:55 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;CMMI是一个有关产品和服务的过程改善的成熟度模型，集成了三个源模型：软件CMM、系统工程CMM、集成产品开发CMM（或产品集成开发CMM）。&lt;/li&gt;
&lt;li&gt;CMMI模型基于过程途径思想，通过过程把软件质量三个支撑点进行集成，以开发所期望的系统产品。三个支撑</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>CMMI是一个有关产品和服务的过程改善的成熟度模型，集成了三个源模型：软件CMM、系统工程CMM、集成产品开发CMM（或产品集成开发CMM）。</li><li>CMMI模型基于过程途径思想，通过过程把软件质量三个支撑点进行集成，以开发所期望的系统产品。三个支撑点是：受训的人员、规程和方法、工具和设备。</li><li>共用目标用于确定一个过程域是否得以满足。</li><li>共用目标在每个过程域中都有多个，而专用目标可以有一个或多个。</li><li>CMMI分五个成熟度等级，每一个等级都是进行下一个等级的基础：【背】<br>（1）初始级<br>（2）已管理级<br>（3）已定义级<br>（4）量化管理级<br>（5）优化管理级</li><li>CMMI针对每个过程域设定了6个能力等级：【背】<br>0级——未完成级<br>1级——已执行级<br>2级——已管理级<br>3级——已定义级<br>4级——已定量管理级<br>5级——持续优化级</li><li>符号表示：<br>圆角矩形：过程域，专用目标和共用目标<br>椭圆：共用实践的精化，工作产品，子实践<br>菱形：专用和共用实践</li><li>可以帮助确定一个过程域（的独有特征）是否得到满足的是：专用目标。</li><li>典型工作产品是专用实践产生的：输出样品。</li><li>在单一过程域中已达到的过程改善称为：能力等级。</li><li>达到预先定义的一组过程域所有目标的一种过程改善等级称为：成熟度等级。</li><li>CMMI模型提供了两种过程改善路径：一是称为能力等级的过程改善路径，二是称为成熟度等级的过程改善路径。其意在改进组织的“整体性能”。</li><li>CMMI的两种等级可用于：评定活动和估算。</li><li>简述能力等级和成熟度等级之间的区别和联系：【背】<br>（1）区别：<br>能力等级是一种过程改善路径，该路径可使组织针对单一过程域不断改善该过程域。（1分）<br>成熟度等级也是一种过程改善路径，该路径可使组织通过关注一组过程域不断改善一组相关的过程域；（1分）<br>（2）联系：<br>能力等级和成熟度等级都是CMMI提供的两种过程改善路径，侧重不同：它们都是按共用目标从弱到强。（1分）<br>当某一过程域逐步完成了所有等级的“最佳实践”，它才可能满足成熟度等级对单一过程域的要求。（1分）<br>当一组过程域及相关共用目标的一个成熟度等级完成后，软件过程才能实现高一级别的“成熟”，从而实现对软件过程有效管理的“最佳实践”。（1分）</li><li>裁剪过程的意图：围绕一个组织，影响一个项目，反映一个组织。</li><li>CMMI中有22个过程域，分为4类：项目管理类，工程类，过程管理类，支持类。</li><li>需求开发、确认、验证过程域可归类为：工程类。</li><li>项目规划的一个重要任务：对需要的规划参数进行估算。</li><li>过程域：是一个业务中一束相关的实践,当它们一起得以实现时,就满足被认为对该过程域的改善具有重要作用的一组条件。【背】</li><li>项目规划的内容/活动：【背】<br>(1)估算工作产品和任务。<br>(2)确定需要的资源。<br>(3)协商承诺。<br>(4)生成进度。<br>(5)标识并分析项目风险。</li><li>需求开发过程域的意图：分析客户需求、产品需求、产品部件需求。【背】</li><li>项目规划过程域的意图：建立并维护项目活动计划的定义，项目计划提供了执行和控制项目活动的基础。【背】</li><li>项目规划过程域的专用目标：估算项目规模、开发项目计划、获得对该计划的承诺。【背】</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/29/02333-8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程 考试大纲复习手册</title>
      <link>https://pearlchocolatezy.com/2025/06/29/02333-syllabus/</link>
      <guid>https://pearlchocolatezy.com/2025/06/29/02333-syllabus/</guid>
      <pubDate>Sun, 29 Jun 2025 04:17:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;题型：单项选择题、名词解释题、简答题、综合应用题等。&lt;/p&gt;
&lt;h2 id=&quot;第一章-概述&quot;&gt;&lt;a href=&quot;#第一章-概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 概述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;mediumblue&quot;&gt;第一章 概述&lt;/f</description>
        
      
      
      
      <content:encoded><![CDATA[<p>题型：单项选择题、名词解释题、简答题、综合应用题等。</p><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a><font color="mediumblue">第一章 概述</font></h2><mark class="hl-label pink">【重点】软件工程的定义、特点、基本原理。</mark> <h3 id="1-1-软件工程的定义、特点、基本原理"><a href="#1-1-软件工程的定义、特点、基本原理" class="headerlink" title="1.1 软件工程的定义、特点、基本原理"></a>1.1 软件工程的定义、特点、基本原理</h3><h3 id="1-2-软件危机的定义和原因"><a href="#1-2-软件危机的定义和原因" class="headerlink" title="1.2 软件危机的定义和原因"></a>1.2 软件危机的定义和原因</h3><h3 id="1-3-软件工程的生命周期"><a href="#1-3-软件工程的生命周期" class="headerlink" title="1.3 软件工程的生命周期"></a>1.3 软件工程的生命周期</h3><h3 id="1-4-软件开发过程模型"><a href="#1-4-软件开发过程模型" class="headerlink" title="1.4 软件开发过程模型"></a>1.4 软件开发过程模型</h3><h2 id="第二章-分析阶段"><a href="#第二章-分析阶段" class="headerlink" title="第二章 分析阶段"></a><font color="mediumblue">第二章 分析阶段</font></h2><mark class="hl-label pink">【重点】问题定义；可行性研究的任务、内容和步骤；DFD图的画法。</mark> <h3 id="2-1-可行性研究-amp-规格说明书"><a href="#2-1-可行性研究-amp-规格说明书" class="headerlink" title="2.1 可行性研究 &amp; 规格说明书"></a>2.1 可行性研究 &amp; 规格说明书</h3><h3 id="2-2-问题定义"><a href="#2-2-问题定义" class="headerlink" title="2.2 问题定义"></a>2.2 问题定义</h3><h3 id="2-3-系统流程图"><a href="#2-3-系统流程图" class="headerlink" title="2.3 系统流程图"></a>2.3 系统流程图</h3><h3 id="2-4-需求分析-amp-需求评审"><a href="#2-4-需求分析-amp-需求评审" class="headerlink" title="2.4 需求分析 &amp; 需求评审"></a>2.4 需求分析 &amp; 需求评审</h3><h2 id="第三章-总体设计"><a href="#第三章-总体设计" class="headerlink" title="第三章 总体设计"></a><font color="mediumblue">第三章 总体设计</font></h2><mark class="hl-label pink">【重点】模块设计准则、设计方法；结构设计方法；数据流设计方法；MVC框架。</mark> <h3 id="3-1-总体设计"><a href="#3-1-总体设计" class="headerlink" title="3.1 总体设计"></a>3.1 总体设计</h3><h3 id="3-2-设计方法"><a href="#3-2-设计方法" class="headerlink" title="3.2 设计方法"></a>3.2 设计方法</h3><h3 id="3-3-MVC框架"><a href="#3-3-MVC框架" class="headerlink" title="3.3 MVC框架"></a>3.3 MVC框架</h3><h2 id="第四章-详细设计"><a href="#第四章-详细设计" class="headerlink" title="第四章 详细设计"></a><font color="mediumblue">第四章 详细设计</font></h2><mark class="hl-label pink">【重点】问题定义；详细设计的方法和工具；用户界面设计原则。</mark> <h3 id="4-1-详细设计"><a href="#4-1-详细设计" class="headerlink" title="4.1 详细设计"></a>4.1 详细设计</h3><h3 id="4-2-Jackson程序设计方法-amp-Warnier程序设计方法"><a href="#4-2-Jackson程序设计方法-amp-Warnier程序设计方法" class="headerlink" title="4.2 Jackson程序设计方法 &amp; Warnier程序设计方法"></a>4.2 Jackson程序设计方法 &amp; Warnier程序设计方法</h3><h3 id="4-3-用户界面"><a href="#4-3-用户界面" class="headerlink" title="4.3 用户界面"></a>4.3 用户界面</h3><h2 id="第五章-编码及测试"><a href="#第五章-编码及测试" class="headerlink" title="第五章 编码及测试"></a><font color="mediumblue">第五章 编码及测试</font></h2><mark class="hl-label pink">【重点】程序设计风格；代码行度量法；黑盒测试、白盒测试；测试用例设计；自动测试。</mark> <h3 id="5-1-程序设计语言"><a href="#5-1-程序设计语言" class="headerlink" title="5.1 程序设计语言"></a>5.1 程序设计语言</h3><h3 id="5-2-程序文档化"><a href="#5-2-程序文档化" class="headerlink" title="5.2 程序文档化"></a>5.2 程序文档化</h3><h3 id="5-3-程序表达式"><a href="#5-3-程序表达式" class="headerlink" title="5.3 程序表达式"></a>5.3 程序表达式</h3><h3 id="5-4-代码效率"><a href="#5-4-代码效率" class="headerlink" title="5.4 代码效率"></a>5.4 代码效率</h3><h3 id="5-5-软件测试"><a href="#5-5-软件测试" class="headerlink" title="5.5 软件测试"></a>5.5 软件测试</h3><h2 id="第六章-软件维护及软件再工程"><a href="#第六章-软件维护及软件再工程" class="headerlink" title="第六章 软件维护及软件再工程"></a><font color="mediumblue">第六章 软件维护及软件再工程</font></h2><mark class="hl-label pink">【重点】软件可维护度量方法；软件再工程方法。</mark> <h3 id="6-1-软件维护"><a href="#6-1-软件维护" class="headerlink" title="6.1 软件维护"></a>6.1 软件维护</h3><h3 id="6-2-软件的逆向工程和再工程"><a href="#6-2-软件的逆向工程和再工程" class="headerlink" title="6.2 软件的逆向工程和再工程"></a>6.2 软件的逆向工程和再工程</h3><h2 id="第七章-面向对象方法学"><a href="#第七章-面向对象方法学" class="headerlink" title="第七章 面向对象方法学"></a><font color="mediumblue">第七章 面向对象方法学</font></h2><mark class="hl-label pink">【重点】面向对象方法；对象模型；动态模型；功能模型。</mark> <h3 id="7-1-面向对象方法学"><a href="#7-1-面向对象方法学" class="headerlink" title="7.1 面向对象方法学"></a>7.1 面向对象方法学</h3><h3 id="7-2-面向对象建模方法"><a href="#7-2-面向对象建模方法" class="headerlink" title="7.2 面向对象建模方法"></a>7.2 面向对象建模方法</h3><h3 id="7-3-三个模型"><a href="#7-3-三个模型" class="headerlink" title="7.3 三个模型"></a>7.3 三个模型</h3><h2 id="第八章-面向对象分析"><a href="#第八章-面向对象分析" class="headerlink" title="第八章 面向对象分析"></a><font color="mediumblue">第八章 面向对象分析</font></h2><mark class="hl-label pink">【重点】面向对象分析的基本过程和三种模型的建立</mark> <h3 id="8-1-面向对象的3个子模型和5个层次"><a href="#8-1-面向对象的3个子模型和5个层次" class="headerlink" title="8.1 面向对象的3个子模型和5个层次"></a>8.1 面向对象的3个子模型和5个层次</h3><h3 id="8-2-类与对象、事件跟踪"><a href="#8-2-类与对象、事件跟踪" class="headerlink" title="8.2 类与对象、事件跟踪"></a>8.2 类与对象、事件跟踪</h3><h3 id="8-3-建立三种模型"><a href="#8-3-建立三种模型" class="headerlink" title="8.3 建立三种模型"></a>8.3 建立三种模型</h3><h2 id="第九章-面向对象设计"><a href="#第九章-面向对象设计" class="headerlink" title="第九章 面向对象设计"></a><font color="mediumblue">第九章 面向对象设计</font></h2><mark class="hl-label pink">【重点】面向对象的准则和启发规则；设计子系统；设计类中的服务；设计关联；设计模式。</mark> <h3 id="9-1-面向对象设计准则和启发规则"><a href="#9-1-面向对象设计准则和启发规则" class="headerlink" title="9.1 面向对象设计准则和启发规则"></a>9.1 面向对象设计准则和启发规则</h3><h3 id="9-2-软件重用"><a href="#9-2-软件重用" class="headerlink" title="9.2 软件重用"></a>9.2 软件重用</h3><h3 id="9-3-子系统"><a href="#9-3-子系统" class="headerlink" title="9.3 子系统"></a>9.3 子系统</h3><h3 id="9-4-设计关联-amp-设计模式"><a href="#9-4-设计关联-amp-设计模式" class="headerlink" title="9.4 设计关联 &amp; 设计模式"></a>9.4 设计关联 &amp; 设计模式</h3><h2 id="第十章-面向对象实现"><a href="#第十章-面向对象实现" class="headerlink" title="第十章 面向对象实现"></a><font color="mediumblue">第十章 面向对象实现</font></h2><mark class="hl-label pink">【重点】面向对象设计风格；设计测试用例。</mark> <h3 id="10-1-面向对象语言"><a href="#10-1-面向对象语言" class="headerlink" title="10.1 面向对象语言"></a>10.1 面向对象语言</h3><h3 id="10-2-面向对象设计风格"><a href="#10-2-面向对象设计风格" class="headerlink" title="10.2 面向对象设计风格"></a>10.2 面向对象设计风格</h3><h3 id="10-3-面向对象测试"><a href="#10-3-面向对象测试" class="headerlink" title="10.3 面向对象测试"></a>10.3 面向对象测试</h3><h2 id="第十一章-软件工程标准化和软件文档"><a href="#第十一章-软件工程标准化和软件文档" class="headerlink" title="第十一章 软件工程标准化和软件文档"></a><font color="mediumblue">第十一章 软件工程标准化和软件文档</font></h2><mark class="hl-label pink">【重点】软件工程标准化的概念、类型和意义；软件文档的作用和分类。</mark> <h3 id="11-1-软件工程标准化"><a href="#11-1-软件工程标准化" class="headerlink" title="11.1 软件工程标准化"></a>11.1 软件工程标准化</h3><h3 id="11-2-软件文档"><a href="#11-2-软件文档" class="headerlink" title="11.2 软件文档"></a>11.2 软件文档</h3><h2 id="第十二章-软件工程质量"><a href="#第十二章-软件工程质量" class="headerlink" title="第十二章 软件工程质量"></a><font color="mediumblue">第十二章 软件工程质量</font></h2><mark class="hl-label pink">【重点】软件质量的定义、度量和软件质量度量模型。</mark> <h3 id="12-1-软件质量"><a href="#12-1-软件质量" class="headerlink" title="12.1 软件质量"></a>12.1 软件质量</h3><h3 id="12-2-CMM模型"><a href="#12-2-CMM模型" class="headerlink" title="12.2 CMM模型"></a>12.2 CMM模型</h3><h2 id="第十三章-软件工程项目管理"><a href="#第十三章-软件工程项目管理" class="headerlink" title="第十三章 软件工程项目管理"></a><font color="mediumblue">第十三章 软件工程项目管理</font></h2><mark class="hl-label pink">【重点】软件工程项目管理的概念；成本估算；开发进度计划的制定；甘特图；工程网络与关键路径；项目跟踪与控制；软件配置。</mark> <h3 id="13-1-软件项目管理"><a href="#13-1-软件项目管理" class="headerlink" title="13.1 软件项目管理"></a>13.1 软件项目管理</h3><h3 id="13-2-基于CASE技术的开发工具"><a href="#13-2-基于CASE技术的开发工具" class="headerlink" title="13.2 基于CASE技术的开发工具"></a>13.2 基于CASE技术的开发工具</h3><h3 id="13-3-软件成本估算"><a href="#13-3-软件成本估算" class="headerlink" title="13.3 软件成本估算"></a>13.3 软件成本估算</h3><h3 id="13-4-开发计划"><a href="#13-4-开发计划" class="headerlink" title="13.4 开发计划"></a>13.4 开发计划</h3><h3 id="13-5-甘特图"><a href="#13-5-甘特图" class="headerlink" title="13.5 甘特图"></a>13.5 甘特图</h3><h3 id="13-6-工程网络与关键路径"><a href="#13-6-工程网络与关键路径" class="headerlink" title="13.6 工程网络与关键路径"></a>13.6 工程网络与关键路径</h3><h3 id="13-7-项目跟踪与控制"><a href="#13-7-项目跟踪与控制" class="headerlink" title="13.7 项目跟踪与控制"></a>13.7 项目跟踪与控制</h3><h3 id="13-8-软件配置"><a href="#13-8-软件配置" class="headerlink" title="13.8 软件配置"></a>13.8 软件配置</h3>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/29/02333-syllabus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747 Java 考试大纲复习手册</title>
      <link>https://pearlchocolatezy.com/2025/06/29/04747-syllabus/</link>
      <guid>https://pearlchocolatezy.com/2025/06/29/04747-syllabus/</guid>
      <pubDate>Sun, 29 Jun 2025 04:15:34 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;题型：单项选择题、填空题、简答题、程序改错题、程序分析题、程序设计题等。&lt;/p&gt;
&lt;h2 id=&quot;第一章-概述&quot;&gt;&lt;a href=&quot;#第一章-概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 概述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;mediumblue&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>题型：单项选择题、填空题、简答题、程序改错题、程序分析题、程序设计题等。</p><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a><font color="mediumblue">第一章 概述</font></h2><mark class="hl-label pink">【重点】Java语言的特点，Java开发环境的基本使用。</mark> <h3 id="1-1-理解Java语言的特点和应用背景"><a href="#1-1-理解Java语言的特点和应用背景" class="headerlink" title="1.1 理解Java语言的特点和应用背景"></a>1.1 理解Java语言的特点和应用背景</h3><h3 id="1-2-Java应用和程序初步"><a href="#1-2-Java应用和程序初步" class="headerlink" title="1.2 Java应用和程序初步"></a>1.2 Java应用和程序初步</h3><h3 id="1-3-Java的编译、运行命令"><a href="#1-3-Java的编译、运行命令" class="headerlink" title="1.3 Java的编译、运行命令"></a>1.3 Java的编译、运行命令</h3><h3 id="1-4-较流行的IDE环境"><a href="#1-4-较流行的IDE环境" class="headerlink" title="1.4 较流行的IDE环境"></a>1.4 较流行的IDE环境</h3><h2 id="第二章-标识符和数据类型"><a href="#第二章-标识符和数据类型" class="headerlink" title="第二章 标识符和数据类型"></a><font color="mediumblue">第二章 标识符和数据类型</font></h2><mark class="hl-label pink">【重点】常量，变量，面向对象基本概念。</mark> <h3 id="2-1-关键字和自定义标识符（自建类、方法等的名称）"><a href="#2-1-关键字和自定义标识符（自建类、方法等的名称）" class="headerlink" title="2.1 关键字和自定义标识符（自建类、方法等的名称）"></a>2.1 关键字和自定义标识符（自建类、方法等的名称）</h3><h3 id="2-2-三种注释"><a href="#2-2-三种注释" class="headerlink" title="2.2 三种注释"></a>2.2 三种注释</h3><h3 id="2-3-常量和变量-amp-数据类型转换"><a href="#2-3-常量和变量-amp-数据类型转换" class="headerlink" title="2.3 常量和变量 &amp; 数据类型转换"></a>2.3 常量和变量 &amp; 数据类型转换</h3><h3 id="2-4-复合数据类型：Array，类，接口，Enum，包"><a href="#2-4-复合数据类型：Array，类，接口，Enum，包" class="headerlink" title="2.4 复合数据类型：Array，类，接口，Enum，包"></a>2.4 复合数据类型：Array，类，接口，Enum，包</h3><h3 id="2-5-面向对象基本概念"><a href="#2-5-面向对象基本概念" class="headerlink" title="2.5 面向对象基本概念"></a>2.5 面向对象基本概念</h3><h2 id="第三章-表达式和流程控制语句"><a href="#第三章-表达式和流程控制语句" class="headerlink" title="第三章 表达式和流程控制语句"></a><font color="mediumblue">第三章 表达式和流程控制语句</font></h2><mark class="hl-label pink">【重点】流程控制语句。</mark> <h3 id="3-1-运算符-amp-Math类"><a href="#3-1-运算符-amp-Math类" class="headerlink" title="3.1 运算符 &amp; Math类"></a>3.1 运算符 &amp; Math类</h3><h3 id="3-2-表达式语句、条件语句、循环语句"><a href="#3-2-表达式语句、条件语句、循环语句" class="headerlink" title="3.2 表达式语句、条件语句、循环语句"></a>3.2 表达式语句、条件语句、循环语句</h3><h3 id="3-3-while-do-while-for-break-continue"><a href="#3-3-while-do-while-for-break-continue" class="headerlink" title="3.3 while, do-while, for, break, continue"></a>3.3 while, do-while, for, break, continue</h3><h2 id="第四章-数组、向量和字符串"><a href="#第四章-数组、向量和字符串" class="headerlink" title="第四章 数组、向量和字符串"></a><font color="mediumblue">第四章 数组、向量和字符串</font></h2><mark class="hl-label pink">【重点】数组的声明、创建和使用。</mark> <h3 id="4-1-StringBuffer类"><a href="#4-1-StringBuffer类" class="headerlink" title="4.1 StringBuffer类"></a>4.1 StringBuffer类</h3><h3 id="4-2-一维数组的声明、创建、初始化、使用"><a href="#4-2-一维数组的声明、创建、初始化、使用" class="headerlink" title="4.2 一维数组的声明、创建、初始化、使用"></a>4.2 一维数组的声明、创建、初始化、使用</h3><h3 id="4-3-多维数组的声明、创建、初始化、使用"><a href="#4-3-多维数组的声明、创建、初始化、使用" class="headerlink" title="4.3 多维数组的声明、创建、初始化、使用"></a>4.3 多维数组的声明、创建、初始化、使用</h3><h3 id="4-4-String类，Array类（System-arraycopy-方法）"><a href="#4-4-String类，Array类（System-arraycopy-方法）" class="headerlink" title="4.4 String类，Array类（System.arraycopy()方法）"></a>4.4 String类，Array类（System.arraycopy()方法）</h3><h2 id="第五章-进一步讨论对象和类"><a href="#第五章-进一步讨论对象和类" class="headerlink" title="第五章 进一步讨论对象和类"></a><font color="mediumblue">第五章 进一步讨论对象和类</font></h2><mark class="hl-label pink">【重点】类与对象的创建和使用，与类之间的关系，继承过程中产生的隐藏和覆盖问题。</mark> <h3 id="5-1-类的声明-amp-构造方法"><a href="#5-1-类的声明-amp-构造方法" class="headerlink" title="5.1 类的声明 &amp; 构造方法"></a>5.1 类的声明 &amp; 构造方法</h3><h3 id="5-2-类的继承"><a href="#5-2-类的继承" class="headerlink" title="5.2 类的继承"></a>5.2 类的继承</h3><h3 id="5-3-抽象类"><a href="#5-3-抽象类" class="headerlink" title="5.3 抽象类"></a>5.3 抽象类</h3><h3 id="5-4-接口-amp-接口的实现"><a href="#5-4-接口-amp-接口的实现" class="headerlink" title="5.4 接口 &amp; 接口的实现"></a>5.4 接口 &amp; 接口的实现</h3><h3 id="5-5-main-static-final-super-访问控制符"><a href="#5-5-main-static-final-super-访问控制符" class="headerlink" title="5.5 main, static ,final, super, 访问控制符"></a>5.5 main, static ,final, super, 访问控制符</h3><h3 id="5-6-包"><a href="#5-6-包" class="headerlink" title="5.6 包"></a>5.6 包</h3><h3 id="5-7-子类"><a href="#5-7-子类" class="headerlink" title="5.7 子类"></a>5.7 子类</h3><h2 id="第六章-Java语言中的异常"><a href="#第六章-Java语言中的异常" class="headerlink" title="第六章 Java语言中的异常"></a><font color="mediumblue">第六章 Java语言中的异常</font></h2><mark class="hl-label pink">【重点】异常处理机制。</mark> <h3 id="6-1-常见异常"><a href="#6-1-常见异常" class="headerlink" title="6.1 常见异常"></a>6.1 常见异常</h3><h3 id="6-2-自定义异常"><a href="#6-2-自定义异常" class="headerlink" title="6.2 自定义异常"></a>6.2 自定义异常</h3><h2 id="第八章-Java的图形用户界面设计"><a href="#第八章-Java的图形用户界面设计" class="headerlink" title="第八章 Java的图形用户界面设计"></a><font color="mediumblue">第八章 Java的图形用户界面设计</font></h2><mark class="hl-label pink">【重点】容器、布局、常用组件、委托事件处理机制。</mark> <h3 id="8-1-Java-GUI的组成"><a href="#8-1-Java-GUI的组成" class="headerlink" title="8.1 Java GUI的组成"></a>8.1 Java GUI的组成</h3><h3 id="8-2-容器-amp-布局"><a href="#8-2-容器-amp-布局" class="headerlink" title="8.2 容器 &amp; 布局"></a>8.2 容器 &amp; 布局</h3><h3 id="8-3-AWT和Swing常用组件"><a href="#8-3-AWT和Swing常用组件" class="headerlink" title="8.3 AWT和Swing常用组件"></a>8.3 AWT和Swing常用组件</h3><h2 id="第九章-Swing组件"><a href="#第九章-Swing组件" class="headerlink" title="第九章 Swing组件"></a><font color="mediumblue">第九章 Swing组件</font></h2><mark class="hl-label pink">【重点】常用组件的综合使用。</mark> <h3 id="9-1-菜单"><a href="#9-1-菜单" class="headerlink" title="9.1 菜单"></a>9.1 菜单</h3><h3 id="9-2-对话框-amp-滚动条"><a href="#9-2-对话框-amp-滚动条" class="headerlink" title="9.2 对话框 &amp; 滚动条"></a>9.2 对话框 &amp; 滚动条</h3><h3 id="9-3-按钮、标签、列表、组合框、文本域、文本区等"><a href="#9-3-按钮、标签、列表、组合框、文本域、文本区等" class="headerlink" title="9.3 按钮、标签、列表、组合框、文本域、文本区等"></a>9.3 按钮、标签、列表、组合框、文本域、文本区等</h3><h3 id="9-4-处理鼠标事件"><a href="#9-4-处理鼠标事件" class="headerlink" title="9.4 处理鼠标事件"></a>9.4 处理鼠标事件</h3><h2 id="第十章-JavaApplet"><a href="#第十章-JavaApplet" class="headerlink" title="第十章 JavaApplet"></a><font color="mediumblue">第十章 JavaApplet</font></h2><mark class="hl-label pink">【重点】Applet类的主要方法，Applet的生命周期。</mark> <h3 id="10-1-Applet的基础知识"><a href="#10-1-Applet的基础知识" class="headerlink" title="10.1 Applet的基础知识"></a>10.1 Applet的基础知识</h3><h3 id="10-2-Applet类的主要方法"><a href="#10-2-Applet类的主要方法" class="headerlink" title="10.2 Applet类的主要方法"></a>10.2 Applet类的主要方法</h3><h3 id="10-3-Applet的运行机制"><a href="#10-3-Applet的运行机制" class="headerlink" title="10.3 Applet的运行机制"></a>10.3 Applet的运行机制</h3><h3 id="10-4-Applet生命周期"><a href="#10-4-Applet生命周期" class="headerlink" title="10.4 Applet生命周期"></a>10.4 Applet生命周期</h3><h3 id="10-5-HTML与Applet的配合使用"><a href="#10-5-HTML与Applet的配合使用" class="headerlink" title="10.5 HTML与Applet的配合使用"></a>10.5 HTML与Applet的配合使用</h3><h3 id="10-6-Applet的应用"><a href="#10-6-Applet的应用" class="headerlink" title="10.6 Applet的应用"></a>10.6 Applet的应用</h3>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/29/04747-syllabus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（八）——图形界面设计</title>
      <link>https://pearlchocolatezy.com/2025/06/23/04747-08/</link>
      <guid>https://pearlchocolatezy.com/2025/06/23/04747-08/</guid>
      <pubDate>Mon, 23 Jun 2025 14:56:05 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;J开头的是Swing组件。&lt;/li&gt;
&lt;li&gt;AWT组件包括：Label，Checkbox，TextField&lt;/li&gt;
&lt;li&gt;请简要说明AWT组件与Swing组件的区别：&lt;br&gt;AWT组件是早期的JDK版本提供的窗口工具集,包含部分本地代码,在不同平台上运行</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>J开头的是Swing组件。</li><li>AWT组件包括：Label，Checkbox，TextField</li><li>请简要说明AWT组件与Swing组件的区别：<br>AWT组件是早期的JDK版本提供的窗口工具集,包含部分本地代码,在不同平台上运行的效果略有差异,也被称为“重量级”组件。<br>Swing组件是较新的JDK版本提供的窗口工具集,功能比AWT更加强大,多数组件的名字以“J”开头。Swing组件不包含任何本地代码,在任何平台上的显示效果都是一致的,也被称为“轻量级组件”。</li><li>Swing组件定义在<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">jaxax.swing</i>包中。</li><li>Swing的四种顶层容器：JFrame, JApplet, JDialog, JWindow。</li><li>所有容器的父类是Container。</li><li>JFrame：一个带有标题行和控制按钮的独立窗口，有时称为框架，创建应用程序时需要使用JFrame。</li><li>创建小应用程序时使用 JApplet。</li><li>Frame被称为容器组件。</li><li>Java有哪些方法可以将组件放到内容窗格中：<br>Java有两种方法可以将组件放入内容窗格中。<br>第一种是通过顶层容器的 getContentPane()方法获得默认的内容窗格,然后将组件添加到内容窗格中。<br>第二种方法是创建一个新的内容窗格,将组件添加到新的内容窗格,然后用新的内容窗格取代顶层容器默认的内容窗格。</li><li>JScrollPane是带有滚动条的面板。</li><li>什么是容器组件？容器组件应如何使用？<br>容器组件是指可以包含其他组件的组件。<br>容器分为顶层容器和一般用途容器,显示在屏幕上的所有组件都必须包含在某个容器中,有些容器可以嵌套,在这个嵌套层次的最外层,必须是一个顶层容器。</li><li>将三个按钮垂直排列的代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frame=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Buttons&quot;</span>);</span><br><span class="line">Container con=frame.getContentPane();</span><br><span class="line">con.add(btn1, BorderLayout.NORTH);</span><br><span class="line">con.add(btn2, BorderLayout.CENTER);</span><br><span class="line">con.add(btn3, BorderLayout.SOUTH);</span><br><span class="line">frame.pack();<span class="comment">//调整窗口的大小，使其能够容纳所有组件的首选大小和布局</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li>Swing常用的四种按钮：JButton, JToggleButton, JCheckBox, JRadioButton。</li><li>JMenu继承自JMenuItem，JMenuItem继承自AbstractButton，最终继承自JComponent。</li><li>JButton继承自AbstractButton，AbstractButton继承自JComponent。</li><li>JLabel直接继承自JComponent。</li><li>JTextArea继承自JTextComponent，JTextComponent继承自JComponent。</li><li>java.awt包中的类<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">Graphics</i>是所有图形处理的基础。</li><li>组合框上的用户事件可以通过<i id="answer20_1" class="answer" onclick="showOrHide('20_1')">ActionListener</i>或<i id="answer20_2" class="answer" onclick="showOrHide('20_2')">ItemListener</i>处理。</li><li>如何处理 JComboBox上的用户事件？【背】<br>JComboBox(组合框)上的用户事件既可以通过 ActionListener处理,又可以通过 ItemListener处理。<br>用户输入项目后按键,对应的接口是 ActionListener。<br>用户选定项目,对应的接口是 ItemListener。<br>用户的一次选择操作会引发两个 ItemEvent事件,因此通常使用 ActionListener处理比较方便。</li><li>请说明按钮和按钮组的关系：【背】<br>按钮可以添加到按钮组中,这时首先要创建一个按钮组,然后调用按钮组的add()方法将按钮添加进去。当多个按钮被添加到同一个按钮组后,如果用户选中一个按钮,那么其他按钮就会变为未选中状态,即同一个按钮组中只能有一个按钮处于被选中状态。</li><li>给label，button添加文字：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(this是JFrame)</span></span><br><span class="line">label1=<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;aa&quot;</span>);<span class="comment">//新建label并添加文字</span></span><br><span class="line">btn=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;bb&quot;</span>);<span class="comment">//新建button并添加文字</span></span><br><span class="line">btn.setText(<span class="string">&quot;bbb&quot;</span>);<span class="comment">//button修改文字</span></span><br><span class="line">btn.setToolTipText(<span class="string">&quot;hello&quot;</span>);<span class="comment">//btn修改hover title</span></span><br><span class="line"></span><br><span class="line">Container con=getContentPane();</span><br><span class="line">con.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());<span class="comment">//FlowLayout:按照组件添加的顺序，从左到右、从上到下排列组件</span></span><br></pre></td></tr></table></figure></li><li>FlowLayout的对其方式的可选值有：LEFT, CENTER, RIGHT。</li><li>CardLayout特点：允许多个组件共用同一个显示空间，通过卡片的切换来显示不同的组件。</li><li>BoxLayout特点：多个组件从上到下排列。</li><li>GridLayout特点：容器被分成网格状。</li><li>FlowLayout每行可以放1个组件。</li><li>BorderLayout布局管理器是如何安排组件的？【背】<br>BorderLayout提供了一种较为复杂的组件布局管理方案。每个由BorderLayout管理的容器被划分为5个区域, 分别代表容器的上部(North)、下部(South)、左部(West)、右部(East)和中部(Center),分别使用常量 BorderLayout.NORTH、BorderLayout.SOUTH、BorderLayout.WEST、BorderLayout.EAST和BorderLayout.CENTER来表示。在容器的每个区域,可以加入一个组件。</li><li>设置JPanel的布局：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panel.setLauout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.LEFT));</span><br></pre></td></tr></table></figure></li><li>向容器添加组件：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.add(checkBox,BorderLayout.EAST);</span><br></pre></td></tr></table></figure></li><li>容器中组件的位置和大小/显示方式通常由<i id="answer32_1" class="answer" onclick="showOrHide('32_1')">布局管理器</i>负责安排。</li><li>MouseMotionListener接口主要用于处理鼠标的移动和拖拽事件。<br>它包含两个方法：<code>mouseMoved(MouseEvent e)</code>用于处理鼠标移动事件，<code>mouseDragged(MouseEvent e)</code>用于处理鼠标拖动事件。</li><li>MouseListener处理鼠标点击、鼠标释放、鼠标离开事件。</li><li>什么是事件侦听程序？【背】<br>在Java中,为了接收并处理某类用户事件,组件必须注册相应的事件处理程序,这种事件处理程序称为事件侦听程序(Listener),也称为侦听器,它是实现了对应侦听程序接口的一个类。</li><li>对事件的响应称为<i id="answer36_1" class="answer" onclick="showOrHide('36_1')">事件处理</i>。</li><li>在JList上进行选择时，将引发<i id="answer37_1" class="answer" onclick="showOrHide('37_1')">ListSelectionEvent</i>。</li><li>考试常用方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addItemListener(<span class="built_in">this</span>)</span><br><span class="line">checkBox.isSelected()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">MonseListener</span></span><br><span class="line">mouseClicked(MouseEvent e)</span><br></pre></td></tr></table></figure></li><li>java.awt.event中，用来检测并对事件做出反应的模型所包括的三种对象：【背】<br>源对象(1分)、监视器对象(1分)、事件对象(1分)</li><li>请写出Java语言中的事件处理机制：<br>事件被直接送往产生这个事件的组件(1分), 组件需要注册一个或多个侦听程序(1分)。侦听程序的类中包含了事件处理程序(1分)，用来接收和处理该事件(1分)</li><li>KeyListener的作用：<i id="answer41_1" class="answer" onclick="showOrHide('41_1')">处理键盘事件</i>。</li><li>在Java的绘图区域中，坐标原点（0,0）通常位于左上角。</li><li>在Java中进行绘图操作时，当组件被显示出来时，需调用paint(Graphics g)方法。</li><li>AWT的Font对象的作用是<i id="answer44_1" class="answer" onclick="showOrHide('44_1')">用类Font对象设置字型</i>。</li><li>Graphics2D类，stoke属性控制线条的宽度，笔形样式，线段连接方式，短划线图案；paint属性控制填充效果。【背】</li><li>什么是轻量级组件？什么是重量级组件？在程序中同时使用轻量级组件和重量级组件时，会有什么显示效果？【背】<br>不包含本地代码的组件成为轻量级组件。<br>包含本地代码的组件称为重量级组件。<br>当重量级组件与轻量级组件一同使用时，如果组件区域有重叠，则重量级组件总是显示在上面。</li><li><i id="answer47_1" class="answer" onclick="showOrHide('47_1')">Swing</i>组件比<i id="answer47_2" class="answer" onclick="showOrHide('47_2')">AWT</i>组件拥有更多的功能。</li><li>JFrame是顶层容器，可指定窗口标题，Swing可以继承它</li><li>Jpanel属于容器。</li><li>JLabel上既可以有文本也可以有图标。</li><li>setEnabled方法改变按钮的可用状态。</li><li>Swing中的复选按钮：JCheckbox；单选按钮：JRadioButton；切换按钮：JToggleButton</li><li>JPanel的默认布局管理器FlowLayout。</li><li>用户在程序界面所进行的操作是一个<i id="answer54_1" class="answer" onclick="showOrHide('54_1')">用户事件</i>。</li><li>要使得已注册的按钮对象暂时不响应事件，需要使用的方法是<i id="answer55_1" class="answer" onclick="showOrHide('55_1')">removeActionListener(ActionListener l)</i>。</li><li>在事件<i id="answer56_1" class="answer" onclick="showOrHide('56_1')">适配器</i>类中实现了相应接口中全部的方法，只不过方法体都为空。</li><li>当要创建自定义图形时，需要由JPanel类派生一个新类，并重写父类的<i id="answer57_1" class="answer" onclick="showOrHide('57_1')">paintComponent()</i>方法。</li><li>在Graphics类中，绘图模式主要有正常模式和<i id="answer58_1" class="answer" onclick="showOrHide('58_1')">异或</i>模式2种。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/23/04747-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（九）——Swing组件</title>
      <link>https://pearlchocolatezy.com/2025/06/23/04747-09/</link>
      <guid>https://pearlchocolatezy.com/2025/06/23/04747-09/</guid>
      <pubDate>Mon, 23 Jun 2025 14:55:34 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;JList不能用Array创建列表。&lt;/li&gt;
&lt;li&gt;JList既支持单项选择，也支持连续或间断的多项选择。&lt;/li&gt;
&lt;li&gt;JComboBox设置默认值：&lt;code&gt;jcb.setSelectedIndex(0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JComb</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>JList不能用Array创建列表。</li><li>JList既支持单项选择，也支持连续或间断的多项选择。</li><li>JComboBox设置默认值：<code>jcb.setSelectedIndex(0)</code></li><li>JComboBox是一个下拉式菜单。</li><li>Jlist是可供用户进行选择的<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">一系列可选项</i>。</li><li>请说明列表的当前选项发生变化的处理过程：【背】<br>当用户在列表上选择时,将引发ListSelectionEvent事件,在 JList中提供了 addListSelectionListener( ListSelectionListener listener)法,该方法用于注册对应的事件侦听程序,在ListSelectionListener接口中,只有一个方法:valueChanged(ListSelectionEvent),当列表的当前选项发生变化时,将会调用该方法进行响应处理。</li><li>滚动面板的滚动条总是可见：<code>VERTICAL_SCROLLBAR_ALWAYS</code>。</li><li>列表获取所选项：<code>list.getSelectedvalue()</code>。</li><li>JTextField是一个单行的文本输入框，可以指定列数，可以设置文本对齐方式。</li><li><i id="answer10_1" class="answer" onclick="showOrHide('10_1')">文本 或 JTextField 和 JTextArea</i>组件可用于显示信息和提供用户输入功能。</li><li>简述 JTextField和 JTextArea的区别：【背】<br>JTextField是一个单行的文本输入框,可用于输入少量文本,<br>JTextArea是一个多行多列的文本输入框。</li><li>方法setMnemonic()的作用是：<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">为菜单项设置快捷键</i>。</li><li>可以创建仅有图标的菜单项。</li><li>分割线：JSeparator。</li><li>请简要说明建立一个菜单系统的过程：【背】<br>通常在建立菜单系统时,首先创建一个菜单栏( JMenuBar),并通过 setMenuBar()方法将其放入某个框架中,然后创建若干个菜单(JMenu),通过 JMenuBar的add()方法将菜单加入菜单栏。最后创建各个菜单项,通过 JMenu的add()方法将它们加入不同的菜单中。</li><li>试述JMenuBar、JMenu、JMenuItem的关系：【背】<br>JMenuBar定义的是菜单栏,用来包容一组菜单,即 JMenu可以被添加至 JMenuBar,另外, JMenu还可以被添加至另一个 JMenu。如果将 JMenu看作是一棵树,那么 JMenultem就是这棵树的叶子,是菜单系统的最下面一级,即JMenu用来包容一组 JMenultem。</li><li>菜单栏：JMenuBar。</li><li>对话框是顶层容器。</li><li>强制型对话框被关闭之前,其他窗口无法接收任何形式的输入。<br>非强制型对话框可以中断对话过程,去响应对话框之外的事件。</li><li>一般要先创建一个窗类口类,再创建一个对话框。</li><li>构造一个强制对话框的语句：JDialog(frame,true)。</li><li>创建一个所有者为frame，标题为str的非强制对话框：JDialog(frame,str,false)。</li><li>JFileChooser 是一个用于创建文件选择对话框的类，它允许用户选择文件或目录，并且可以配置为打开或保存文件，同时支持文件类型过滤和多选功能。</li><li>JDialog类通常用于创建：<i id="answer24_1" class="answer" onclick="showOrHide('24_1')">自定义</i>对话框</li><li>文件对话框是专门用于对文件或目录进行<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">浏览和选择</i>的对话框。</li><li>列表的当前选项发生变化时，将会调用<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">valueChanged</i>方法。</li><li>JComboBox删除指定选项的方法是<i id="answer27_1" class="answer" onclick="showOrHide('27_1')">removeItem</i>。</li><li><code>Font f=new Font(&quot;宋体&quot;,Font.PLAIN,12);</code></li><li>菜单栏：<code>JMenuBar</code><br>复选菜单项：<code>JCheckBoxMenuItem</code><br>单选菜单项：<code>JRadioButtonMenuItem</code><br>itemEvent状态改变的响应事件：<code>itemStateChanged</code><br>文件对话框类：<code>JFileChooser</code></li><li>打开确认对话框的方法：showConfirmDialog<br>打开信息对话框的方法：showMessageDialog</li></ol><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/23/04747-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（七）——输入和输出流</title>
      <link>https://pearlchocolatezy.com/2025/06/21/04747-07/</link>
      <guid>https://pearlchocolatezy.com/2025/06/21/04747-07/</guid>
      <pubDate>Sat, 21 Jun 2025 14:10:53 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;OutputStream的常用方法write(int i),close(),flush()表示将字节i写入到数据流中，将输出流关闭，刷新输出流并强制写出所有缓冲的输出字节。&lt;/li&gt;
&lt;li&gt;Jav中所有涉及数据流的操作中，都会引入包&lt;i id=&quot;answer2</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>OutputStream的常用方法write(int i),close(),flush()表示将字节i写入到数据流中，将输出流关闭，刷新输出流并强制写出所有缓冲的输出字节。</li><li>Jav中所有涉及数据流的操作中，都会引入包<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">java.io</i>。</li><li>请说明输入数据流中方法read()和方法read(byte[] b)的作用是什么：【背】<br>方法read()的作用是：从输入流中读取一个字节的二进制数据。<br>方法read(byte[] b)的作用是：将多个字节读到数组中,填满整个数组。</li><li>Java中把不同的输入、输出源抽象为<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">流</i>。</li><li><p>什么是数据流，数据流分为哪些类，各类的特点是什么：【背】<br>数据流是指一组有顺序的、有起点和终点的字节集合。<br>数据流分为输入数据流和输出数据流,输入数据流只能读不能写,输出数据流只能写不能读。<br>从数据流中读取数据时,必须有一个数据源与该数据流相连。</p></li><li><p>不是所有对象都可以序列化。</p></li><li>接口Serilizable中没有定义任何方法，只作为一个标记指示实现该接口的类可以进行序列化。</li><li>一般在关闭输出流之前，应先使用flush()方法，强制输出剩余数据。</li><li>缓冲区的大小可变。</li><li>使用输入数据流中的read()方法，读取结束时返回-1。</li><li>对象序列化可以保存的是非静态成员变量。<br>（对象的序列化是将对象的状态转换为字节流，以便保存到文件或通过网络传输。<br>序列化关注的是对象的状态，而非类的状态。静态成员变量属于类本身，而非静态成员变量是每个实例对象独有的状态信息。）</li><li>为什么在关闭缓冲区输出流之前应执行flush方法？【背】<br>对于缓冲区输出流,当执行写入操作时,数据以块为单位进入缓冲区,当缓冲区的块空间被填满数据时才会真正将数据写到了输出流中。在最后一次执行写入操作后,缓冲区的块空间可能未被填满,所以此时没有将块中的数据真正的写入到输出流中,未真正的执行输出操作,此时若直接向该缓冲区输出流,则块中的数据会丢失。所以,在关闭缓冲区输出流之前,应先使用flush()方法,强制将剩余的数据写入到输出流中。</li><li>请简述过滤器数据流的概念及其种类：【背】<br>一个过滤器数据流在创建时与一个已经存在的数据流相连,这样在从这样的数据流中读取数据时,它提供的是对一个原始输入数据流的内容进行了特定处理的数据。<br>过滤器数据流有缓冲区数据流和数据数据流两种。</li><li>FilelnputStream和FileOutputStream的数据源或数据终点都应当是<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">文件</i>。</li><li>顶层容器都有一个<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">内容窗格</i>。</li><li>Java如何实现对象的序列化？【背】<br>Java中有一个接口java.io.Serializable，接口Serializable中没有定义任何方法,只是作为一个标记来指示实现该接口的类可以进行序列化,当一个类声明实现了Serializable接口时,表明该类的对象是可以序列化的,否则不能序列化。</li><li>写Java基本数据类型需要用<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">DataOutputStream</i>。</li><li>请写出采用缓冲式输入方式，按行输入文件内容的步骤：<br>先创建FilcReaer对象(1分),<br>再利用FileReader对象创建BufferedReader对象(1分),<br>然后对该对象使用readLine()方法(1分)。</li><li>字节流和字符流<br>处理字节流：BufferInputStream &amp; BufferOutputStream，FileInputStream &amp; FileOutputStream，ObjectInputStream &amp; ObjectOutputStream。<br>处理字符流：InputStreamReader &amp; OutputStreamWriter（<strong>InputStreamReader和OutputStreamWriter是字符流和字节流之间的桥梁</strong>，InputStreamReader将字节流转字符流，OutputStreamWriter将字符流转字节流）。</li><li>程序要采用缓冲式输入，只要先创建FileReader对象，再利用FileReader对象创建BufferedReader对象，习惯称为FileReader对象接到BufferedReader对象上。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferReader br;</span><br><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;abc.txt&quot;</span>);</span><br><span class="line">br=<span class="keyword">new</span> <span class="title class_">BufferReader</span>(fr);<span class="comment">//BufferReader实例的参数只能是Reader结尾的类型</span></span><br><span class="line">String s=br.readLine();</span><br></pre></td></tr></table></figure></li><li><code>System.in</code>用于控制台输入数据读取<br>转为代码中字符处理的过程：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br></pre></td></tr></table></figure></li><li>读c盘下java文件夹中的1.data，输出文件名、内容、文件大小：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\java\\1.data&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;文件名：&quot;</span>+f.getName());</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line">BufferReader br=<span class="keyword">new</span> <span class="title class_">BufferReader</span>(isr);</span><br><span class="line">System.out.println(<span class="string">&quot;文件内容：&quot;</span>);</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span>((s=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;文件大小：&quot;</span>+f.length)</span><br></pre></td></tr></table></figure></li><li>请说明Java基本字符流中读者、写者出现的原因及作用：<br>有些程序设计语言使用ASCI字符集,而Java使用Unicode字符集表示字符和字符串。<br>ASCII字符集以一个字节表示一个字符,可以认为一个字符就是一个字节。<br>Java使用两个字节表示一个字符,这时字节与字符就不再相同。Java为实现与其他程序语言及不同平台的交互,提供了一种新的数据流处理方案,称为读者和写者。读者和写者的作用是在字节流和字符流之间作中介,在构造方法中应指定一定的平台规范,以便把以字节方式表示的流转换为特定平台上的字符表示。</li><li>FileWriter类的作用是<i id="answer24_1" class="answer" onclick="showOrHide('24_1')">字符流文件写操作</i>。</li><li>Java语言使用的字符集是<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">Unicode</i>。</li><li><p>在BufferReader类中，能实现按行输入的方法为<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">readLine</i>。</p></li><li><p>File类不能实现的：写入数据；读写文件；getContent()；</p></li><li>File类的重命名文件方法是<code>f.renameTo(nf);</code>，获取文件名<code>getName()</code>，获取文件路径名<code>getPath()</code>。</li><li>File类的getParent()方法的作用是：获取文件父级目录名称。</li><li>Java提供的随机访问文件的类为<i id="answer30_1" class="answer" onclick="showOrHide('30_1')">RandomAccessFile</i>，该类读取一个字符的方法是<i id="answer30_2" class="answer" onclick="showOrHide('30_2')">readChar()</i>，向文件写入一个字符的方法是<i id="answer30_3" class="answer" onclick="showOrHide('30_3')">writeChar()</i>。</li><li>FileInputStream的read0方法读取各字符的ASCII码</li><li>能够输入输出对象的流称为<i id="answer32_1" class="answer" onclick="showOrHide('32_1')">对象流</i>。</li><li>序列化，反序列化</li><li>InputStream类能从输入流中读一个字节的二进制数据的方法是<i id="answer34_1" class="answer" onclick="showOrHide('34_1')">read</i>，能将一个字节的二进制数据写入输出流的是<i id="answer34_2" class="answer" onclick="showOrHide('34_2')">write</i>。</li><li>Java中的缓冲区字符输入流类是<i id="answer35_1" class="answer" onclick="showOrHide('35_1')">BufferedReader</i>，缓冲区字符输出流类是<i id="answer35_2" class="answer" onclick="showOrHide('35_2')">BufferedReader</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/21/04747-07/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（七）——软件生存周期过程与管理</title>
      <link>https://pearlchocolatezy.com/2025/06/21/02333-7/</link>
      <guid>https://pearlchocolatezy.com/2025/06/21/02333-7/</guid>
      <pubDate>Sat, 21 Jun 2025 12:48:53 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;按过程主体，软件生存周期分为：基本过程，支持过程，组织过程。&lt;/li&gt;
&lt;li&gt;软件基本过程：获取过程，供应过程，开发过程，运行过程，维护过程。&lt;/li&gt;
&lt;li&gt;软件验证过程的任务：需求验证，设计验证，代码验证，集成验证，文档验证。&lt;/li&gt;
&lt;li&gt;简述软件</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>按过程主体，软件生存周期分为：基本过程，支持过程，组织过程。</li><li>软件基本过程：获取过程，供应过程，开发过程，运行过程，维护过程。</li><li>软件验证过程的任务：需求验证，设计验证，代码验证，集成验证，文档验证。</li><li>简述软件验证过程中，过程实现的任务：【背】<br>（1）确定项目<font color="blue">是否需要</font>一项验证工作以及独立程度。<br>（2）如果项目承担验证工作,则应为验证软件产品建立相应的<font color="blue">验证过程</font>。<br>（3）如果项目需要独立的验证工作,则应选择一个<font color="blue">有资格的组织</font>负责进行验证。<br>（4）基于以上有关范围、粒度、复杂性和至关重要性分析,确定需要验证的生存周期活动和软件产品,并应为所选择的生存周期活动和软件产品<font color="blue">选择适当的验证活动</font>和任务以及执行这些任务相关的方法、技术<font color="blue">和工具</font>。<br>（5）基于所确定的验证任务,开发验证计划并建立相应的<font color="blue">文档</font>。<br>（6）<font color="blue">实现</font>验证计划。</li><li>什么是验证和确认，以及它们的区别？【背】<br>（1）验证就是证实一个过程或项目的每一软件工作产品/服务是否正确地反映了所规约的需求。；（1分）<br>（2）确认就是证实所期望使用的软件工作产品是否满足其需求；（1分）<br>（3）区别：验证是通过提供的客观证据、证实规约的需求是否得以满足；确认是通过提供的客观证据，证实有关特定期望的使用或应用的需求是否得以满足。（3分）</li><li>软件生存周期过程分为<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">5</i>个基本过程，<i id="answer4_2" class="answer" onclick="showOrHide('4_2')">8</i>个支持过程，<i id="answer4_3" class="answer" onclick="showOrHide('4_3')">4</i>个组织过程。</li><li>软件生存周期的七个过程组：<br>需求分析过程：意图是建立系统软件部分需求。<br>软件确认过程：证实期望使用的软件产品是否满足其需求。</li><li>增量模型：快速构建第一版产品的好方法；适合在项目一开始增加一两个需求，可减少需求变更。</li><li>螺旋模型：适合开发风险大需求不确定的项目；引入<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">风险分析</i>。</li><li>喷泉模型：支持面向对象技术。</li><li>瀑布模型：适合开发小组非常熟悉项目需求；有自上而下相互衔接的固定顺序。</li><li>简述演化模型及其适用场合：【背】<br>（1）演化模型是在用户提出待开发系统的核心需求的基础上，开发人员按照这一需求，首先开发一个核心系统投入运行，根据用户反馈，实施迭代，每次迭代均由需求、设计、编码、测试、集成等阶段组成，通过增加或修正，产生软件产品的增量，最终完成软件产品的开发。<br>（2）一定程度上可减少软件开发活动盲目性;<br>（3）该模型主要针对事先不能完整定义需求的软件开发。</li><li>简述瀑布模型各阶段：【背】<br>（1）系统需求；（1分）<br>（2）软件需求；（1分）<br>（3）需求分析；（1分）<br>（4）设计；（1分）<br>（5）编码；（1分）<br>（6）测试；（1分）<br>（7）运行。（1分）</li><li>简述瀑布模型概念及其主要问题：<br>定义：瀑布模型将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作,形如瀑布流水,最终得到产品。(1分)<br>问题：<br>（1）要求客户能够完整、正确和清晰地表达他们的需求;并要求开发人员一开始就要理解这一应用。(1分)<br>（2）由于需求的不稳定性,使设计、编码和测试阶段都可能发生延期;并且当项目接近结束时,出现了大量的集成和测试工作。(1分)<br>（3）在开始的阶段中,很难评估真正的进度状态;并且直到项目结束之前都不能演示系统的能力。(1分)<br>（4）在一个项目的早期阶段,过分地强调了基线和里程碑处的文档;并可能需要花费更多的时间用于建立一些用处不大的文档。(1分)</li><li>简述螺旋模型概念及其特点：<br>（1）螺旋模型是瀑布模型与演化模型的基础上加入两者所忽略的风险分析所建立的一种软件开发模型。(2分)<br>（2）螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。(3分)</li><li>项目管理计划的主体是<i id="answer16_1" class="answer" onclick="showOrHide('16_1')">过程管理计划</i>。</li><li>支持生存周期过程具有重要作用的计划：<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">软件工程管理</i>计划，<i id="answer17_2" class="answer" onclick="showOrHide('17_2')">软件配置管理</i>计划，<i id="answer17_3" class="answer" onclick="showOrHide('17_3')">软件质量保证</i>计划，<i id="answer17_4" class="answer" onclick="showOrHide('17_4')">软件验证和确认</i>计划，<i id="answer17_5" class="answer" onclick="showOrHide('17_5')">软件度量</i>计划。</li><li>简述选择一个合适项目的生存周期模型的步骤：【背】<br>（1）标识开发项目可用的SLCM（软件生命周期管理）。<br>（2）在所期望的最终系统和开发环境中,识那些会影响SLCM选择的属性。<br>（3）标识为选择生存周期模型所需要的任何约束,包括外部的或是内部的。<br>（4）基于以往的经验和组织能力,评估第一步所选择的那几个SLCM。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/21/02333-7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（六）——软件测试</title>
      <link>https://pearlchocolatezy.com/2025/06/13/02333-6/</link>
      <guid>https://pearlchocolatezy.com/2025/06/13/02333-6/</guid>
      <pubDate>Fri, 13 Jun 2025 13:47:56 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;调试是为了证明程序员的正确。&lt;/li&gt;
&lt;li&gt;调试的结果一般是不可预见的。&lt;/li&gt;
&lt;li&gt;调试是不受时间约束的。&lt;/li&gt;
&lt;li&gt;测试从一个侧面证明程序员的“失败”。&lt;/li&gt;
&lt;li&gt;测试以已知条件开始。&lt;/li&gt;
&lt;li&gt;静态软件评估技术：评审，代码</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>调试是为了证明程序员的正确。</li><li>调试的结果一般是不可预见的。</li><li>调试是不受时间约束的。</li><li>测试从一个侧面证明程序员的“失败”。</li><li>测试以已知条件开始。</li><li>静态软件评估技术：评审，代码检查（走查），静态分析（形式化证明）。</li><li>测试的首要目标是<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">预防错误</i>。</li><li>集成测试的目标是为了发现<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">与接口有关的错误</i>。</li><li>软件测试是一个有程序的过程，包括测试<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">设计</i>、测试<i id="answer9_2" class="answer" onclick="showOrHide('9_2')">执行</i>、测试<i id="answer9_3" class="answer" onclick="showOrHide('9_3')">结果比较</i>。</li><li>软件评估分为<i id="answer10_1" class="answer" onclick="showOrHide('10_1')">静态评估</i>，<i id="answer10_2" class="answer" onclick="showOrHide('10_2')">动态评估</i>。</li><li>依据程序逻辑结构的测试技术<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">白盒测试技术</i>。<br>包括：路径测试技术。</li><li>黑盒测试技术又称功能测试技术，包括：事务处理流程技术，定义域测试技术，状态测试技术；等价划分类，边界值分析，因果图。<br>黑盒测试定义：将被测软件看成黑盒子，只通过外部的输入和输出来发现软件中的错误。</li><li>测试度量：语句覆盖≤分支覆盖≤条件组合覆盖≤路径覆盖</li><li>条件覆盖：条件覆盖是白盒测试中的一种方法，其核心要求是设计测试用例，使得程序中每个判定表达式中的每个条件的所有可能结果（如真/假）至少被执行一次‌。</li><li>路径覆盖：路径覆盖是白盒测试中的一种方法，其核心要求是设计足够多的测试用例，确保程序的每条可能执行路径都至少被执行一次（若程序存在循环结构，则每个循环至少需经过一次）。</li><li>简述边界值分析在设计测试用例时可以遵循的原则：【难背】<br>（1）如果某个输入条件规定了输入值的范围，则应选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据；（1分）<br>（2）如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数作为测试数据；（1分）<br>（3）如果程序的规格说明中，输入域或输出域是有序集合，则选取集合的第一个元素、最后一个元素以及典型元素作为测试用例；（1分）<br>（4）如果程序中使用了内部数据结构，则应当选择这个内容数据结构的边界上的值作为测试用例；（1分）<br>（5）分析规格说明，找出其他可能的边界条件。（1分）</li><li>简述因果图方法生成测试用例的基本步骤：【难背】<br>（1）通过对软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符；（1分）<br>（2）分析原因与结果之间以及原因与原因之间对应的关系，并画出因果图；（1分）<br>（3）在因果图上标识出一些特定的约束或限制条件；（1分）<br>（4）把因果图转换成判定表；（1分）<br>（5）为判定表的每一列设计测试用例。（1分）</li><li>简述边界值分析与等价类划分技术的区别：【难背】<br>（1）边界值分析与等价类划分技术的区别在于：边界值分析着重边界的测试，应选取等于、刚刚大于或刚刚小于边界的值作为测试数据；（3分）<br>（2）而等价类划分是选取等价类中的典型值或任意值作为测试数据。（2分）</li><li>软件测试技术可分为两大类：<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">白盒测试技术</i>和<i id="answer18_2" class="answer" onclick="showOrHide('18_2')">黑盒测试技术</i>。</li><li>路径测试技术的基本要点：<br>（1）采用控制流程图来表达被测试程序模型,揭示程序中的控制结构。(2分)<br>（2）通过合理地选择一组穿过程序的路径,以达到某种测试度量。(2分)</li><li>白盒测试常用到的覆盖技术：语句覆盖，分支覆盖，条件覆盖，条件组合覆盖，路径覆盖。</li><li>在设计软件测试用例之前应<i id="answer22_1" class="answer" onclick="showOrHide('22_1')">建立环境模型</i>、<i id="answer22_2" class="answer" onclick="showOrHide('22_2')">被测对象模型</i>、<i id="answer22_3" class="answer" onclick="showOrHide('22_3')">错误模型</i>。</li><li>语句覆盖：至少执行程序中所有语句一次。</li><li>分支覆盖：至少将程序中的每个分支执行一次。</li><li>合理的测试序列：单元测试，集成测试，有效性测试，系统测试。<br>单元测试：考虑模块的局部数据结构，首先测试数据流，必须为每个模块单元测试开发<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">驱动</i>模块和<i id="answer25_2" class="answer" onclick="showOrHide('25_2')">承接/桩</i>模块。<br>集成测试：发现与接口有关的错误，以主控模块作为测试驱动模块，主要缺点是需要设计承接模块，用于模块组合功能和软件结构检验的测试，每当组合一个模块要进行<i id="answer25_3" class="answer" onclick="showOrHide('25_3')">回归</i>测试，可采用<i id="answer25_4" class="answer" onclick="showOrHide('25_4')">自顶向下</i>和<i id="answer25_5" class="answer" onclick="showOrHide('25_5')">自底向上</i>两种集成方式递增组装软件。<br>有效性测试：发现软件实现功能与需求规格说明书不一致。</li><li>软件测试是一个有程序的过程，包括<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">测试设计</i>、<i id="answer26_2" class="answer" onclick="showOrHide('26_2')">测试执行</i>、<i id="answer26_3" class="answer" onclick="showOrHide('26_3')">测试结果比较</i>。</li><li>简述软件测试步骤中合理的软件测试序列及每个序列的关注点：<br>（1）合理的测试序列:单元测试、集成测试、有效性测试和系统测试。<br>（2）单元测试关注每个独立的模块。<br>（3）集成测试关注模块的组装。<br>（4）有效性测试关注检验是否符合用户所见的文档。<br>（5）系统测试关注检验习题中所有元素之间的协作是否合适,整个系统的性能、功能是否达到。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/13/02333-6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（六）——继承与多态</title>
      <link>https://pearlchocolatezy.com/2025/06/12/04747-06/</link>
      <guid>https://pearlchocolatezy.com/2025/06/12/04747-06/</guid>
      <pubDate>Thu, 12 Jun 2025 12:41:14 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;Java仅支持单重继承。&lt;/li&gt;
&lt;li&gt;如果一个类有父类，那么父类只能有一个，这条限制称为&lt;i id=&quot;answer2_1&quot; class=&quot;answer&quot; onclick=&quot;showOrHide(&#39;2_1&#39;)&quot;&gt;单重继承&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;子类不能继</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>Java仅支持单重继承。</li><li>如果一个类有父类，那么父类只能有一个，这条限制称为<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">单重继承</i></li><li>子类不能继承父类的构造方法。</li><li>允许用已定义的类来定义一个新类，新类称作<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">子类</i>。</li><li>在Java中如何判断两个对象各个属性（成员变量）的值是否相同？<br>在Java中要判断两个对象的属性(成员变量)的值是否相同,需要在类声明中对equals方法进行覆盖,即重新修改这个方法,重写的equals方法中对对象中的值是否相等一一判断。</li><li>请说明父类与子类的联系与区别：<br>大的更一般的类可以看作父类,包含在其中的特殊的、具体的类是子类。<br>子类与父类的关系是:<strong>子类对象“is a”父类对象。</strong>从层次关系上讲,子类继承自父类,父类的对象引用可以指向子类对象,反之则不行。从成员上讲,子类可以比父类拥有更多的成员变量和成员方法,这些成员变量和成员方法是子类独有的,父类不具有也不能使用。但是反过来,父类中具有公共、保护权限的成员变量和成员方法同时也属于子类,子类可以使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类对象引用指向子类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">a.eat(); <span class="comment">// 输出：Dog is eating</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判断父类变量指向的是不是子类实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;<span class="comment">//判断父类变量指向的是不是子类实例</span></span><br><span class="line">Dog d=(Dog) a;<span class="comment">//将父类变量转换成对应的子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java允许将一个子类的对象赋给父类的变量（子类对象可以作为父类对象使用），这称为<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">对象转型（向上转型）</i>。</li><li>什么是继承：<br>将一个已有类中的数据和方法保留,并加上自己特殊的数据和方法,从而构成一个新类。</li><li>简述通过继承，子类可以获得的好处：【难背】<br>（1）子类可以拥有父类的所有属性和方法(2分)；<br>（2）也可以扩展原有代码、生成新的类、原有代码可以不必重写(1分)。</li><li>类A某个成员变量的类型是类B，则类A<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">has a</i>类B。</li><li>方法覆盖：要求子类定义方法所用的名字、返回类型及参数列表和父类中的方法使用的完全一样，也就是具有相同的方法签名，从逻辑上看就是子类方法中的成员方法将隐藏父类中的同名方法。<br>名词解释：使用类的继承关系，可以从已有的类产生新的类。在原有特性的基础上，增加了新的特性。父类中原有的方法可能不能满足新的要求，因此需要修改父类中已有的方法。</li><li>重载的方法属于同一个类，覆盖的方法分属于<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">父类、子类</i>。</li><li>简述关键字super的作用：【难背】<br>如果子类重写了父类中的方法，但在子类中还想使用父类中被隐藏的方法，可以使用super关键字，另外，在子类的构造方法中也可以使用super关键字，其功能为调用父类的构造方法。<br>使用super关键字时要注意两个问题：<br>首先，使用super.method()调用父类中的方法method(),将执行父类方法中的所有操作，其中可能会包括一些原本不希望进行的操作，所以调用时要谨慎。<br>其次，由继承性的机制可以知道，super.method()语句所调用的方法不一定是在父类中加以描述的，它也可能是父类从它的祖先中继承来的。因此，有可能需要按继承层次关系依次向上查询才能找到。</li><li>方法覆盖的两条原则：【难背】<br>（1）覆盖方法的允许范围不能小于原方法。<br>（2）覆盖方法所抛出的异常不能比原方法多。</li><li>如果一个抽象类除了抽象方法外什么都没有，则使用接口更合适。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>用关键字<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">final</i>修饰的类是终极类，不能有子类。</li><li>接口及其实现的基础语法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>什么是抽象类、抽象方法？在使用过程中有什么注意事项？【难背】<br>定义时只定义了方法但没有定义具体实现的类称为抽象类，在Java中通过关键字abstract把一个类定义为抽象类。<br>每一个未被定义具体实现的方法也用关键字abstract修饰，这样的方法称为抽象方法，只有抽象类才有抽象方法。<br>在使用抽象类和抽象方法时要注意的事项有：不能用抽象类作为模板创建对象，必须定义抽象类的子类后，用子类作为模板才能创建实例。对于抽象方法不能进行调用，子类将抽象方法实现以后才可以调用。</li><li>接口中所有的方法都是抽象方法，没有方法体。</li><li>一个类可以实现多个接口，从而实现了多重继承。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, ..., 接口N &#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口可以定义自己的成员变量和方法，但成员变量必须赋初值且不可改变（系统会自动添加final和static关键字）。</li><li>实现接口必须实现该接口的所有方法。</li><li>接口可以继承。</li><li>简述抽象类与接口的联系与区别：【难背】<br>抽象类是指类中定义了方法但没有具体实现的类，抽象类代表一些基本行为，但又无法或不宜在这个类中对这些行为加以具体实现，而希望在子类中根据实际情况去实现。<br>接口是体现抽象类功能的另一种方式，可将其想象为一个“纯”的抽象类，接口中所有的方法都是抽象方法，都没有方法体，接口与抽象类都用来定义多个类的共同属性。<br>接口还可以实现与抽象类不同的功能，具体来说，Java不支持多重继承，一个类只能从唯一的一个类继承，但允许一个类实现多个接口，从而实现了多重继承的功能，并具有更加清晰的结构。</li><li>一个接口能够包含的元素有<i id="answer27_1" class="answer" onclick="showOrHide('27_1')">成员变量</i>，默认修饰符是<i id="answer27_2" class="answer" onclick="showOrHide('27_2')">abstract</i>；<i id="answer27_3" class="answer" onclick="showOrHide('27_3')">成员方法</i>，默认修饰符是<i id="answer27_4" class="answer" onclick="showOrHide('27_4')">static,final</i>。</li><li>子类中修改父类中已有的同名方法，称为方法<i id="answer28_1" class="answer" onclick="showOrHide('28_1')">覆盖/重写</i>。</li><li>同一个类中，具有不同签名的同名方法是<i id="answer29_1" class="answer" onclick="showOrHide('29_1')">重载</i>方法。</li><li>接口中的抽象方法不能是私有或受保护的方法。</li><li>Java中实现多重继承的机制是<i id="answer31_1" class="answer" onclick="showOrHide('31_1')">使用接口</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/12/04747-06/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
