<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Tue, 18 Mar 2025 00:17:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TCP拥塞控制</title>
      <link>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/</link>
      <guid>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/</guid>
      <pubDate>Mon, 17 Mar 2025 13:26:38 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;一、原理-概念&quot;&gt;&lt;a href=&quot;#一、原理-概念&quot; class=&quot;headerlink&quot; title=&quot;一、原理/概念&quot;&gt;&lt;/a&gt;一、原理/概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;拥塞：某段时间内，对网络的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="一、原理-概念"><a href="#一、原理-概念" class="headerlink" title="一、原理/概念"></a>一、原理/概念</h3><ol><li>拥塞：某段时间内，对网络的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫拥塞。</li><li>拥塞的直接后果：（1）时延增加；（2）分组丢弃。</li><li>拥塞控制：通过合理调度、规范、调整向网络中发送数据的主机数量、发送速率或数据量，以避免拥塞或尽快消除已发生的拥塞。</li><li>拥塞控制与流量控制的区别：拥塞控制就是防止过多的数据注入到网络中这样可以使网络中的路由器或链路不至于过载，拥塞控制有一个前提，就是网络能够承受现有的网络负荷，他是一个全局性过程。而流量控制往往是指点对点通信量的控制，是个端到端的问题。</li></ol><h3 id="二、方法-算法"><a href="#二、方法-算法" class="headerlink" title="二、方法/算法"></a>二、方法/算法</h3><p><pre class="mermaid">graph LRA[拥塞控制策略] -->B[拥塞预防]A-->C[拥塞消除]C-->|网络层| D[基于拥塞状态反馈的拥塞控制方法]C-->|传输层| E[无须拥塞状态反馈的拥塞控制方法]E-->F[慢开始 - 拥塞避免 - 快重传 - 快恢复]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div><br>无须进行拥塞状态反馈的拥塞控制方法：在主机(即端系统)推断网络是否发生拥塞（是否发生报文段的超时），如果推断网络已发生拥塞，则主动调整向网络中发送数据的速率和数据量，以便消除拥塞。e.g.TCP拥塞控制。</p><p>TCP进行拥塞控制的算法有四种（拥塞控制过程的四个部分）：慢开始，拥塞避免，快重传，快恢复。</p><p>窗口是什么？ 拥塞窗口是一个状态变量，变量大小取决于网络拥塞程度。<br>MSS是指TCP/IP协议栈中TCP协议层所能发送的最大报文段长度。</p><p>TCP 的拥塞控制也叫做基于窗口的拥塞控制。为此，发送方维持了叫做<strong>拥塞窗口 cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。发送方让自己的发送窗口等于拥塞窗口。<br><img src="/2025/03/17/13017-TCP-CC/TCP拥塞控制.png" width="70%"><br><img src="/2025/03/17/13017-TCP-CC/TCP拥塞控制2.png" width="70%"></p><p>发送方控制拥塞窗口cwnd的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提供网络的利用率。但只要网络出现拥塞或者可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。<br>当网络发生拥塞时，路由器就要丢弃分组。只要发送方没有按时收到应当到达的确认报文，即出现了超时，可判断出现了网络拥塞。</p><p>TCP拥塞控制的窗口调节分为慢启动阶段和拥塞避免阶段，慢启动阶段窗口从一个MSS快速增长，达到某个阈值后转为拥塞避免阶段，拥塞避免阶段的窗口增长放慢。</p><p>慢启动阶段，每收到1个确认段，拥塞窗口增加1个MSS，每经过1RTT，拥塞窗口增长1倍；<br>在拥塞避免阶段，每经过l个RTT，拥塞窗口增加1个MSS。<br>发生超时（丢包）时，cwnd降至1MSS，阈值下降一半。<br>3次重复确认（丢包）时，旧版Tahoe中cwnd降至1MSS，新版Reno只下降一半。（题意不明时以新版为主）阈值均下降一半。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13017 计算机网络与信息安全——计算题</title>
      <link>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/</link>
      <guid>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/</guid>
      <pubDate>Mon, 17 Mar 2025 12:53:40 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;h4 id=&quot;1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。"><a href="#1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。" class="headerlink" title="1. 当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit/s。"></a>1. 当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">8Mbit/s</i>。</h4><p>【分析】计算机网络结构分为：①网络边缘 ②接入网络 ③网络核心<br>常见的接入网络：电话拨号接入、ADSL、HFC、局域网、移动接入网络。<br>ADSL（Asymmehic Digital Subscriber Line，非对称数字用户线路）是利用现有的电话网络的用户线路实现的接入网络。是家庭用户接入网络中常见的接入网络之一。<br>ASDL可以实现的上行和下行带宽与用户线路的长度有关系，当用户线路长度在3~5km范围内时，典型的上行带宽为 512kbit/s ~ 1Mbit/s，下行带宽为 1Mbit/s ~ 8Mbit/s。（记忆）</p><h4 id="2-主机A到主机B之间有一条链路，长度D-100m，带宽R-10-8-bit-s，信号传播速率V-250000km-s。如果主机A从t-0时刻向主机B发送长度L-1024bit的分组，求："><a href="#2-主机A到主机B之间有一条链路，长度D-100m，带宽R-10-8-bit-s，信号传播速率V-250000km-s。如果主机A从t-0时刻向主机B发送长度L-1024bit的分组，求：" class="headerlink" title="2. 主机A到主机B之间有一条链路，长度D=100m，带宽R=$10^8$bit/s，信号传播速率V=250000km/s。如果主机A从t=0时刻向主机B发送长度L=1024bit的分组，求："></a>2. 主机A到主机B之间有一条链路，长度D=100m，带宽R=$10^8$bit/s，信号传播速率V=250000km/s。如果主机A从t=0时刻向主机B发送长度L=1024bit的分组，求：</h4><h4 id="（1）主机A和主机B间的链路传输延迟-d-t-；"><a href="#（1）主机A和主机B间的链路传输延迟-d-t-；" class="headerlink" title="（1）主机A和主机B间的链路传输延迟$d_t$；"></a>（1）主机A和主机B间的链路传输延迟$d_t$；</h4><h4 id="（2）主机A发送该分组的传播延迟-d-p-；"><a href="#（2）主机A发送该分组的传播延迟-d-p-；" class="headerlink" title="（2）主机A发送该分组的传播延迟$d_p$；"></a>（2）主机A发送该分组的传播延迟$d_p$；</h4><h4 id="（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；"><a href="#（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；" class="headerlink" title="（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；"></a>（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；</h4><h4 id="（4）在t-d-t-时刻，分组的第一位在何处，并说明原因；"><a href="#（4）在t-d-t-时刻，分组的第一位在何处，并说明原因；" class="headerlink" title="（4）在t=$d_t$时刻，分组的第一位在何处，并说明原因；"></a>（4）在t=$d_t$时刻，分组的第一位在何处，并说明原因；</h4><h4 id="（5）主机A与主机B之间链路的时延带宽积。"><a href="#（5）主机A与主机B之间链路的时延带宽积。" class="headerlink" title="（5）主机A与主机B之间链路的时延带宽积。"></a>（5）主机A与主机B之间链路的时延带宽积。</h4><blockquote><p>(1) <script type="math/tex">d_t=\frac{L}{R}=\frac{1024bit}{10^8bit/s}=1.024*10^{-5}s</script><br>(2) <script type="math/tex">d_p=\frac{100m}{250000km/s}=4*10^{-7}s</script><br>(3) <script type="math/tex">T=d_t+d_p=1.064*10^{-5}s</script><br>(4) 分组的第一位已到达主机B，因为<script type="math/tex">d_t>d_p</script></p></blockquote><p>【分析】个人认为问题（1）（2）的叙述有问题，传输延迟是发送方处理的（是指数据从发送端开始进入链路直到完全进入链路所需的时间），是数据上的；传播延迟才是在链路上的，是物理上的。<br><img src="/2025/03/17/LearnNet13017-2/4种时延.png" width="50%"></p><h3 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h3><h3 id="三、传输层"><a href="#三、传输层" class="headerlink" title="三、传输层"></a>三、传输层</h3><ol><li>假设甲、乙双方采用<font color="mediumvioletred">GBN协议</font>发送报文段，甲已经发送了编号为0~7的报文段。当计时器超时时，若甲只收到0号和3号报文段的确认，则甲需要重发的报文段有哪些？<blockquote><p>4~7号报文段要重新发送。</p></blockquote></li></ol><p>【分析】GBN协议采用累积确认机制：即接收方只能按序接收数据分组，当发送方收到$ACK_n$时，表明接收方已正确接收序号$\le{n}$的所有分组。<br>GBN协议发送端的发送窗口数量$W_s\ge1$，接收端的接收窗口数量$W_r=1$（GBN协议的接收端无缓存能力，不能缓存未按序到达的分组）。<br>GBN发送方必须响应的三种事件：<br>（1）上层调用；<br>（2）收到1个$ACK_n$；<br>（3）计时器超时。<br>发送方收到3号帧的确认，意味着0、1、2、3号帧已被接收，因此需要重传的帧是 4、5、6、7 号帧。</p><h4 id="2-主机甲、乙通过128kbit-s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80-，分组序号字段的位数至少要达到多少？"><a href="#2-主机甲、乙通过128kbit-s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80-，分组序号字段的位数至少要达到多少？" class="headerlink" title="2. 主机甲、乙通过128kbit/s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80%，分组序号字段的位数至少要达到多少？"></a>2. 主机甲、乙通过128kbit/s卫星信道互连，采用<font color="mediumvioletred">滑动窗口协议</font>发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80%，分组序号字段的位数至少要达到多少？</h4><blockquote><p>至少4位。</p></blockquote><p><img src="/2025/03/17/LearnNet13017-2/滑动窗口协议.png" width="70%"><br>【分析】（本题的分组理解为图上的帧）数据链路层，一次发一帧，相当于一次发1000B。发送帧有延迟，确认帧无延迟。<br>发送一帧的时间=发送延迟+发送时延+接收时延+接受延迟（接受延迟为0），即图中的a+b+c。<font color="silver">（一个RTT=一组发送时延+接收时延）</font><br>发送一帧的时间= $t_{seg}$ +RTT+ $t_{ack}$ ，本题$t_{seg}$=250ms，$t_{ack}$=0，RTT=1000*8bit/(128*1000)*2=1/$2_4$ms<br>按照信号利用率公式：<script type="math/tex">U_{sender} = \frac{W_s \times t_{seg}}{t_{seg}+RTT+t_{ack}}</script><br>发送延迟=一帧长度的发送延迟=$t_{seg}$=1000*8bit/(128*1000)=1/$2^3$ms<br>$W_s$相当于发送窗口的个数。</p><script type="math/tex; mode=display">U_{sender} = \frac{W_s \times 1/2^3}{1/2^4 + 1/2^3} \ge 0.8</script><script type="math/tex; mode=display">W_s \ge 7.2</script><p>分组序号范围是[1,$2^{n-1}$]<br>至少有：$7.2 \le W_s \le 8=2^3=2^{4-1}$<br>即窗口个数至少为8，n（位数）至少为4。</p><h4 id="3-若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？"><a href="#3-若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？" class="headerlink" title="3. 若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？"></a>3. 若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？</h4><blockquote><p>阈值=24/2=12MSS<br>拥塞窗口=1MSS</p></blockquote><p>【分析】结合 <a href="/2025/03/17/13017-TCP-CC/" title="TCP拥塞控制">TCP拥塞控制</a> 理解。<br>TCP拥塞避免阶段发生超时，cwnd降至1MSS，阈值降至原来的一半。</p><h4 id="4-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？"><a href="#4-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？" class="headerlink" title="4. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？"></a>4. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？</h4><blockquote><p>第一个报文段的确认序列号是200+300=500<br>第二个报文段的确认序列号是500+500=1000</p></blockquote><p>【分析】确认序列号=原始序列号+TCP段的长度</p><h4 id="5-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？"><a href="#5-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？" class="headerlink" title="5. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？"></a>5. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？</h4><blockquote><p>500</p></blockquote><p>【分析】题目中给出的某个报文段的序号就是原始序列号。<br><img src="/2025/03/17/LearnNet13017-2/确认序号.png" width="60%"><br>由于TCP是累积确认，收到了第3段没收到第2段的情况，确认序号仍停留在第一段的末尾第二段的起始，即500。</p><h4 id="6-主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？"><a href="#6-主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？" class="headerlink" title="6. 主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？"></a>6. 主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？</h4><blockquote><p>2046 2013</p></blockquote><p>【分析】考查TCP的数据编号与确认。<br>有效载荷为100B，即TCP段长度为100B。报文段的序号即该报文段的原始序号，即已发送给甲的，即甲发送之前的，是1913。那么甲即将要发送的报文段的初始序号=乙发来的报文段的确认序号=1913+100=2013。</p><h4 id="7-主机甲和主机乙已建立TCP连接，甲始终以MSS-1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？"><a href="#7-主机甲和主机乙已建立TCP连接，甲始终以MSS-1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？" class="headerlink" title="7. 主机甲和主机乙已建立TCP连接，甲始终以MSS=1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？"></a>7. 主机甲和主机乙已建立TCP连接，甲始终以MSS=1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？</h4><blockquote><p>10KB</p></blockquote><p>【分析】从发生超时的那一刻起，阈值调整为t时刻cwnd大小的一半，即ssthresh=8KB/2=4KB。<br>RTT=1, cwnd=1MSS<br>RTT=2, cwnd=2MSS<br>RTT=3, cwnd=4MSS, 此时到达门限值ssthresh，之后进入拥塞避免阶段<br>RTT=4, cwnd=5MSS, cwnd会一直线性增长到接收窗口大小<br>RTT=5, cwnd=6MSS<br>RTT=6, cwnd=7MSS<br>RTT=7, cwnd=8MSS<br>RTT=8, cwnd=9MSS<br>RTT=9, cwnd=10MSS<br>RTT=10, cwnd=10MSS, 发送端不能超过接收端10，此后拥塞窗口一直保持cwnd=10KB。</p><h4 id="8-主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？"><a href="#8-主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？" class="headerlink" title="8. 主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？"></a>8. 主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？</h4><blockquote><p>1000B</p></blockquote><p>【分析】甲总共发送了2000B给乙，只确认了1000B，还有1000B未确认，说明乙的接收窗口还有1000B未确认占用了总共2000B的空间，剩下最多可接收1000B，1000B&lt;=4000B，因此甲最大可发1000B（最大还能发一个报文段）。</p><h3 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h3><h4 id="1-请将建网络183-164-128-0-17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"><a href="#1-请将建网络183-164-128-0-17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。" class="headerlink" title="1. 请将建网络183.164.128.0/17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"></a>1. 请将建网络183.164.128.0/17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。</h4><div class="table-container"><table><thead><tr><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP总数</th><th>可分配IP数量</th><th>可分配IP范围</th></tr></thead><tbody><tr><td>183.164.128.0/20</td><td>183.164.143.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.128.1 ~ 183.164.143.254</td></tr><tr><td>183.164.144.0/20</td><td>183.164.159.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.144.1 ~ 183.164.159.254</td></tr><tr><td>183.164.160.0/20</td><td>183.164.175.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.160.1 ~ 183.164.175.254</td></tr><tr><td>183.164.176.0/20</td><td>183.164.191.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.176.1 ~ 183.164.191.254</td></tr><tr><td>183.164.192.0/20</td><td>183.164.206.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.192.1 ~ 183.164.206.254</td></tr><tr><td>183.164.207.0/20</td><td>183.164.211.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.207.1 ~ 183.164.211.254</td></tr><tr><td>183.164.212.0/20</td><td>183.164.226.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.212.1 ~ 183.164.226.254</td></tr><tr><td>183.164.227.0/20</td><td>183.164.241.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.227.1 ~ 183.164.256.254</td></tr></tbody></table></div><p>【分析】IP网络地址183.164.128.0/17：前17位是网络部分，用于标识网络；剩余的（32-17）15位是主机部分，用于标识该网络中的单个设备。183.164.128.0/17表示的是一个包含$2^{(32-17)} = 2^{15} = 32768$个地址的网络，其中包含32766个可用的主机地址（因为一个地址用于网络地址，一个用于广播地址）。这个网络的范围从183.164.128.0到183.164.255.255。<br>网络地址：在任何网络中，网络地址总是该网络的第一个地址。对于183.164.128.0/17这个网络，网络地址就是183.164.128.0。<br>广播地址：广播地址是该网络的最后一个地址，用于向该网络内的所有主机发送数据包。对于183.164.128.0/17这个网络，广播地址是183.164.255.255。<br>剩下的32766个可以分配给主机。</p><p>183.164.128.0/17分为8个子网，$2^3$=8，所以我们需要3位来划分子网。<br>分为8个子网后，网络部分有17+3=20位，剩下12位可分给主机。<br>183.164.128.0也就是183.164.10000000.0（第三个位置用8个二进制表示），子网地址紧跟在前17位后面，即占用18、19、20三位来划分：<br>（绿色部分4+8=12位用于分配主机，共$2^{12}$个主机地址，第一个分给子网的网络地址，最后一个分给广播地址，剩下中间$2^{12}-2$个分配给主机）<br>183.164.1<font color="mediumvioletred">000</font><font color="limegreen">0000.0</font>，<br>183.164.1<font color="mediumvioletred">001</font>0000.0，<br>183.164.1<font color="mediumvioletred">010</font>0000.0，<br>183.164.1<font color="mediumvioletred">011</font>0000.0，<br>183.164.1<font color="mediumvioletred">100</font>0000.0，<br>183.164.1<font color="mediumvioletred">101</font>0000.0，<br>183.164.1<font color="mediumvioletred">110</font>0000.0，<br>183.164.1<font color="mediumvioletred">111</font>0000.0。<br>广播地址：就是前20位网络地址不变，主机地址的12位IP地址都是1：183.164.1XXX1111.255。（表示每个子网的最后一个地址）<br>子网掩码：就是就是前20位网络地址全为1，主机地址的12位IP地址都是0。所以8个子网的子网掩码是一样的：255.255.11110000.0即255.255.240.0。<br>IP总数：共（32-20）12位可用于分配，每个子网有$2^{12}=4096$个。<br>可分配的IP地址：主机地址全为0是该子网的子网地址，全为1是该子网的广播地址，每个子网有4096-2=4094个。<br>可分配IP地址范围：子网地址末尾+1 ~ 广播地址末尾-1。</p><h4 id="2-某ISP拥有一个网络地址块201-123-16-0-21-现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"><a href="#2-某ISP拥有一个网络地址块201-123-16-0-21-现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。" class="headerlink" title="2. 某ISP拥有一个网络地址块201.123.16.0/21, 现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"></a>2. 某ISP拥有一个网络地址块201.123.16.0/21, 现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。</h4><div class="table-container"><table><thead><tr><th>组织</th><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP总数</th><th>可分配IP数量</th><th>IP地址数</th><th>可分配IP范围</th></tr></thead><tbody><tr><td>A</td><td>201.123.16.0/20</td><td>201.123.19.255</td><td>255.255.248.0</td><td>1024</td><td>1022</td><td>985</td><td>201.123.16.1 ~ 201.123.19.254</td></tr><tr><td>B</td><td>201.123.20.0/20</td><td>201.123.21.255</td><td>255.255.248.0</td><td>512</td><td>510</td><td>486</td><td>201.123.20.1 ~ 201.123.21.254</td></tr><tr><td>C</td><td>201.123.22.0/20</td><td>201.123.22.255</td><td>255.255.248.0</td><td>256</td><td>254</td><td>246</td><td>201.123.22.1 ~ 201.123.22.254</td></tr><tr><td>D</td><td>201.123.23.0/20</td><td>201.123.23.255</td><td>255.255.248.0</td><td>256</td><td>254</td><td>211</td><td>201.123.23.1 ~ 201.123.23.254</td></tr></tbody></table></div><p>【分析】201.123.16.0第三个位置写成二进制：0001 0000，题意已经给出前21位为网络部分，剩余（32-21）=11（3+8）位。<br>子网掩码：（21个1）1111 1111.1111 1111.1111 1000.0000 0000 即255.255.248.0<br>$2^{10}$=1048 &lt; 985+486+246+211=1928 &lt; 2048=$2^{11}$<br>哈夫曼树：</p><p><pre class="mermaid">graph TD    A[2048] --> |0| B1[组织A:1024]    A --> |1| B2[1024]    B2 --> |0| C1[组织B:512]    B2 --> |1| C2[512]    C2 --> |0| D1[组织C:256]    C2 --> |1| D2[组织D:256]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div><br>给第一个子网分配1024=$2^{10}$个地址，组织A实际只用985。范围为：<br>201.123.0001 0<font color="limegreen">000.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">011.1111 1111</font>最大（广播地址）</p><p>给第二个子网分配512=$2^9$个地址，组织B实际只用486。范围为：<br>201.123.0001 0<font color="limegreen">100.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">101.1111 1111</font>最大（广播地址）</p><p>给第三个子网分配256=$2^8$个地址，组织C实际只用256。范围为：<br>201.123.0001 0<font color="limegreen">110.0000 0000</font>最小（子网地址 ~<br>201.123.0001 0<font color="limegreen">110.1111 1111</font>最大（广播地址）</p><p>给第四个子网分配256=$2^8$个地址，组织D实际只用256。范围为：<br>201.123.0001 0<font color="limegreen">111.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">111.1111 1111</font>最大（广播地址）</p><h4 id="3-现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？"><a href="#3-现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？" class="headerlink" title="3. 现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？"></a>3. 现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？</h4><div class="table-container"><table><thead><tr><th>片</th><th>Length(总长度)</th><th>DF</th><th>MF</th><th>片偏移</th></tr></thead><tbody><tr><td>1</td><td>1500</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2</td><td>1500</td><td>0</td><td>1</td><td>185</td></tr><tr><td>3</td><td>840</td><td>0</td><td>0</td><td>370</td></tr></tbody></table></div><p>【分析】最大传输单元（MTU）是指网络层在一次传输中能够传输的最大数据包（或帧）的大小，以字节为单位。<br>DF：禁止分片标识，0表示允许分片，1表示禁止分片。<br>MF：更多分片标识，0表示该数据报未被分片或是最后一片，1表示该数据报一定是一个分片且不是最后一个。<br>IP数据报总长度：L=3800<br>最大传输单元(MTU)：M=1500<br><img src="/2025/03/17/LearnNet13017-2/IP数据报.png" width="40%"><br>最大分片可封装的数据长度 d=(1500-20)/8×8$\approx$1480（向下取整）<br>需要的IP分片数 n=(3800-20)/1500$\approx$3（向上取整）<br>每个IP的偏移字段：F1=1480/8×(1-1)=0, F2=1480/8×(2-1)=185, F3=1480/8×(3-1)=370<br>每个IP分片的总长度：L1=1480+20=1500，L2=1480+20，L3=3800-1480*(3-1)=840<br>每个IP分片的MF字段：MF1=1, MF2=1, MF3=0<br>由于题意一定分片，所以DF都为0。</p><h4 id="4-某网络拓扑图如下图所示，路由器-R1-通过接口-E1、E2-分别连接局域网1、局域网2，通过接口-L0-连接路由器-R2，并通过路由器-R2-连接域名服务器与互联网。R1-的-L0-接口的-IP-地址是-202-118-2-1-R2-的-L0-接口的-IP-地址是202-118-2-2，L1-接口的-IP-地址是-130-11-120-1，E0-接口的-地址是-202-118-3-1；-城名服务器的-IP-地址-202-118-3-2。"><a href="#4-某网络拓扑图如下图所示，路由器-R1-通过接口-E1、E2-分别连接局域网1、局域网2，通过接口-L0-连接路由器-R2，并通过路由器-R2-连接域名服务器与互联网。R1-的-L0-接口的-IP-地址是-202-118-2-1-R2-的-L0-接口的-IP-地址是202-118-2-2，L1-接口的-IP-地址是-130-11-120-1，E0-接口的-地址是-202-118-3-1；-城名服务器的-IP-地址-202-118-3-2。" class="headerlink" title="4. 某网络拓扑图如下图所示，路由器 R1 通过接口 E1、E2 分别连接局域网1、局域网2，通过接口 L0 连接路由器 R2，并通过路由器 R2 连接域名服务器与互联网。R1 的 L0 接口的 IP 地址是 202.118.2.1;  R2 的 L0 接口的 IP 地址是202.118.2.2，L1 接口的 IP 地址是 130.11.120.1，E0 接口的 地址是 202,118.3.1； 城名服务器的 IP 地址 202.118.3.2。"></a>4. 某网络拓扑图如下图所示，路由器 R1 通过接口 E1、E2 分别连接局域网1、局域网2，通过接口 L0 连接路由器 R2，并通过路由器 R2 连接域名服务器与互联网。R1 的 L0 接口的 IP 地址是 202.118.2.1;  R2 的 L0 接口的 IP 地址是202.118.2.2，L1 接口的 IP 地址是 130.11.120.1，E0 接口的 地址是 202,118.3.1； 城名服务器的 IP 地址 202.118.3.2。</h4><p><img src="/2025/03/17/LearnNet13017-2/网络拓扑.png" width="70%"><br>（1）将IP地址空间202.118.1.0/24分配给局域网1、局域网2，每个局域网需要分配的IP地址数不少于120个。请给出分配结果，并分别写出局域网1、局域网2 的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。<br>（2）请给出R1的路由表，使其明确包括到局域网1的路由、到局域网2的路由、到域名服务器的主机路由和到互联网的路由。<br>（3）请采用路由聚合技术，分别给出R2到局域网1、局域网2的路由。</p><blockquote><p>（1）</p></blockquote><div class="table-container"><table><thead><tr><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP地址总数</th><th>可分配IP地址数</th><th>可分配IP地址范围</th></tr></thead><tbody><tr><td>202.118.1.0/25</td><td>202.118.1.127</td><td>255.255.255.128</td><td>128</td><td>126</td><td>202.118.1.1 ~ 202.118.1.126</td></tr><tr><td>202.118.1.128/25</td><td>202.118.1.255</td><td>255.255.255.128</td><td>128</td><td>126</td><td>202.118.1.129 ~ 202.118.1.254</td></tr></tbody></table></div><p>【分析】64=$2^6$&lt;120&lt;$2^7$=128<br>每个局域网需要7位作为主机地址，1位为子网号，于是网络前缀变为（24+1）25位。<br>网络地址已用掉24位剩下（32-24）8位正好够用。<br>子网1的地址范围202.118.1.0000 0000~202.118.0111 1111<br>子网2的地址范围202.118.1.1000 0000~202.118.1111 1111<br>可以将子网1分配给局域网1，子网2分配给局域网2；或将子网1分配给局域网2，子网2分配给局域网1。<br>子网掩码：255.255.255.1000 0000，最后一个位置即$2^7$=128</p><blockquote><p>（2）R1的路由表</p></blockquote><p>若子网1分配给局域网1，子网2分配给局域网2：</p><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.0</td><td>255.255.255.128</td><td>-</td><td>E1</td></tr><tr><td>202.118.1.128</td><td>255.255.255.128</td><td>-</td><td>E2</td></tr><tr><td>202.118.3.2</td><td>255.255.255.255</td><td>202.118.2.2</td><td>L0</td></tr><tr><td>0.0.0.0</td><td>0.0.0.0</td><td>202.118.2.2</td><td>L0</td></tr></tbody></table></div><p>若子网2分配给局域网1，子网1分配给局域网2：</p><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.128</td><td>255.255.255.128</td><td>-</td><td>E1</td></tr><tr><td>202.118.1.0</td><td>255.255.255.128</td><td>-</td><td>E2</td></tr><tr><td>202.118.3.2</td><td>255.255.255.255</td><td>202.118.2.2</td><td>L0</td></tr><tr><td>0.0.0.0</td><td>0.0.0.0</td><td>202.118.2.2</td><td>L0</td></tr></tbody></table></div><blockquote><p>（3）局域网1和局域网2的地址可以聚合为202.118.1.0/24</p></blockquote><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.0</td><td>255.255.255.0</td><td>202.118.2.1</td><td>L0</td></tr></tbody></table></div><h3 id="五、数据链路层"><a href="#五、数据链路层" class="headerlink" title="五、数据链路层"></a>五、数据链路层</h3><h4 id="1-对于10-Mbps的基带CSMA-CD网的MAC帧的最小和最大总长度分别为64和1518字节。"><a href="#1-对于10-Mbps的基带CSMA-CD网的MAC帧的最小和最大总长度分别为64和1518字节。" class="headerlink" title="1. 对于10 Mbps的基带CSMA/CD网的MAC帧的最小和最大总长度分别为64和1518字节。"></a>1. 对于10 Mbps的基带CSMA/CD网的MAC帧的最小和最大总长度分别为<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">64</i>和<i id="answer5_2" class="answer" onclick="showOrHide('5_2')">1518</i>字节。</h4><p>【分析】R=10Mbit/s，以太网的CSMA/CD协议中的帧长范围也是固定的。<br>CSMA/CD协议的公式：<script type="math/tex">\frac{L_{min}}{R}\ge\frac{D_{max}}{v}</script></p><p><pre class="mermaid">graph LR    A[数据链路层使用的信道] --> B1[点对点信道]    A --> B2[广播信道]    B2 --> C[多路访问控制协议MAC]    C --> D1[信道划分MAC协议]    C --> D2[随机访问MAC协议]    C --> D3[受控接入MAC协议]    D1 --> E1[频分多路复用FDM]    D1 --> E2[时分多路复用TDM]    D1 --> E3[波分多路复用WDM]    D1 --> E4[码分多路复用CDM]    D2 --> E5[ALOHA协议]    D2 --> E6[载波监听多路访问协议CSMA]    D2 --> E7[带冲突检测的载波监听多路访问协议CSMA/CD]    style E7 stroke:#f9f,stroke-width:2px    D3 --> E8[集中式控制]    D3 --> E9[分散式控制]    E6 --> F1[非坚持CSMA]    E6 --> F2[1-坚持CSMA]    E6 --> F3[P-坚持CSMA]    E5 --> F4[纯ALOHA]    E5 --> F5[时隙ALOHA]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><p>非坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则立即发送数据；若发现信道忙，则等待一个随机时间，然后重新开始侦听信道。<br>1-坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则立即发送数据；若发现信道忙，则继续侦听信道，直至发现信道空闲，然后立即发送数据。<br>P-坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则以概率P在最近时隙开始时刻发送数据，以概率1-P延迟至下一个时隙发送；若发现信道忙，则等待一个随机时间，然后重新开始侦听信道。</p><p>多路复用技术：当传输介质的带宽或容量超过传输单一信号的需求时，可用一个信道同时传输多路信号，从而有效地利用通信线路，节省电缆安装和维护费用。<br>CSMA/CD协议：通信站使用CSMA协议进行数据发送；在发送期间，如果检测到碰撞，立即终止发送，并发出一个冲突强化信号，使所有通信站都知道冲突的发生；在发出冲突强化信号后，等待一个随机时间，再重复上述过程。</p><h4 id="2-有一个电缆长度为2km的CSMA-CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2-3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）-光速值为3×-10-5-km-s-。"><a href="#2-有一个电缆长度为2km的CSMA-CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2-3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）-光速值为3×-10-5-km-s-。" class="headerlink" title="2. 有一个电缆长度为2km的CSMA/CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2/3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）(光速值为3×$10^5$km/s)。"></a>2. 有一个电缆长度为2km的CSMA/CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2/3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）(光速值为3×$10^5$km/s)。</h4><blockquote><script type="math/tex; mode=display">D=2km=2*10^3m</script><script type="math/tex; mode=display">v=3*10^5km/s*\frac{2}{3}=2*10^8m/s</script><script type="math/tex; mode=display">L=512bit</script><script type="math/tex; mode=display">R=10Mbps=10*10^6bit/s=10^7bit/s</script><script type="math/tex; mode=display">d_t=\frac{L}{R}=\frac{512bit}{10^7bit/s}=5.12*10^{-5}s  \mathrm{传输时延}</script><script type="math/tex; mode=display">d_p=\frac{D}{v}=\frac{2*10^3m}{2*10^8m/s}=10^{-5}s  \mathrm{传播时延}</script><script type="math/tex; mode=display">d_{确认帧}=\frac{32bit}{10^7bit/s}=3.2*10^{-6}s</script><script type="math/tex; mode=display">T=d_t+2d_p+d_{确认帧}=5.12*10^{-5}s+2*10^{-5}s+3.2*10^{-6}s=7.44*10^{-5}s</script><script type="math/tex; mode=display">数据帧的净荷长度=512 bit - 32 bit = 480 bit</script><script type="math/tex; mode=display">有效数据传输速率=\frac{480bit}{7.44*10^{-5}s}\approx6.45*10^6m/s=6.45Mbps</script></blockquote><p>【分析】512bit中包含的32bit开销可能是头部信息，不算有效数据，和确认帧不是一回事。确认帧是从接收方发送回来的，所以总时间加上$d_{确认帧}$。<br>传播时间乘以2是因为信号需要从发送方传播到接收方，然后再从接收方传播回发送方。这个往返过程确保了在发送方和接收方之间有足够的时间来检测和处理可能发生的冲突。</p><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2024年终总结</title>
      <link>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/</link>
      <guid>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/</guid>
      <pubDate>Sun, 16 Mar 2025 05:57:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;已经是2025年的3月了，生活没那么容易，但也没那么难，有很多要做也正在做的事，过去的一年做了很多的探索。生活的表象都仿佛是对内心世界的度量，苦苦渴求却还没得到的，真的不如现在带有偏见却已经拥有的吗？还是说，这苦苦追逐的感觉根本不是我想要的，根本就不存在需要去追逐的外物，我</description>
        
      
      
      
      <content:encoded><![CDATA[<p>已经是2025年的3月了，生活没那么容易，但也没那么难，有很多要做也正在做的事，过去的一年做了很多的探索。生活的表象都仿佛是对内心世界的度量，苦苦渴求却还没得到的，真的不如现在带有偏见却已经拥有的吗？还是说，这苦苦追逐的感觉根本不是我想要的，根本就不存在需要去追逐的外物，我能拥有的，只有当下，那些求不得是否都不如求自己来得痛快……<br>不一样的感觉是从何而来的？是因为我看着事物的区别，我评价，我归类，我选择了其中之一，否定了另一个选择，循环往复……即便我选择了其一，另一种存在也无法凭空消失，我看不惯，我感到不适，我觉得不想要的在干扰我获得想要的……人生就是这样子的吗？不对的。</p><p><strong>我只能创造我想要的生活。</strong></p><p>得不到的，只能祛魅，必须祛魅。已经得到的，学会珍惜，学会发现它们对我的意义。在已有的基础之上，将梦想变为现实。</p><p>前段时间看到的一段话给了我很大的触动，大致是说，“人的欲望分为三种：努力追求而求不得的，努力追求而得到的，没有追求就得到的。”这三种情形的感受是大不相同的，而只有最后一种才是理想的状态。<br>我在2023年终总结中所写的“向内求”，似乎在过去的一年里一定程度的落实了，但还不够，因为我很多时候还会因为求不得而痛苦，不够强大的内心还需要修炼。<br>但是无论如何，相对而言是对自己满意的。过去一年的思考与积累，承受过的情绪波澜，让我在新的一年里，自我攻击越来越少了，面对困难寻求解决方案的执行力更强了，即便还没有做成什么事，我也珍惜此刻充实的生活。</p><p>几年间一直在心头回响的“我不想得到答案”，在潜意识里的愿望就是“我要自己找到答案”。<br>只有创造的过程是幸福的。去创造，无论是否够到达彼岸。<br>这是我对2025年的祈愿。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      
      <comments>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何在hexo-butterfly中画思维导图：Mermaid插件</title>
      <link>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/</link>
      <guid>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/</guid>
      <pubDate>Sat, 15 Mar 2025 13:06:55 GMT</pubDate>
      
      <description>mermaid在butterfly中的配置过程。</description>
      
      
      
      <content:encoded><![CDATA[<p>想要在hexo博客的markdown文档中添加思维导图（树状图/流程图）插件，问了下百度说有mermaid这个工具，发现butterfly的配置选项中自带mermaid。<br><a href="https://butterfly.js.org/posts/4aa8abbe">Butterfly 文檔(三) 主題配置</a>这篇教程说最好hexo要更新至7.0或以上版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --version</span><br></pre></td></tr></table></figure><br>使用这个语句查了一下发现我的hexo版本是6.3.0，时间有限想先试试不更新的办法。</p><ol><li>先在_config.butterfly.yml文件配置mermaid：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">code_write:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li><li>在hexo的文件中配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">exclude_languages:</span> [<span class="string">&#x27;mermaid&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>在markdown文章中添加code：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```&quot;mermaid&quot;  (实际没有引号)</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[根节点] --&gt; B[子节点1]</span></span><br><span class="line"><span class="code">A --&gt; C[子节点2]</span></span><br><span class="line"><span class="code">B --&gt; D[子节点1.1]</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">&#123;% endmermaid %&#125; </span><br></pre></td></tr></table></figure>写法很怪，但在hexo没升级的情况下能生效。<br>效果如下：<br><pre class="mermaid">graph LR A[根节点] --> B[子节点1] A --> C[子节点2] B --> D[子节点1.1]</pre><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div> <img class="zy_img_shadow" src="/2025/03/15/LearnMermaid/../../../../album-doge/index/001-code.jpg" width="30%"><!--往上翻这么多层是因为编译后是按年月日分文件夹的--></li></ol><p>mermaid除了可以画思维导图、流程图以外，还可以画饼图等。<br>mermaid<a href="https://zhuanlan.zhihu.com/p/627356428">中文教程</a><br>mermaid<a href="https://mermaid.js.org/">官方文档</a></p><p>End.🐧</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Markdown/">Markdown</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13017 计算机网络与信息安全——主观题</title>
      <link>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/</link>
      <guid>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/</guid>
      <pubDate>Tue, 25 Feb 2025 14:03:59 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;共十一章&lt;/p&gt;
&lt;h2 id=&quot;一、计算机网络与信息安全概述&quot;&gt;&lt;a href=&quot;#一、计算机网络与信息安全概述&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络与信息安全概述&quot;&gt;&lt;/a&gt;一、计算机网络与信息安全概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;大纲</description>
        
      
      
      
      <content:encoded><![CDATA[<p>共十一章</p><h2 id="一、计算机网络与信息安全概述"><a href="#一、计算机网络与信息安全概述" class="headerlink" title="一、计算机网络与信息安全概述"></a>一、计算机网络与信息安全概述</h2><p><strong>大纲知识点</strong></p><ol><li><p>什么是计算机网络？</p><blockquote><p>计算机网络是计算机技术与通信技术相互融合的产物。<br>计算机网络是利用通信设备与通信链路或者通信网络，互连位置不同、功能自治的计算机系统，并遵循一定的规则实现计算机系统之间信息交换的系统。<br>计算机网络是互连的、自治的计算机的集合。<br>目前最大的、应用最广泛的计算机网络就是Internet（因特网）。</p></blockquote></li><li><p>网络协议的三要素是什么？每个要素的含义分别是什么</p><blockquote><p>语 法 （syntax）、语 义 （semantics） 和 时 序 （timing）。<br>语法定义实体之间交换信息的格式与结构。<br>语义定义实体之间交换的信息中需要发送哪些控制信息及其具体含义、接收端如何响应、差错处理机制。<br>时序也称为同步，定义实体之间交换信息的顺序以及如何匹配或适应彼此的速度。</p></blockquote></li><li><p>按网络覆盖范围划分，主要有哪几类计算机网络？它们各有什么特点？</p><blockquote><p>按网络覆盖范围分类，计算机网络可以分为以下4 类：<br>( 1 ) 个域网：通常是由个人设备通过无线通信技术构成小范围的网络，实现个人设备间的数据传输，比如蓝牙。覆盖范围为1~10 m。<br>( 2 ) 局域网：通常部署在办公楼、校园等局部区域内，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。通常覆盖范围为10 m~1km。<br>( 3 ) 城域网：指覆盖一个城市范围的网络，覆盖范围通常为5~50km 。<br>( 4 ) 广域网：可以实现异地城域网或局域网的互连，覆盖范围在几十到几千公里。</p></blockquote></li><li><p>按网络拓扑划分，主要有哪几类计算机网络？它们各有什么特点？</p><blockquote><p>按照拓扑分类，计算机网络可以分为星形拓扑、总线型拓扑、环形拓扑、网状拓扑、树形拓扑和混合拓扑等。<br>( 1 ) 星形拓扑：包括一个中央结点，网络中的主机通过点对点通信链路与中央结点连接。<br>( 2 ) 总线型拓扑：采用一条广播信道作为总线，所有结点均与总线连接，通过总线进行结点间的通信。<br>( 3 ) 环形拓扑：利用通信链路将所有结点连接成一个闭合的环，每个结点与环互通数据。<br>( 4 ) 网状拓扑：每个结点通过多条链路与不同的结点直接连接。<br>( 5 ) 树形拓扑：可以看作总线型拓扑或星形拓扑的扩展。常见通过级联星形拓扑网络中的中央结点构建树形拓扑网络。<br>( 6 ) 混合拓扑：由两种以上简单拓扑网络混合连接而成的网络。</p></blockquote></li><li><p>计算机网络结构主要包括哪几部分？每部分的主要功能分别是什么？</p><blockquote><p>现代计算机网络的结构包括网络边缘(networkedge)、接入网络(accessnetwork)与网络核心(networkcore)三部分。</p></blockquote></li></ol><h2 id="三、传输层服务与物议"><a href="#三、传输层服务与物议" class="headerlink" title="三、传输层服务与物议"></a>三、传输层服务与物议</h2><p><strong>大纲知识点</strong></p><ol><li><p>实现可靠数据传输的主要措施有哪些？这些措施主要用于解决哪些问题？</p><blockquote><p>实现可靠数据传输的主要措施包括差错检测、确认、重传、序号以及计时器等。<br>（1）差错检测：检测和纠正数据在传输过程中的比特错误差错。<br>（2）确认：解决数据丢失或传输错误的问题。<br>（3）重传：确保数据能够完整、准确地到达接收方。<br>（4）序号：解决数据包在传输过程中可能出现的乱序问题，确保数据按正确的顺序重组。<br>（5）计时器：防止数据丢失或确认信息延迟导致的传输失败。</p></blockquote></li><li><p>UDP与TCP是分别如何实现复用与分解的？</p><blockquote><p>（1）UDP的复用与分解<br>①复用：在发送端，UDP从多个进程收集数据报，并为每个数据报添加源端口号和目标端口号，然后将这些数据报发送到网络层。<br>②分解：在接收端，UDP根据报文段中的目标端口号将数据报分发到对应的套接字。UDP套接字由二元组（目标IP地址、目标端口号）标识。<br>③特点：UDP是无连接的，不维护连接状态，因此只通过端口号进行分解。如果多个数据报具有相同的目标端口号，它们会被分发到同一个套接字。<br>（2）TCP的复用与分解<br>①复用：在发送端，TCP从多个进程收集数据流，并为每个数据流添加源IP地址、源端口号、目标IP地址和目标端口号，然后将这些数据流发送到网络层。<br>②分解：在接收端，TCP根据报文段中的四元组（源IP地址、源端口号、目标IP地址、目标端口号）将数据流分发到对应的套接字。每个TCP连接都有一个唯一的套接字。<br>③特点：TCP是面向连接的，每个连接都有一个独立的套接字，即使多个连接使用相同的端口号，也可以通过源IP和源端口号区分。</p></blockquote></li><li><p>请画出TCP报文段结构，并简要说明各个字段的主要作用。<br><img src="/2025/02/25/LearnNet13017/1.png" width="70%"></p><blockquote><p>（1）源端口号标识发送该报文段的源端口；目的端口号标识发送该报文段的目的端口。<br>（2）序号是对每个应用层数据的每个字节的编号；确认序号是期望从对方接收数据的字节序号。<br>（3）首部长度指出TCP报文段的首部长度；保留字段留给今后使用；URG=1时，说明报文中有紧急数据；ACK=1时，确认序号字段有效；PSH=1时，会尽快将报文段中数据交付进程，而不再等缓存填满后再上交；RST=1时，表明TCP连接中出现严重差错，必须释放重连；SYN=1时，表明该TCP报文段是一个建立新连接请求控制段或同意建立新连接的确认段；FIN=1时，表明该TCP报文段的发送端数据已发送完毕，请求释放TCP连接；接收窗口字段表示愿意接收的应用层数据字节数量。<br>（4）校验和字段检验TCP伪首部、TCP报文段首部、数据；紧急指针只在URG=1时有效，指出在本TCP报文段中紧急数据共多少字节。<br>（5）选项字段放入最大报文长度等信息；填充字段取值全0，使首部长度是4B的整数倍。<br>（6）数据部分存放报文段的主要数据。</p></blockquote></li><li><p>TCP为何采用三次握手来建立连接？采用二次握手可以吗？为什么？</p><blockquote><p>TCP（传输控制协议）采用三次握手来建立连接，主要是为了确保连接的可靠性和防止错误连接的建立。<br>第一次握手：客户端发送一个带有SYN（同步）标志的报文到服务器，表示请求建立连接。<br>第二次握手：服务器收到客户端的SYN报文后，回复一个带有SYN和ACK（确认）标志的报文。其中，ACK是对客户端SYN报文的确认，而SYN表示服务器也准备好建立连接。<br>第三次握手：客户端收到服务器的SYN+ACK报文后，再发送一个带有ACK标志的报文给服务器，确认收到服务器的SYN+ACK报文，至此连接建立。<br>三次握手的主要作用：<br>（1）防止已失效的连接请求报文突然又传送到了服务端，因而产生错误；<br>（2）确保双方都具备发送和接收的能力；<br>（3）同步双方的初始序列号。<br>如果采用二次握手，会存在以下问题：<br>（1）无法防止已失效的连接请求报文；<br>（2）无法确认客户端的接收能力；<br>（3）无法同步初始序列号。</p></blockquote></li><li><p>请分别说明TCP建立连接与断开连接的过程，并给出主要状态转移过程。</p><blockquote><p>TCP建立连接的过程是通过三次握手来完成的。<br>第一次握手：客户端向服务器发送一个带有SYN标志的报文请求建立连接，客户端状态转移CLOSED → SYN-SENT；<br>第二次握手：服务器收到客户端的SYN报文后，回复一个带有SYN和ACK标志的报文，服务器状态转移LISTEN → SYN-RCVD；<br>第三次握手：客户端收到服务器的SYN+ACK报文后，发送一个带有ACK标志的报文给服务器，客户端状态转移SYN-SENT → ESTABLISHED，服务器收到客户端的ACK报文后状态转移SYN-RCVD → ESTABLISHED。<br>主要状态转移：<br>客户端：CLOSED → SYN-SENT → ESTABLISHED。<br>服务器：LISTEN → SYN-RCVD → ESTABLISHED。</p><p>TCP断开连接的过程是通过四次挥手来完成的。<br>第一次挥手：客户端向服务器发送一个带有FIN标志的报文，表示客户端已经完成数据发送，准备关闭连接，客户端状态转移ESTABLISHED → FIN-WAIT-1；<br>第二次挥手：服务器收到客户端的FIN报文后，回复一个带有ACK标志的报文，确认收到客户端的关闭请求，服务器状态转移ESTABLISHED → CLOSE-WAIT，客户端状态转移FIN-WAIT-1 → FIN-WAIT-2；<br>第三次挥手：服务器完成数据发送后，向客户端发送一个带有FIN标志的报文，表示服务器也准备关闭连接，服务器状态转移CLOSE-WAIT → LAST-ACK；<br>第四次挥手：客户端收到服务器的FIN报文后，回复一个带有ACK标志的报文，确认收到服务器的关闭请求，客户端状态转移FIN-WAIT-2 → TIME-WAIT，服务器状态转移LAST-ACK → CLOSED，客户端在TIME-WAIT状态等待2MSL后状态转移TIME-WAIT → CLOSED。<br>主要状态转移：<br>客户端：ESTABLISHED → FIN-WAIT-1 → FIN-WAIT-2 → TIME-WAIT → CLOSED。<br>服务器：ESTABLISHED → CLOSE-WAIT → LAST-ACK → CLOSED。</p></blockquote></li><li><p>TCP是如何保证可靠数据传输的？</p><blockquote><p>TCP的可靠数据传输实现机制包括差错编码、确认、序号、重传、计时器等。<br>（1）校验和：发送方和接收方验证校验和是否相同。不相同则数据传输有误，相同也可能有问题。<br>（2）确认应答：三次握手与四次挥手过程中通过比对Seq和ACK来实现。<br>（3）超时重传：发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。</p></blockquote></li><li><p>请分别简述GBN协议和SR协议的工作过程。</p><blockquote><p>GBN协议是一种滑动窗口协议，用于实现可靠的数据传输。其核心思想是发送方在未收到确认（ACK）之前可以连续发送多个数据分组，但一旦检测到超时或丢失，将重传所有未确认的分组。<br>SR协议也是一种滑动窗口协议，但与GBN协议不同，它允许接收方缓存失序到达的分组，并只重传丢失的分组。</p></blockquote></li><li><p>请说明TCP滑动窗口机制，并对比TCP滑动窗口与GBN协议的异同。<br><pre class="mermaid">graph LR A[传输层TCP如何实现可靠传输] --> B[停-等协议] A --> C[滑动窗口协议] C --> D[GBN协议] C --> E[SR议]</pre></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div> <blockquote><p>TCP滑动窗口机制是一种用于流量控制和拥塞控制的技术，允许发送方在等待确认之前连续发送多个数据段。其核心原理如下：</p><ol><li>发送窗口与接收窗口：<br>发送方维护一个发送窗口，表示可以发送但尚未被确认的数据范围。<br>接收方维护一个接收窗口，表示可以接收的数据范围。<br>窗口大小动态调整，取决于接收方的处理能力和网络拥塞情况。</li><li>窗口滑动：<br>当发送方收到接收方的确认（ACK）时，窗口向前滑动，允许发送更多数据。<br>如果接收方缓冲区已满，窗口大小会减小，甚至变为0，发送方暂停发送。</li><li>确认机制：<br>TCP使用累积确认，接收方确认的是已正确接收的最高序号数据。<br>如果数据丢失，发送方会根据确认信息重传丢失的数据。</li><li>动态调整：<br>TCP的滑动窗口大小不是固定的，而是根据网络状况和接收方的接收能力动态调整。<br>窗口大小的调整涉及接收窗口（rwnd）和拥塞窗口（cwnd），实际发送窗口大小为两者的最小值。</li></ol><p>TCP滑动窗口与GBN协议的相同点：</p><ol><li>基于滑动窗口协议：TCP和GBN都使用滑动窗口机制来提高数据传输效率。</li><li>单个计时器：TCP和GBN都使用单个计时器来监控最早未被确认的数据段。</li><li>按序确认：TCP和GBN都要求接收方按序接收数据，接收方只确认按序到达的数据。</li></ol><p>TCP滑动窗口与GBN协议的不同点：</p><ol><li>接收窗口大小：TCP滑动窗口：动态调整，取决于接收方缓冲区容量。GBN协议：固定为1。</li><li>重传机制：TCP滑动窗口：选择性重传丢失的数据段。GBN协议：重传从丢失数据段开始的所有后续数据段。</li><li>对失序数据的处理：TCP滑动窗口：接收方缓存失序数据。GBN协议：接收方丢弃失序数据。</li><li>窗口大小限制：TCP滑动窗口：动态调整，无固定上限。GBN协议：最大为 2^n−1（n为序列号比特数）。</li><li>传输效率：TCP滑动窗口：高，支持选择性重传和缓存失序数据。GBN协议：较低，重传数据量可能较大。</li></ol></blockquote></li><li><p>TCP与UDP的主要区别是什么？</p><blockquote><ol><li>连接性：TCP：面向连接的协议。<font color="silver">（三次握手）</font>UDP：无连接的协议。</li><li>可靠性：TCP：提供可靠的数据传输<font color="silver">（确认-重传机制）</font>UDP：不保证数据包的可靠传输。</li><li>顺序性：TCP：保证数据包按顺序到达。UDP：不保证数据包的顺序。</li><li>流量控制：TCP：提供流量控制机制。UDP：没有流量控制机制。</li><li>拥塞控制：TCP：具有拥塞控制机制。UDP：没有拥塞控制机制。</li><li>应用场景：TCP：适用于需要可靠传输的应用，如 Web 浏览（HTTP）、文件传输（FTP）、电子邮件（SMTP）等。UDP：适用于对传输速度要求高、可以容忍一定丢包率的应用，如实时视频/音频传输、在线游戏、DNS 查询等。</li></ol></blockquote></li><li><p>TCP是如何实现拥塞控制的？</p><blockquote><p>TCP拥塞控制是通过合理调度、规范、调整向网络中发送数据的主机数量、发送速率或数据量，以避免拥塞或尽快消除已发生的拥塞。<br>拥塞控制策略可以分为拥塞预防与拥塞消除两大类。<br>拥塞预防是通过采取一些技术预防拥塞的发生，如流量整形技术<br>拥塞消除是利用拥塞检测机制检测网络中是否发生拥塞，然后通过某种方法消除已发生的拥塞。<br>根据拥塞检测机制的不同，拥塞控制又可以分为基于拥塞状态反馈的拥塞控制方法和无须拥塞状态反馈的拥塞控制方法。<br>TCP的拥塞控制是从端到端的角度，推测网络是否发生拥塞，如果推断网络发生拥塞，则立即将数据发送速率降下来，以便缓解网络拥塞。<br>TCP拥塞控制的基本思想是AIMD。<br>TCP的拥塞控制采用的也是窗口机制，通过调节窗口的大小实现对发送数据速率的调整。窗口调节的基本策略是网络未发生拥塞时，逐渐“加性”增大窗口大小，当网络拥塞时，“乘性”快速减小窗口大小，<br>TCP拥塞控制窗口的调节分为慢启动阶段和拥塞避免阶段，慢启动阶段窗口从一个MSS快速增长，达到某个阈值后转为拥塞避免阶段；拥塞避免阶段的窗口增长放慢。</p><p>【简洁版】</p><ol><li>慢启动：开始时，拥塞窗口设置为一个较小的值（通常为1个MSS）。每当收到一个ACK，拥塞窗口就增加一个MSS，呈指数增长，直到达到慢启动阈值。</li><li>拥塞避免：当拥塞窗口超过慢启动阈值时，TCP进入拥塞避免阶段。拥塞窗口的增长速度变慢，每次收到ACK时，拥塞窗口增加1，呈线性增长。</li><li>快速重传：当发送方收到三个重复的ACK时，它会立即重传丢失的数据包，而不是等待重传定时器超时。</li><li>快速恢复：快速恢复算法与快速重传配合使用，用于在发生数据包丢失后快速调整拥塞窗口。</li><li>拥塞窗口调整：当发生丢包时，TCP会调整拥塞窗口的大小，以减少网络拥塞。</li></ol></blockquote></li></ol><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><ol><li><p>网络层提供的主要功能是什么？</p><blockquote><p>转发、路由以及连接管理。<br>（1）转发：通过一条输入链路收到分组后，决策选哪条输出链路发送分组，将分组从输入接口转到输出接口。<br>（2）路由：按照路由选择算法决定分组经过的路径。<br>（3）连接管理：建立从源主机到目标主机的一条路径，这条路径经过的每个路由器等网络设备都要参与网络层连接的建立。</p></blockquote></li><li><p>转发和路由的含义是什么？它们之间有什么区别和联系？</p><blockquote><p>（1）转发：通过一条输入链路收到分组后，决策选哪条输出链路发送分组，将分组从输入接口转到输出接口。<br>（2）路由：按照路由选择算法决定分组经过的路径。<br>区别和联系：<br>（1）作用范围：转发是局部的，发生在单个网络设备内部；路由是全局的，涉及整个网络的路径选择。<br>（2）决策依据：转发基于转发表（如MAC地址表或路由表）；路由基于网络拓扑和路由协议。<br>（3）功能层次：转发可以看作是路由决策的执行部分，即路由决定路径，转发执行路径上的传输。</p></blockquote></li><li><p>简述虚电路网络和数据报网络各自的优缺点。</p><blockquote><p>虚电路网络（如X.25, Frame Relay, MPLS）<br>优点：<br>（1）可靠性：在数据传输前建立连接，确保数据传输的可靠性。<br>（2）有序传输：数据包按照发送顺序到达目的地。<br>（3）流量控制：提供流量控制机制，避免拥塞。<br>（4）错误检测：能够检测和纠正传输过程中的错误。<br>（5）带宽保证：为每个连接提供一定的带宽保证。<br>缺点：<br>（1）建立延迟：需要时间来建立连接，对于突发性数据传输不够灵活。<br>（2）资源占用：即使没有数据传输，也需要占用网络资源以维持连接。<br>（3）不够灵活：对于动态变化的网络条件适应性较差。<br>数据报网络（如IP）<br>优点：<br>（1）灵活性：不需要建立连接，数据包可以独立选择路由。<br>（2）动态路由：能够适应网络拓扑的变化，动态选择最佳路径。<br>（3）资源效率：只在有数据传输时占用网络资源。<br>（4）可扩展性：适合大规模网络，易于扩展。<br>（5）适应性：能够适应各种类型的网络服务和应用。<br>缺点：<br>（1）无序传输：数据包可能不按发送顺序到达，需要应用层处理。<br>（2）无流量控制：可能导致网络拥塞，需要应用层或传输层协议来控制。<br>（3）错误处理：错误检测和纠正通常由应用层或传输层协议处理。<br>（4）无带宽保证：不能保证数据传输的带宽，可能导致延迟和抖动。<br>总的来说，虚电路网络更适合需要可靠、有序传输的应用，而数据报网络则更适合需要灵活性和动态路由的应用。在实际应用中，根据具体需求选择合适的网络模型是非常重要的。</p></blockquote></li><li><p>虚电路网络如何建立虚电路？虚电路网络分组转发的依据是什么？</p><blockquote><p>通信之前，双方需要先建立虚电路，通信结束后再拆除虚电路。虚电路是在源主机到目的主机的一条路径上建立的一条网络层逻辑连接，为区别于电路交换中的电路，称之为虚电路。电路交换网络在建立每条电路时，网络会为电路分配独享资源，沿某条电路传输的数据，只占用分配给该电路的资源。<br>虚电路网络设备根据分组所携带的VCID判断其所属的虚电路，从而决策如何转发分组。</p></blockquote></li><li><p>实现异构网络互连的主要方法有哪些？实现异构网络互连的典型网络设备是什么？</p><blockquote><p>异构网络主要是指两个网络的通信技术和运行协议的不同。<br>实现异构网络互连的基本策略主要包括协议转换和构建虚拟互联网络。<br>（1）协议转换机制采用一类支持异构网络之间的协议转换的网络中间设备，实现异构网络之间数据分组的转换与转发。<br>（2）通过构建虚拟互联网络机制的异构网络互连是在现有异构网络基础上，构建一个同构的虚拟互联网络，异构网络均只需要封装、转发虚拟互联网络分组，同时引入虚拟互联网中间设备互连异构网络，实现在异构网络间转发统一的虚拟互联网的数据分组。<br>用来连接网络的设备多种多样，包括中继器、集线器、交换机、网桥、路由器和网关<br>等。</p></blockquote></li><li><p>路由器有哪些部分组成？各部分的主要功能是什么？</p><blockquote><p>路由器可以分为输入端口、交换结构、输出端口与路由处理器。<br>（1）输入端口负责从物理接口接收信号，还原数据链路层帧，提取IP数据报（或其他网络层协议分组），根据IP数据报的目的IP地址检索路由表，决策需要将该债数据报交换到哪个输出端口。<br>（2）交换结构将输入端口的田数据报交换到指定的输出端口。<br>（3）输出端口首先提供一个缓存排队功能，排队交换到该端口的待发送分组，并从队列中不断取出分组以进行数据链路层数据帧的封装，通过物理线路端接发送出去。<br>（4）路由处理器就是路由器的CPU，负责执行路由器的各种指令，包括路由协议的运行、路由计算以及路由表的更新维护等。</p></blockquote></li><li><p>网络层出现拥塞的原因是什么？有哪些网络层拥塞控制策略？</p><blockquote><p>在分组交换网中，由于众多用户随机地将信息送入网络，使网络中需要传输的信息总量经常大于其传输能力，以致某些网络结点（如路由器）因缓冲区已满，无法接收新到达的分组，此时就发生了拥塞现象。<br>四种原因：<br>（1）缓冲区容量有限。<br>（2）传输线路的带宽有限。<br>（3）网络结点的处理能力有限。<br>（4）网络中某些部分发生了故障。<br>措施：<br>（1）流量感知路由：【拥塞预防】链路费用（边的权值）根据网络负载动态调整，则可以将网络流量引导到不同的链路上，均衡网络负载，从而延缓或避免拥塞的发生。<br>（2）准入控制：【拥塞预防】如果新建立的虚电路会导致网络变得拥塞，那么网络拒绝建立该新虚电路。<br>（3）流量调节：【拥塞消除】通过调整发送方向网络发送数据的速率来消除拥塞。<br>（4）负载脱落：【拥塞消除】有选择地主动丢弃一些数据报，减轻网络负载，从而缓解或消除拥塞。</p></blockquote></li><li><p>一个新加入到网络中的主机需要发送DHCP请求来获取一个可用的IP地址，为什么DHCP请求要以广播的形式发送出去？当某台DHCP服务器接收到一台主机的DHCP请求时，会返回一个DHCP响应，为什么DHCP响应也要以广播的形式发送出去？</p><blockquote><p>DHCP（动态主机配置协议）是一种网络协议，用于自动分配IP地址给网络中的主机。<br>DHCP请求以广播形式发送的原因：（1）未知的DHCP服务器地址；（2）可能存在多个DHCP服务器；（3）简化配置；（4）快速发现。<br>DHCP响应以广播形式发送的原因：（1）未知的客户端地址；（2）确保可达性；（3）避免地址冲突；（4）简化DHCP服务器逻辑。</p></blockquote></li><li><p>简述ICMP的主要功能。</p><blockquote><p>ICMP互联网控制报文协议：主要目的是在主机或路由器间实现差错信息报告。<br>ICMP通过发送ICMP报文，实现差错报告或网络探询功能。因此ICMP报文分为差错报告报文和询问报文两大类。</p></blockquote></li><li><p>说明NAT的工作原理，如何实现NAT穿透？</p><blockquote><p>NAT（网络地址转换）原理：对于从内网出去，进入公共互联网的密数据报，将其源IP地址替换为NAT服务器拥有的合法的公共I P地址，同时替换源端口号，并将替换关系记录到NAT转换表中；对于从公共互联网返回的我数据报，依据其目的IP地址与目的端口号检索NAT转换表，并利用检索到的内部私有IP地址与对应的端口号替换目的IP地址和目的端口号，然后将IP数据报转发到内部网络。<br>NAT穿透技术就是在外网主机主动与内网主机发起通信之前，先在NAT转换表中建立好内网到外网的映射，使内网运行的服务以NAT公网地址的“合法”身份“暴露”出去。</p></blockquote></li><li><p>IPv6提出的动机是什么？相比于加IPv4，IPv6的数据报格式有什么特点？</p><blockquote><p>IPv4地址即将耗尽，NAT只能过渡缓解这个问题，所以提出了IPv6，在地址长度上进行了扩展。<br>（1）简化的报头结构：IPv6简化了报头结构，去除了IPv4中一些不常用的字段。<br>（2）更大的地址空间：IPv6使用128位地址，而IPv4使用32位地址，这意味着IPv6可以提供比IPv4更大的地址空间。<br>（3）固定长度的报头：IPv6基本首部长度为固定的40字节。<br>（4）分片与重组：IPv6规定分片与重组只能在源与目的地上执行，不允许在中间路由器进行，这大大加快了网络中的IP转发速率。</p></blockquote></li></ol><p><img src="/2025/02/25/LearnNet13017/IPv4.png" width="70%"><br><img src="/2025/02/25/LearnNet13017/IPv6.png" width="70%"></p><ol><li><p>简述链路状态路由选择算法与距离向量路由选择算法的实现过程。</p><blockquote><p>链路状态路由选择算法的实现过程：<br>（1）发现邻居：当一个路由器启动时，它首先发现邻居，并向邻居发送“hello”消息。<br>（2）计算链路状态：然后计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离。<br>（3）广播链路状态包：将自身和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。<br>（4）构建拓扑图：每个路由器都能在自己本地构建一个完整的图。<br>（5）计算最短路径：针对这个图使用Dijkstra算法，找到两点之间的最短路径。<br>距离向量路由选择算法的实现过程：<br>（1）初始化路由表：每个路由器初始化自己的路由表，将所有目标网络的最短距离设置为无穷大，除了直接相连的网络。<br>（2）路由信息交换：路由器定期向邻居路由器发送自己的路由表信息。<br>（3）更新路由表：每个路由器根据收到的邻居路由表信息，计算到达目标网络的最短距离，并更新自己的路由表。<br>（4）收敛：当所有路由器的路由表不再发生变化时，整个网络达到收敛状态。</p></blockquote></li><li><p>为什么距离向量路由选择算法可能产生无穷计数问题？请举例说明。可以采取哪些措施来避免这一问题？</p><blockquote><p>当两个或多个路由器试图通过更新彼此的路由信息来找到到达某个目的地的最短路径时，它们可能会错误地不断增加到达该目的地的距离（或“跳数”），导致距离变得无限大。<br>措施：<br>（1）水平分割：它规定路由器不能将从某个接口学到的路由信息再通过同一个接口发送出去。<br>（2）毒性逆转：不仅阻止了路由信息的循环，还将该信息以无穷大的距离发送回相邻路由器，明确告知对方该路由不可达。<br>（3）触发更新：网络拓扑发生变化时，立即发送更新信息，而不是等待常规的更新周期。<br>（4）路由抑制：当检测到一个不可达的网络时，将其距离设置为无穷大，并通知所有相邻路由器。</p></blockquote></li><li><p>简述RIP、OSPF和BGP的异同。</p><blockquote><p>RIP（路由信息协议）、OSPF（开放最短路径优先）和BGP（边界网关协议）是三种常见的路由协议，它们在网络中扮演着重要的角色，但各自有不同的特点和应用场景。<br>RIP是一种基于距离向量的路由协议，它通过跳数来衡量路径的优劣。<br>OSPF是一种基于链路状态的内部网关协议，专为自治系统（AS）内部设计。<br>BGP是一种外部网关协议，主要用于自治系统间的路由选择。<br>（1）RIP和OSPF主要用于单一自治系统内部的路由选择，而BGP用于不同自治系统间的路由发布与选择。<br>（2）RIP基于距离向量算法，OSPF基于链路状态算法，BGP基于路径向量算法。<br>（3）OSPF和BGP通常具有更快的收敛速度，而RIP的收敛速度较慢。</p></blockquote></li></ol><h2 id="五、数据链路层"><a href="#五、数据链路层" class="headerlink" title="五、数据链路层"></a>五、数据链路层</h2><ol><li><p>信道使用的协议<br><pre class="mermaid">graph LR A[数据链路层的信道类型] --> B[点对点信道] A --> C[广播信道] C --> D[多路访问控制协议MAC] D --> E[信道划分MAC协议] D --> F[随机访问MAC协议] D --> G[受控接入MAC协议] E --> E0[多路复用技术] E0 --> E1[频分多路复用FDM] E0 --> E2[时分多路复用TDM] E0 --> E3[波分多路复用WDM] E0 --> E4[码分多路复用CDM] E2 --> E21[同步STDM] E2 --> E22[异步ATDM/统计STDM] E3 --> E31[密集波分复用技术DWDM] F --> F1[ALOHA协议] F --> F2[载波监听] F --> F3[带冲突检测的载波监听]</pre></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div> <p>多路复用技术的目的是实现信道共享。</p></li><li><p>数据链路层协议能够向网络层提供哪些可能的服务？</p><blockquote><p>（1）组帧：数据链路层一般会将要传输的数据封装成帧。<br>（2）链路接入：发送结点和接收结点独占通信链路，只要链路处于空闲状态，就可以随时使用链路发送和接收帧。<br>（3）可靠交付：可以在相邻结点间经数据链路实现数据报的可靠传输。<br>（4）差错控制：确保出现差错的帧不再被处理和继续传输。<br>（5）流量控制：两个相邻结点间帧的发送和接收处理速度，避免接收方被数据淹没。</p></blockquote></li><li><p>为什么有些网络用纠错码而不用检错和重传机制？请给出两个理由。</p><blockquote><p>（1）不需要发送方重发数据：纠错码允许接收方利用数据中的冗余信息检测并纠正传输中发生的错误，不需要发送方重发数据，节省了网络资源和时间。<br>（2）提高数据传输效率：使用纠错码可以减少因为错误而导致的数据重传。</p></blockquote></li><li><p>差错编码的检错或纠错能力与什么有关？试举例说明。</p><blockquote><p>（1）编码冗余度：指编码中用于错误检测和纠正的额外位数。冗余度越高，编码的检错和纠错能力通常越强。<br>（2）编码方法：不同的编码方法具有不同的检错和纠错能力。如：奇偶校验码，汉明码。<br>（3）错误模式：检错和纠错能力还取决于错误发生的模式。<br>（4）编码复杂度：编码的复杂度也会影响其检错和纠错能力。</p></blockquote></li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL逐行累加——实现账目余额报表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</guid>
      <pubDate>Thu, 20 Feb 2025 14:52:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;惊艳了同事的sum over语法~(✧◡✧)&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </description>
        
      
      
      
      <content:encoded><![CDATA[<p>惊艳了同事的sum over语法~(✧◡✧)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(colA) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> colB <span class="keyword">order</span> <span class="keyword">by</span> colC) <span class="keyword">from</span> temp</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL递归语法——读取树形结构表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</guid>
      <pubDate>Thu, 20 Feb 2025 14:44:48 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--recursive + inner join</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> temp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> class_id,mother_id,class_id::text <span class="keyword">as</span> path, class_name <span class="keyword">from</span> item_class <span class="comment">--and class_id=123</span></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> iic.class_id,iic.mother_id,iic.class_id::text<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.path <span class="keyword">as</span> path, iic.class_name<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.class_name <span class="keyword">as</span> class_name <span class="keyword">from</span> item_class iic <span class="keyword">inner</span> <span class="keyword">join</span> temp <span class="keyword">on</span> temp.mother_id<span class="operator">=</span>iic.class_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;/&#x27;</span>,path,<span class="string">&#x27;/&#x27;</span>) <span class="keyword">as</span> path, class_name,split_part(path,<span class="string">&#x27;/&#x27;</span>,LENGTH(path) <span class="operator">-</span> LENGTH(REPLACE(path, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>))<span class="operator">+</span><span class="number">1</span>) <span class="keyword">as</span>  class_id <span class="keyword">from</span> temp <span class="keyword">where</span> mother_id<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> <span class="built_in">position</span>(<span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> path)<span class="operator">&gt;</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13015 计算机系统原理</title>
      <link>https://pearlchocolatezy.com/2025/02/15/LearnCO/</link>
      <guid>https://pearlchocolatezy.com/2025/02/15/LearnCO/</guid>
      <pubDate>Sat, 15 Feb 2025 13:02:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;1&amp;#39;*10=10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*10=20&lt;/code&gt;&lt;br&gt;名词解释：&lt;code&gt;3&amp;#39;*2=6&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;6&amp;#39;*4=24&lt;/code&gt;&lt;br&gt;综合计算题：&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>1&#39;*10=10</code><br>填空题：<code>2&#39;*10=20</code><br>名词解释：<code>3&#39;*2=6</code><br>简答题：<code>6&#39;*4=24</code><br>综合计算题：<code>10&#39;*4=40</code></p><p>共六章</p><h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h3 id="一-1-计算机基本工作原理"><a href="#一-1-计算机基本工作原理" class="headerlink" title="一/1 计算机基本工作原理"></a>一/1 计算机基本工作原理</h3><h3 id="一-2-程序的开发与运行"><a href="#一-2-程序的开发与运行" class="headerlink" title="一/2 程序的开发与运行"></a>一/2 程序的开发与运行</h3><h3 id="一-3-计算机系统的层次结构"><a href="#一-3-计算机系统的层次结构" class="headerlink" title="一/3 计算机系统的层次结构"></a>一/3 计算机系统的层次结构</h3><h3 id="一-4-计算机系统性能评价"><a href="#一-4-计算机系统性能评价" class="headerlink" title="一/4 计算机系统性能评价"></a>一/4 计算机系统性能评价</h3><p><strong>大纲知识点</strong></p><ol><li>名词解释<br>（1）中央处理器（CPU）：控制部件、运算部件和各类寄存器互连组成的电路。<br>（2）算术逻辑部件（ALU）：用来进行算术逻辑运算的部件。<br>运算器的核心部件是<i id="answer1_6" class="answer" onclick="showOrHide('1_6')">算术逻辑运算单元</i>。 <mark class="hl-label default">（2024-10TK 1'）</mark> <br>（3）通用寄存器：用于临时存放从主存取来的数据或运算的结果。<br>（4）程序计数器（PC）：CPU 为了自动按序读取主存中的指令，需要程序计数器 , 在执行当前指令的过程中，自动计算出下一条指令的地址并送到PC中保存。<br>（5）指令寄存器（IR）：用于临时保存从主存取来的指令。<br>（6）控制器：用于自动逐条取出指令并进行译码的部件。<br>（7）主存储器：用来存放指令和数据的部件。<br>（8）总线：连接不同部件进行信息传输的介质。<br>（9）主存地址寄存器（MAR）：CPU送到地址线的主存地址先存放的位置。<br>（10）主存数据寄存器（MDR）：发送到或从数据线取来的信息存放的位置。<br>（11）机器指令：计算机能理解和执行的，用0和1表示的一串0/1序列。<br>（12）指令操作码：计算机指令中用于指示CPU执行特定操作的部分。<br>（13）高级程序设计语言：是指面向算法设计的、较接近于日常英语书面语言的程序设计语言，如C、Java等。<br>（14）汇编语言：通过用简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序。<br>（15）机器语言：使用特定计算机规定的指令格式而形成的0/1序列。<br>（16）机器级语言：是计算机硬件能够直接理解和执行的低级语言，它是计算机指令的最底层表示形式，由一系列二进制代码组成，这些代码直接对应计算机硬件的操作指令。<br>（17）源程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，被翻译的程序为源程序。<br>（18）目标程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，翻译生成的程序为目标程序。<br>（19）编译程序：也称编译器。用于将高级语言源程序翻译成汇编语言或机器语言目标程序。<br>（20）解释程序：也称解释器。用于将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行。<br>（21）汇编程序：也称汇编器。用于将汇编语言源程序翻译成机器语言目标程序。<br>（22）语言处理系统：提供程序编辑器和各类翻译转换软件的工具包。<br>（23）设备控制器：I/0控制器或I/0适配器统称为设备控制器，用于连接外设到主机。<br>（24）最终用户：使用应用软件完成特定任务的计算机用户。<br>（25）系统管理员：是指利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护，以建立高效合理的系统环境供计算机用户使用的操作人员。<br>（26）应用程序员：是指使用高级编程语言编制应用软件的程序员。<br>（27）系统程序员：指设计和开发系统软件的程序员。<br>（28）指令集体系结构（ISA）：是软件和硬件之间接口的一个完整定义。<br>（29）微体系结构：实现ISA的电路逻辑结构。<br>（30）透明：在计算机技术中，一个存在的事物或概念从某个角度看似乎不存在，即对实际存在的事物或概念感觉不到。<br>（31）响应时间：指从作业提交开始到作业完成所用的时间。<br>（32）吞吐率：在单位时间内所完成的工作量。<br>（33）用户CPU时间：指真正用于运行用户程序代码的时间。<br>（34）时钟周期：CPU主脉冲信号（计算机产生的同步的时钟定时信号）的宽度。<br>（35）主频：CPU主脉冲信号的时钟频率，是CPU时钟周期的倒数。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> <br>（36）CPI：执行一条指令所需的时钟周期数。<br>（37）基准程序：是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。<br>（38）MIPS：指令速度所用的计量单位，含义是平均每秒钟执行多少百万条指令。<br>（39）峰值MIPS：选取一组指令组合，使 得 得 到 的 平 均 C P I最小，由此得到的MIPS是峰值MIPS。<br>（40）相对MIPS：根据某个公认的参考机型来定义的相应MIPS值，是被测机型相对于参考机型MIPS的倍数。<br>（41）MFLOPS：每秒所执行的浮点运算有多少百万次。<br>（42）GFLOPS：每秒所执行的浮点运算有多少$10^9$次。<br>（43）TFLOPS：每秒所执行的浮点运算有多少$10^{12}$次。<br>（44）PFLOPS：每秒所执行的浮点运算有多少$10^{15}$次。<br>（44）EFLOPS：每秒所执行的浮点运算有多少$10^{18}$次。</li><li>简答<br>（1）冯・ 诺依曼计算机由哪几部分组成？各部分的功能是什么？<blockquote><p>计算机由运算器、控制器、存储器、输入设备和输出设备五大基本部件组成。<br>运算器能进行基本算术和逻辑运算。<br>控制器应能自动执行指令。<br>存储器能存放数据和指令。<br>操作人员可以通过输入输出设备使用计算机。</p></blockquote></li></ol><p>（2）什么 是 “存储程序”工作方式？</p><blockquote><p>必须将事先编好的程序和原始数据送入主存后才能执行程序，一旦程序被启动执行，计算机不需要操作人员干预就能自动完成逐条指令取出和执行的任务。</p></blockquote><p>（3）一条指令的执行过程包含哪几个阶段？</p><blockquote><p>从主存取指令→对指令进行译码→PC增量→取操作数并执行→将结果送至主存或寄存器保存。</p></blockquote><p>（4）计算机系统的层次结构如何划分？</p><blockquote><p>计算机系统由硬件和软件两大部分所构成。<br>硬件是物理装置的总称。<br>软件包括操作系统、编程语言、算法和应用。<br>指令体系结构ISA作为软件与硬件之间的桥梁，提供软件与硬件接口的完整定义。<br>计算机系统的层次结构共分为五级:<br>第1级：微程序设计级,这是一个实际存在的硬件级,由硬件直接执行微指令。<br>第2级：机器语言级,它由微程序解释机器指令系统,该级也属于硬件级。<br>第3级：操作系统级,该级采用机器语言解释执行,既涉及软件资源,也涉及硬件资源,即在操作系统的控制之下调用系统的硬件与软件资源。<br>第4级：汇编语言级,这一级用汇编程序支持和执行。<br>第5级：高级语言级,这一级由各种高级语言编译程序支持和执行,它是面向用户的,所编写的程序称之为用户程序,这一级属于软件级。</p></blockquote><p>（5）计算机系统的用户可分为哪几类？每类用户工作在哪个层次？</p><blockquote><p>按照在计算机上完成任务的不同，可以把使用计算机的用户分成以下4 类 ：最终用户、<br>系统管理员、应用程序员和系统程序员。<br>① 最终用户：使用应用软件完成特定任务。<br>② 系统管理员：利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护。<br>③ 应用程序员：使用高级编程语言编制应用软件的程序员。<br>④ 系统程序员：设计和开发系统软件的程序员，工作在机器语言级。</p></blockquote><p>（6）程序的CPI与哪些因素有关？</p><blockquote><p>CPI：表示执行一条指令所需的时钟周期数。<br>影响 CPI 的因素主要包括：硬件设计（CPU 架构、缓存机制），指令集架构（ISA），程序特性，系统软件。</p></blockquote><p>（7）为什么说性能指标MIPS不能很好地反映计算机的性能？</p><blockquote><p>MIPS：其含义是平均每秒钟执行多少百万条指令。反映了机器执行定点指令的速度。<br>① 有些制造商经常将峰值MIPS直接当作MIPS , 而实际上的性能要比标称的性能差。<br>② 不同机器的指令集不同，指令的功能也不同，因此，同样的指令条数所完成的功能可能不同。<br>③ 不同机器的 CPI 和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。</p></blockquote><ol><li>应用题<br>（1）假定你的朋友不太懂计算机，请用简单通俗的语言给你的朋友介绍计算机系统是如何工作的。<blockquote><p>计算机系统主要由两部分组成：硬件和软件。<br>硬件：就是计算机的实体部分，如机箱、处理器。<br>软件：就是各种程序和指令，如操作系统、游戏软件。<br>计算机的工作可以简单地分为三个步骤：输入、处理和输出。<br>输入就是用键盘等输入设备把信息传递给计算机，这些信息就像是你给计算机的“指令”。<br>处理：计算机接收到输入的信息后，它会用“大脑”来处理这些信息，计算机的“大脑”主要是CPU（中央处理器）。CPU会从内存中读取需要处理的数据，按照软件的指令进行计算。<br>输出：处理完之后，计算机就会把结果输出给你，比如显示在屏幕上的文字、播放音乐。<br>软件是计算机的灵魂，它告诉硬件该做什么。<br>计算机通过硬件和软件的配合，能够快速、高效地完成各种复杂的任务。</p></blockquote></li></ol><p><strong>真题</strong></p><ol><li>冯·诺依曼计算机工作方式的基本特点：<br>（1）“存储程序”工作方式 <mark class="hl-label default">（2024-10XZ 1'）</mark> <br>（2）计算机由五大部件组成：<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">运算器</i>、<i id="answer1_2" class="answer" onclick="showOrHide('1_2')">控制器</i>、<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">存储器</i>、<i id="answer1_4" class="answer" onclick="showOrHide('1_4')">输入设备</i>、<i id="answer1_5" class="answer" onclick="showOrHide('1_5')">输出设备</i>。<br>（3）存储器能存放数据和指令；<br>控制器能自动执行指令；<br>运算器能进行基本算术和逻辑运算；<br>操作人员可以通过I/O设备使用计算机<br>（4）计算机内部以二进制形式表示指令和数据；<br>每条指令=操作码+地址码+…，操作码指出操作类型，地址码指出操作数的地址；<br>由一串指令组成程序。</li></ol><h2 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><p><strong>书本知识点</strong></p><ol><li>整数用<mark class="hl-label blue">定点数</mark> 表示，实数用<mark class="hl-label blue">浮点数</mark> 表示。<br>机器数：计算机内部编码表示的数。一定是一个0/1序列（常缩写为16进制形式）。（X）<br>真值：机器数真正的值。（$X_T$）<br>定点数有四种编码表示方法：原码、补码、反码、移码。它们都是机器数。<br>（其中移码既可以表示整数，也可以表示小数）<br>它们的值都由符号位（最高位）和数值位组成。原码、补码、反码的符号位正数由0表示，负数由1表示。</li></ol><p>（1）原码<br>符号位：最高位为符号位，0表示正数，1表示负数。<br>数值位：其余位表示数值的绝对值。<br>（2）反码<br>符号位：最高位为符号位，0表示正数，1表示负数。符号位独立于数值的绝对值，仅表示正负。<br>数值位：正数的反码与原码相同；负数的反码是原码的数值位取反。<br>缺点：0的表示不唯一；比补码少表示一个最小负数<br>（3）补码<br>符号位：最高位为符号位，0表示正数，1表示负数。<u>符号位既表示正负，也和数值位共同构成补码的值。补码的设计使得加法和减法运算更加高效，因为可以使用相同的加法电路来处理正数和负数的加法。</u><br>数值位：正数的补码与原码相同；负数的补码是反码加1。<br>补码反求真值：数值位取反加一，再加符号。<br>已知补码，求真值反向符号的补码（已知<script type="math/tex">[X^T]_{补}</script>，求<script type="math/tex">[-X^T]_{补}</script>）：符号位和数值位一起，各位取反，末位加1。（最小负数1000 0000的补码不存在，因为溢出）<br>（4）移码<br>符号位：最高位为符号位，但移码的符号位表示方式与原码、补码、反码不同。移码通过偏移量将数值映射到一个无符号数范围内，符号位的作用是区分正负。<br>数值位：移码的值等于原码的值加上偏移量 $2^{n−1}$，其中 n 是位数。<br>（数值位加上偏移量，使得首位表示符号，1为正数，0为负数；小数部分称为浮点数的尾数，整数部分称为浮点数的阶）</p><p>现代计算机中带符号整数都用补码表示。</p><ol><li>补码的运算表达什<br>加法公式：<script type="math/tex">[x+y]_补=[x]_补+[y]_补</script><br>减法公式：<script type="math/tex">[x-y]_补=[x]_补+[-y]_补</script></li></ol><p><strong>真题</strong></p><ol><li><p>简述计算机内部和外部需要进行数制转换的原因： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>计算机内部所有信息都采用二进制编码表示。(2分)<br>但在计算机外部,大都采用八、十或十六进制表示形式。(2分)<br>因此,计算机在数据输入后或输出前都必须实现这些进制数和二进制数之间的转换。(2分)</p></blockquote></li><li><p>二进制、八进制、十六进制转十进制： <mark class="hl-label default">（2024-10XZ 1'）</mark> </p><script type="math/tex; mode=display">(10010)_2=2^4+2^1=18</script><script type="math/tex; mode=display">(347)_8=3*2^2+4*2^1+7*2^0=27</script><script type="math/tex; mode=display">(28E)_{16}=2*16^2+8*16^1+14*16^0=654</script><p>十六进制：A=10，B=11，C=12，D=13，E=14，F=15</p></li><li><p>浮点运算器可以用阶码部件和尾数部件来实现。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="三、程序的转换-及-机器级表示"><a href="#三、程序的转换-及-机器级表示" class="headerlink" title="三、程序的转换 及 机器级表示"></a>三、程序的转换 及 机器级表示</h2><ol><li>指令系统中采用不同寻址方式的目的主要是：缩短指令长度，扩大寻址空间，提高编程灵活性。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </li></ol><h2 id="四、可执行文件的生成-与-加载执行"><a href="#四、可执行文件的生成-与-加载执行" class="headerlink" title="四、可执行文件的生成 与 加载执行"></a>四、可执行文件的生成 与 加载执行</h2><ol><li><p>从源程序变为可执行文件的步骤：<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">预处理</i>、<i id="answer4_2" class="answer" onclick="showOrHide('4_2')">编译</i>、<i id="answer4_3" class="answer" onclick="showOrHide('4_3')">汇编</i>、<i id="answer4_4" class="answer" onclick="showOrHide('4_4')">链接</i>。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li><li><p>在父进程中创建一个子进程，使用<i id="answer4_5" class="answer" onclick="showOrHide('4_5')">fork</i>函数。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="五、程序的存储访问"><a href="#五、程序的存储访问" class="headerlink" title="五、程序的存储访问"></a>五、程序的存储访问</h2><ol><li><p>重定位：重新确定代码和数据的地址,并更新指令中被引用符号地址的操作。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> </p></li><li><p>简述在递归深度较深时，递归调用的时间开销和空间开销都会较大的原因：  <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>每个过程包含准备阶段和结束阶段,并在栈中新增一个栈帧,(2分)<br>因而,每增加一次过程调用,就要增加许多条包含在准备阶段和结束阶段的额外指令,并增加一个栈帧的空间,(2分)<br>当递归调用深度较深时,这些额外指令的执行时间开销和栈帧的空间开销就会很大,有些情况下甚至发生栈溢出。(2分)</p></blockquote></li><li><p>简述动态链接的共享性和动态性： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>共享性是指共享库中的代码段在内存只有一个副本,当应用程序在其代码中需要引用共享库中的符号时,在引用处通过某种方式确定指向共享库中对应定义符号的地址即可;(3分)<br>动态性是指共享库只有使用它的程序被加载或执行时才加载到内存。(3 分)</p></blockquote></li><li><p>非易失性存储器：ROM，次表面存储器，光存储器。<br>易失性存储器：主存，高速缓冲存储。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="六、程序中I-O操作的实现"><a href="#六、程序中I-O操作的实现" class="headerlink" title="六、程序中I/O操作的实现"></a>六、程序中I/O操作的实现</h2><ol><li><p>简述中断控制I/0方式的基本思想： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>当需要进行I /O 操作时,首先启动外设进行第一个数据的 I /O 操作,然后阻塞请求I /O的用户进程,并调度其他进程到 CPU上执行,期间外设在设备控制器的控制下工作。(2 分)<br>外设完成 I /O 操作后,向 CPU 发送一个中断请求信号,CPU 检测到该信号后,则进行上下文切换,调出相应的中断服务程序执行。(2分)<br>中断服务程序将启动后续数据的 I /O操作,然后返回到被打断的进程继续执行。(2分)</p></blockquote></li><li><p>子系统层次结构（图） <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/15/LearnCO/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</link>
      <guid>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</guid>
      <pubDate>Wed, 12 Feb 2025 13:34:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8=40&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;共八章&lt;/p&gt;
&lt;h2 id=&quot;一、绪论&quot;&gt;&lt;a href=&quot;#一、绪</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*15=30</code><br>填空题：<code>2&#39;*15=30</code><br>简答题：<code>5&#39;*8=40</code></p><p>共八章</p><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><ol><li><p>软件开发的本质及其涉及到的问题 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）将软件开发的本质概括为：不同抽象层术语之间的“映射”，以及不同抽象层处理逻辑之间的“映射”。（2’）<br>（2）它涉及到两方面的问题：<br>①一是如何实现这样的映射，这是技术层面上的问题。（1’）<br>②二是如何管理这样的映射，以保障映射的有效性和正确性。这是管理层面上的问题。（2’）</p></blockquote></li><li><p>计算机软件=<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">程序</i>+文档</p></li></ol><h2 id="二、软件需求与规约"><a href="#二、软件需求与规约" class="headerlink" title="二、软件需求与规约"></a>二、软件需求与规约</h2><h2 id="三、结构化方法"><a href="#三、结构化方法" class="headerlink" title="三、结构化方法"></a>三、结构化方法</h2><ol><li><p>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>结构化方法总体设计的三个阶段 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</p></blockquote></li><li><p>结构精细化设计的原则：高内聚低耦合<mark class="hl-label default">（2024-04XZ 2'）</mark> ；逐步细化；清晰第一，效率第二；遵循结构化控制结构……</p></li><li><p>在结构化设计中，执行一个特殊任务的一个过程以及相关的数据结构，称之为<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">模块</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> <br>模块（Module）是结构化设计的核心概念之一，它将程序分解为可管理的、功能单一的代码单元，每个模块完成一个特定的任务，并通过明确的接口与其他模块交互。</p></li></ol><h2 id="四、面向对象方法UML"><a href="#四、面向对象方法UML" class="headerlink" title="四、面向对象方法UML"></a>四、面向对象方法UML</h2><ol><li><p>UML表达客观事物之间关系的术语及定义 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）为了表达各类客观事物之间的关系，UML给出了表达关系的基本术语：关联、泛化、细化、依赖；（1分）<br>（2）关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。（1分）泛化是一般性类目和它的较为特殊性类目之间的一种关系。（1分）细化是类目之间的语义关系，其中一个类目规约了保证另一个类目执行的契约。（1分）依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。（1分）</p></blockquote></li><li><p>为了进一步表达泛化的语义，UML给出了4个约束，分别为完整、不完整、<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">互斥、重叠</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> </p></li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段"><a href="#（一）初始阶段" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段"><a href="#（二）细化阶段" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><p>使用类图来定义分析类（边界类、实体类、控制类）<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/1.png" width="80%"></p><h3 id="（三）构建阶段"><a href="#（三）构建阶段" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段"><a href="#（四）交付阶段" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="五、面向对象方法RUP"><a href="#五、面向对象方法RUP" class="headerlink" title="五、面向对象方法RUP"></a>五、面向对象方法RUP</h2><p>定义：Rational Unified Process，统一软件开发过程。</p><ol><li>RUP中<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">部署模型</i> <mark class="hl-label default">（2024-04TK 2'）</mark>  的主要内容：节点，节点之间的通信关系，主动类到节点的映射 <mark class="hl-label default">（2024-04TK 2'）</mark> ，软件组件到节点的映射，部署配置，部署视图，部署计划</li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段-1"><a href="#（一）初始阶段-1" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段-1"><a href="#（二）细化阶段-1" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><h3 id="（三）构建阶段-1"><a href="#（三）构建阶段-1" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段-1"><a href="#（四）交付阶段-1" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="六、软件测试"><a href="#六、软件测试" class="headerlink" title="六、软件测试"></a>六、软件测试</h2><ol><li><p>描述系统或软件问题时常用的术语：<br>错误：由于开发人员的疏忽、误解或其他原因导致的不符合预期的行为或状态。错误通常发生在开发阶段，例如需求分析、设计或编码过程中。<br>故障：系统或组件的内部状态不正常。能是偶然的（如硬件故障）或系统的（如软件设计缺陷）。<br><i id="answer6_2" class="answer" onclick="showOrHide('6_2')">失效</i>：系统或组件未能按照预期执行其功能，是用户可观察到的错误行为或结果。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>人类对软件测试目的的认识经历了<i id="answer6_1" class="answer" onclick="showOrHide('6_1')"> 5 </i>个阶段 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br>（1）错误检测阶段<br>（2）验证阶段<br>（3）质量保证阶段<br>（4）风险控制阶段<br>（5）用户体验和价值交付阶段</p></li></ol><h2 id="七、软件生命周期"><a href="#七、软件生命周期" class="headerlink" title="七、软件生命周期"></a>七、软件生命周期</h2><ol><li><p>螺旋模型概念及其特点 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）螺旋模型是瀑布模型与演化模型的基础上，加入两者所忽略的风险分析所建立的一种软件开发模型。（2’）<br>（2）螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。（3’）</p></blockquote><p> <img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/3.png" width="80%"></p></li><li>瀑布模型适用于需求明确、稳定且对安全性和可靠性要求高的项目，例如企业内部管理信息系统、航空航天和医疗设备领域的软件开发。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/4.png" width="80%"></li></ol><p>五个主要阶段：</p><h3 id="（一）需求分析"><a href="#（一）需求分析" class="headerlink" title="（一）需求分析"></a>（一）需求分析</h3><h3 id="（二）设计阶段"><a href="#（二）设计阶段" class="headerlink" title="（二）设计阶段"></a>（二）设计阶段</h3><h4 id="（二-1）概要设计"><a href="#（二-1）概要设计" class="headerlink" title="（二/1）概要设计"></a>（二/1）概要设计</h4><ol><li><p>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。<br>功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。<br>接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。<br>数据库设计：设计核心数据的逻辑结构。</p></blockquote></li><li><p>概要设计规约的作用</p><blockquote><p>是系统设计阶段的重要文档，用于指导详细设计和后续的开发工作。<br>是系统架构和功能模块设计的正式文档，为开发团队提供整体设计思路。</p></blockquote></li></ol><h4 id="（二-2）详细设计"><a href="#（二-2）详细设计" class="headerlink" title="（二/2）详细设计"></a>（二/2）详细设计</h4><h3 id="（三）编码阶段"><a href="#（三）编码阶段" class="headerlink" title="（三）编码阶段"></a>（三）编码阶段</h3><h3 id="（四）测试阶段"><a href="#（四）测试阶段" class="headerlink" title="（四）测试阶段"></a>（四）测试阶段</h3><h3 id="（五）维护阶段"><a href="#（五）维护阶段" class="headerlink" title="（五）维护阶段"></a>（五）维护阶段</h3><h2 id="八、集成化能力成熟度模型CMMI"><a href="#八、集成化能力成熟度模型CMMI" class="headerlink" title="八、集成化能力成熟度模型CMMI"></a>八、集成化能力成熟度模型CMMI</h2><p>定义：是一种用于评估和改进组织在软件开发、系统集成、项目管理等方面过程能力的框架。<br>CMMI的成熟度等级：初始级，已管理级，已定义级，已量化管理级，持续优化级。共 5 个等级，每个等级要记英文，可能会考某个等级的名字；最高等级为第5级，优化级。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p><ol><li><p>能力等级和成熟度等级之间的区别和联系 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）区别：能力等级是一种过程改善路径，该路径可使组织针对单一过程域不断改善该过程域。（1分）成熟度等级也是一种过程改善路径，该路径可使组织通过关注一组过程域不断改善一组相关的过程域;（1分）<br>（2）联系：能力等级和成熟度等级都是CMMI提供的两种过程改善路径，侧重不同：它们都是按共用目标从弱到强。（1分）当某一过程域逐步完成了所有等级的“最佳实践”，它才可能满足成熟度等级对单一过程域的要求。（1分）当一组过程域及相关共用目标的一个成熟度等级完成后，软件过程才能实现高一级别的“成熟”，从而实现对软件过程有效管理的“最佳实践”。（1分）</p></blockquote></li><li><p>CMMI模型根据核心能力领域对过程域进行分类，这些能力领域包括：<br>治理：提供高级管理在过程治理中的角色指导。<br>实施基础设施：确保组织的重要过程和资产被持续使用和改进。<br>过程管理：包括组织过程焦点、过程定义等。<br>项目管理：包括项目规划、监控、风险管理等。<br>工程：涉及需求开发、技术方案、验证等。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br>支持：包括配置管理、度量分析、质量保证等。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/6.png" width="80%"></p></li><li><p>CMMI的模型部件中，实践部件的图形是菱形 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/5.png" width="80%"></p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747 Java语言程序设计 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/05/LearnJava/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/LearnJava/</guid>
      <pubDate>Wed, 05 Feb 2025 13:33:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8&lt;/code&gt;&lt;/p&gt;
&lt;!--
## 2024-10真题
### 1.1 Java语言支持的基本数据类型 及 包含的</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*10</code><br>填空题：<code>2&#39;*15</code><br>简答题：<code>5&#39;*8</code></p><!--## 2024-10真题### 1.1 Java语言支持的基本数据类型 及 包含的各类型对应的所有关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整数类型：byte, short, int, long (1&#x27;)</span><br><span class="line">浮点数类型：float, double (1&#x27;)</span><br><span class="line">字符类型：string (1&#x27;)</span><br><span class="line">布尔类型：boolean (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-2-Java的异常类型及各自特点"><a href="#1-2-Java的异常类型及各自特点" class="headerlink" title="1.2 Java的异常类型及各自特点"></a>1.2 Java的异常类型及各自特点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java的异常分为三种类型： (1&#x27;)</span><br><span class="line">（1）受检异常，必须被处理  (1&#x27;)</span><br><span class="line">（2）运行时异常，不需要处理  (1&#x27;)</span><br><span class="line">（3）错误，不需要处理  (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-3-什么是包装类"><a href="#1-3-什么是包装类" class="headerlink" title="1.3 什么是包装类"></a>1.3 什么是包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包装类是一种特殊的基本类型。 (2&#x27;)</span><br><span class="line">当想用处理对象一样的方式来处理基本数据类型的数据时，必须将基本数据类型值“包装”为一个对象。  (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-4-什么是抽象类-及其作用"><a href="#1-4-什么是抽象类-及其作用" class="headerlink" title="1.4 什么是抽象类 及其作用"></a>1.4 什么是抽象类 及其作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义了方法但没有定义具体实现的类称为抽象类，通过abstract关键字完成。 (2&#x27;)</span><br><span class="line">在程序中，需要创建某个类代表一些基本行为，并为其规范定义一些方法，但又无法或不宜在这个类实现，希望在其子类实现。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-5-描述Java的委托事件处理模型"><a href="#1-5-描述Java的委托事件处理模型" class="headerlink" title="1.5 描述Java的委托事件处理模型"></a>1.5 描述Java的委托事件处理模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每当用户在组件上进行某种操作时，事件处理系统会生成一个事件类对象。 (2&#x27;)</span><br><span class="line">事件被直接送往产生这个事件的组件，组件需要注册一个或多个侦听程序。 (1&#x27;)</span><br><span class="line">侦听程序的类中包含了事件处理程序，用来接收和处理这个事件。 (1&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**Expand**</span><br><span class="line">Java的委托事件处理模型（Delegation Event Model）是Java中用于处理事件的一种机制，它基于观察者模式（Observer Pattern），将事件源（Event Source）和事件监听器（Event Listener）分离，从而实现低耦合和高灵活性。</span><br><span class="line">1. 基本概念</span><br><span class="line">    事件源（Event Source）：是产生事件的对象，例如按钮（Button）、文本框（TextField）等。事件源可以触发一个或多个事件。</span><br><span class="line">    事件（Event）：是某个动作或状态的表示，例如鼠标点击（ActionEvent）、键盘输入（KeyEvent）等。</span><br><span class="line">    事件监听器（Event Listener）：是实现特定接口的对象，用于处理事件。监听器接口定义了事件处理方法，例如 ActionListener 接口中的 actionPerformed 方法。</span><br><span class="line">    事件处理器（Event Handler）：是事件监听器中实现的事件处理方法，用于响应事件。</span><br><span class="line">2. 工作原理</span><br><span class="line">（1）注册事件监听器，通过实现特定的接口来定义事件处理逻辑</span><br><span class="line">（2）事件触发，当用户与事件源交互时（例如点击按钮），事件源会生成一个事件对象（如 ActionEvent）。事件源将事件对象传递给所有注册的监听器。</span><br><span class="line">（3）事件处理</span><br><span class="line">3. 事件传播机制</span><br><span class="line">    捕获阶段（Capturing Phase）：事件从最顶层的容器开始向下传播，直到到达事件源。</span><br><span class="line">    冒泡阶段（Bubbling Phase）：事件从事件源开始向上传播，直到到达最顶层的容器。</span><br></pre></td></tr></table></figure><h2 id="2024-04真题"><a href="#2024-04真题" class="headerlink" title="2024-04真题"></a>2024-04真题</h2><h3 id="2-1-接口与多重继承的关系"><a href="#2-1-接口与多重继承的关系" class="headerlink" title="2.1 接口与多重继承的关系"></a>2.1 接口与多重继承的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java不支持多重继承，一个类只能从唯一的一个类继承而来。但是，这并不意味着Java不能实现多重继承的功能。 (2&#x27;)</span><br><span class="line">具体来说，Java允许一个类实现多个接口，从而具备了多重继承的能力。因为接口中声明的方法体是空的，所以不会出现多重继承中固有的混乱。 (2&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口（Interface）是一种特殊的抽象类型，它定义了一组行为规范，但不提供具体实现。当一个类实现某个接口时，它必须提供接口中声明的所有方法的具体实现。这种机制被称为契约机制。</span><br><span class="line">面向接口编程是一种重要的设计原则，它强调通过接口来定义和交互，而不是直接依赖具体的类。这种方式可以带来以下好处：解耦（实现类和使用类之间只依赖接口，而不是具体的实现），多态（通过接口引用调用方法时，可以根据实际对象的类型动态调用相应的方法）。</span><br></pre></td></tr></table></figure><h3 id="2-2-解释线程控制中方法的功能（max-4’）"><a href="#2-2-解释线程控制中方法的功能（max-4’）" class="headerlink" title="2.2 解释线程控制中方法的功能（max:4’）"></a>2.2 解释线程控制中方法的功能（max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start()：启动线程对象。 (2&#x27;)</span><br><span class="line">yield()：用于强制终止线程的执行。 (2&#x27;)</span><br><span class="line">wait()：导致当前线程等待。 (2&#x27;)</span><br><span class="line">notify()：当其它线程调用某线程的notify方法时，唤醒该线程。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"><a href="#2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号" class="headerlink" title="2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"></a>2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Font</span> <span class="variable">fn</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Courier&quot;</span>,Font.BOLD,<span class="number">20</span>);  <span class="comment">//(4&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-静态方法的特点（1’-answer，max-4’）"><a href="#2-4-静态方法的特点（1’-answer，max-4’）" class="headerlink" title="2.4 静态方法的特点（1’/answer，max:4’）"></a>2.4 静态方法的特点（1’/answer，max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）静态方法以static修饰；</span><br><span class="line">（2）静态方法属于类，不属于对象；</span><br><span class="line">（3）调用静态方法时，前缀可以使用类名；</span><br><span class="line">（4）静态方法中不能访问类对象的非静态成员，只能访问类的静态成员；</span><br><span class="line">（5）静态方法中没有this指针；</span><br><span class="line">（6）静态方法不可以被重写。</span><br></pre></td></tr></table></figure><p>—&gt;</p>-->]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/LearnJava/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
