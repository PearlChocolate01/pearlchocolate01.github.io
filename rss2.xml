<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Sun, 01 Jun 2025 15:19:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>02333 软件工程（三）——结构化方法</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-3/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-3/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[结构化方法] --&gt; A1[结构化需求分析]
    A --&gt; A2[结构化设计]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[结构化方法] --> A1[结构化需求分析]    A --> A2[结构化设计]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><h3 id="3-1-结构化需求分析"><a href="#3-1-结构化需求分析" class="headerlink" title="3.1 结构化需求分析"></a>3.1 结构化需求分析</h3><ol><li>可以用于描述加工的是：<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">结构化自然语言</i>。</li><li>可以用于表示数据的静态结构的是：<i id="answer3_2" class="answer" onclick="showOrHide('3_2')">数据存储</i>。</li><li>结构化分析方法用于表达功能模型的工具：<i id="answer3_3_1" class="answer" onclick="showOrHide('3_3_1')">DFD图（数据流图、数据流程图）</i>。一般包含<i id="answer3_3_2" class="answer" onclick="showOrHide('3_3_2')">数据流</i>、<i id="answer3_3_3" class="answer" onclick="showOrHide('3_3_3')">数据存储</i>、<i id="answer3_3_4" class="answer" onclick="showOrHide('3_3_4')">加工</i>、<i id="answer3_3_5" class="answer" onclick="showOrHide('3_3_5')">数据源</i>、<i id="answer3_3_6" class="answer" onclick="showOrHide('3_3_6')">数据潭</i>等。</li><li>数据字典中定于数据结构的符号：m…n表示<i id="answer3_4_1" class="answer" onclick="showOrHide('3_4_1')">子界</i>，<code>&#123;&#125;</code>表示<i id="answer3_4_2" class="answer" onclick="showOrHide('3_4_2')">重复</i>。<br>（1）建立系统环境图,确定系统语境；（1分）<br>（2）自顶向下，逐步求精，建立系统的层次数据流图；（2分）<br>（3）定义数据字典；（1分）<br>（4）描述加工。（1分）</li><li>结构化分析方法建模步骤：建立系统 -&gt; 建立层次 -&gt; 定义字典 -&gt; 加工。</li><li>数据流图中，椭圆表示加工，双横线表示数据存储，方框表示数据源。</li><li>在结构化分析方法中，可采用<i id="answer3_7_1" class="answer" onclick="showOrHide('3_7_1')">结构化自然语言</i>、<i id="answer3_7_2" class="answer" onclick="showOrHide('3_7_2')">判定表</i>、<i id="answer3_7_3" class="answer" onclick="showOrHide('3_7_3')">判定树</i>描述加工。</li><li>结构化分析方法中，数据的变换单位是<i id="answer3_8" class="answer" onclick="showOrHide('3_8')">加工</i>。</li><li>事务流程图中，一个事务可以被另一个事务吸食，称为<i id="answer3_9" class="answer" onclick="showOrHide('3_9')">事务吸收</i>。</li><li>数据字典中，所有客体均可用<i id="answer3_10_1" class="answer" onclick="showOrHide('3_10_1')">顺序结构</i>、<i id="answer3_10_2" class="answer" onclick="showOrHide('3_10_2')">选择结构</i>、<i id="answer3_10_3" class="answer" onclick="showOrHide('3_10_3')">重复结构</i>三种基本结构表示。</li><li>结构化方法中，软件中具有特定标识的独立成分是<i id="answer3_11" class="answer" onclick="showOrHide('3_11')">模块</i>。</li><li>结构化方法包括：<i id="answer3_12_1" class="answer" onclick="showOrHide('3_12_1')">结构化分析方法</i>、<i id="answer3_12_2" class="answer" onclick="showOrHide('3_12_2')">结构化设计方法</i>、<i id="answer3_12_3" class="answer" onclick="showOrHide('3_12_3')">结构化程序设计方法</i>。</li></ol><h3 id="3-2-结构化设计"><a href="#3-2-结构化设计" class="headerlink" title="3.2 结构化设计"></a>3.2 结构化设计</h3><ol><li>耦合：不同模块间相互依赖程度。<br>耦合程度：内容耦合 &gt; 公共耦合 &gt; 控制耦合 &gt; 数据耦合<br>数据耦合：通过传递参数调用模块。<br>控制耦合：通过传递开关量（只有两种状态的离散信号）调用模块。<br>公共耦合：一组模块共同引用一个全局数据项。<br>内容耦合：一个模块直接操作另一个模块的数据，或一个模块不通过正常入口转入另一个模块。</li><li>内聚：一个模块内部各成分之间相互关联程度。<br>常见内聚类型：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。<br>内聚程度：功能内聚 &gt; 过程内聚 &gt; 逻辑内聚<br>通信内聚：一个模块内所有成分都生成或操作同一数据集。<br>偶然内聚：一个模块的各成分之间基本不存在任何关系。</li><li>提高模块独立性的原则：高内聚低耦合</li><li>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/06/01/02333-3/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程度高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </li><li>宽度：同一层次上模块总数的最大值。</li><li>深度：粗略标志一个系统的规模和复杂程度。</li><li>作用域：模块内受一个判定所“影响”的所有模块的集合。（背）</li><li>控制域：模块本身或所有直接或间接“从属”于它的模块的集合。（背）</li><li>作用域和控制域的启发式原则：尽力使模块的作用域在其控制域之内。</li><li>逐步求精：每一步是对上一步结果的细化。（使用N-S盒图）</li><li>详细设计工具：PFD图（程序流程图/框图）、N-S图（盒图）、PAD图（问题分析图）、PDL（类程序设计语言）。<br>N-S图：盒图，支持自顶向下逐步求精，严格控制一个处理到另一个处理的转移。<br>PAD图：问题分析图，用二维树结构表示程序控制流，面向高级语言。<br><strong>简述PDL特点：</strong><br>（1）PDL也称为伪码,它是一种用正文形式表示数据和处理过程的设计工具。<br>（2）PDL借用某种结构化程序设计语言(如Pascal或)的关键字作为语法框架,用于定义控制结构和数据结构。<br>（3）PDL通常使用某种自然语言(如汉语或英语)的词汇,灵活自由地表示实际的操作和判定条件。<br>（4）PDL可以作为注释工具直接插在源程序中间。</li><li>程序流程图优缺点<br>（1）优点：对控制流程描绘很直观，便于初学者掌握。<br>（2）缺点：不是一种逐步求精的工具；控制流不受约束，可能破坏好的系统结构；不易表示数据结构。</li><li>结构化程序设计：顺序结构、选择结构、循环结构。<br>选择结构的表达式：IF-THEN-ELSE。</li><li>针对具有变换型流图和事务型DFD的总体设计步骤：<br>（1）在软件总体设计中，通常以变换设计为主，事务设计为辅进行结构设计；（1分）<br>（2）首先利用变换设计，把软件系统分为输入，中心变换和输出3个部分，设计上层模块；（1分）<br>（3）然后根据各部分数据流图的结构特点，适当地利用变换设计和事务设计进行细化，得到初始的模块结构图；（1分）<br>（4）再按照“高内聚低耦合”的原则，对初始的模块结构图进行精化，得到最终的模块结构图。（2分）</li><li>变换设计的基本步骤：<br>（1）设计准备，复审并精化系统模块；（1分）<br>（2）确定输入、变换、输出这三部分之间的边界；（1分）<br>（3）设计系统模块结构图的顶层和第一层；（1分）<br>（4）自顶向下，逐步求精。（2分）</li><li>结构化方法的不同阶段：可行性研究阶段、需求分析阶段、总体设计阶段、详细设计阶段、编码实现阶段、测试阶段、维护阶段。<br>总体设计阶段使用HIPO图，由IPO图和H图（层次图）组成。<br>层次图：适合自顶向下的软件设计过程。<br><strong>总体设计阶段内的三个阶段：</strong> <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</li><li>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。（1分）<br>（2）功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。（1分）<br>（3）接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。（1分）<br>（4）数据库设计：设计核心数据的逻辑结构。（1分）<br>（5）测试需求等。（1分）</li><li>待建系统的数据流图两种类型：变换型数据流图、事务型数据流图。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（二）——软件需求与软件需求规约</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-2/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-2/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[软件需求] --&gt; A1[需求概念]
    A --&gt; A2[需求获取]
    A --&gt; A3[需求规约]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[软件需求] --> A1[需求概念]    A --> A2[需求获取]    A --> A3[需求规约]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><ol><li>软件需求分为：功能需求（主体），非功能需求。</li><li>接口需求的分类：用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求。</li><li>单个需求必须具有的基本性质：必要的、无歧义的、可测的、可测量的。</li><li>需求分析的三大挑战：问题空间理解，人与人之间的通信，需求的变化性。</li><li>初始发现需求的常用技术：自悟，交谈（提问/回答），观察（可能引起抵触），小组会，提炼（已有文档）。</li><li>验证需求是否正确的技术：自悟、提炼。</li><li>需求规约的定义：需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，它表达了一个软件产品/系统的概念模型。</li><li>软件需求规约的性质：重要性，稳定性，可修改性，完整性（基本），一致性。</li><li>需求规约的三种形式：<br>（1）非形式化的需求规约：基于自然语言来编制需求规约。<br>（2）半形式化的需求规约：以半形式化符号体系（术语表）等表达需求规约。<br>（3）形式化规约：基于良构数学概念符号体系来编制需求规约。</li><li>需求规约在项目开发中的基本作用：<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现；（1分）<br>（2）对于项目的其余大多数工作，需求规约是一个管理控制点；（1分）<br>（3）对于产品/系统的设计，需求规约是一个正式的、受控的起始点；（1分）<br>（4）是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档：初始测试计划和用户系统操作描述。（2分）</li><li>需求规约与项目需求有哪些不同？<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，即关注产品需求，（1分）回答“交付给客户的产品/系统是什么了（1分）。<br>（2）项目需求是客户和开发者之间有关技术合同-产品/ 系统需求的理解。（1分）应记录在工作陈述中或其他某一项目文档中,即关注项目工作于管理，（1分）回答“开发组要做的是什么事。（1分）</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>回杭的日子5</title>
      <link>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/</link>
      <guid>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/</guid>
      <pubDate>Thu, 29 May 2025 14:43:27 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1818978932&auto=1&height=66"></iframe><br></p><p>没有抢到CP31的票，急匆匆制定的PlanB就成了治愈系的绿色漫游。<br>尽管和很多年轻人一样调侃着抢票的难度，也从容地享受着失败者的自嗨，遗憾的心情确实是伴随着全程的，好在杭州的每一株草木都带给我治愈的力量。</p><p>微雨阴晴，早上被布谷鸟的叫声唤醒，走进林木深处就没有了初夏燥热的阳光，正是游玩西湖风景区最好的时候。<br>第一站是虎跑公园，入口的屋檐上长满了垂直向上的枝草，似乎能想象出有如宫崎骏动画中、植物从角角落落不起眼的地方生长出来的样子，没有为了干净的屋檐而破坏，我被生命之美所感动，也被保护着这片风景的人所感动。进门所见的水池、水中木、浮萍、鲤鱼仿佛构成了一幅精心设计的写意画，肆意生长的杂草也争当画中的主角，鱼儿在浮萍之间悠游，好一副动态景观。沿着溪水前行，没有着急看到下一幅画的迫切，每一眼都希望可以再久一点。</p><p>这里是我的灵魂故乡。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/%E6%9D%AD%E5%B7%9E/">杭州</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java</title>
      <link>https://pearlchocolatezy.com/2025/05/29/04747-Java/</link>
      <guid>https://pearlchocolatezy.com/2025/05/29/04747-Java/</guid>
      <pubDate>Thu, 29 May 2025 14:31:39 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简述Java与平台无关原理：&lt;br&gt;java与平台无关的关键是JVM,JVM是一台虚拟计算机,不同的操作系统有不</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ol><li>简述Java与平台无关原理：<br>java与平台无关的关键是JVM,JVM是一台虚拟计算机,不同的操作系统有不同的虚拟机,它类似于一个小巧而高效的CPU。Java编译器将Java程序编译成JVM(虚拟机)能够识别的二进制代码,这种代码称为字节码,字节码就是虚拟机的机器指令,它与平台无关,有统一的格式,不依赖于具体的硬件环境,只运行在JVM上。在任何安装Java运行时环境的系统上,都可以执行这些代码。</li><li>Java程序分为：Java应用程序，Java小程序。</li><li>Java实行<>语言定义阶段</>、<>字节码检查阶段</>、<>程序执行阶段</>三级代码安全检查机制。</li><li>Windows操作系统霞安装JDK并设置缓解变量后，测试命令：<>javac</>。该命令还能将java程序编译成字节码。</li><li>JDK的常用工具<br>bin目录下主要的开发工具：javac, java, jdb, javadoc。<br>javac.exe是java的编译器。<br>java.exe是java的解释器。<br>JDK是java开发工具集。<br>JRE是java运行时环境。<br>JVM是java虚拟机。</li><li>Java集成环境（IDE）工具：编辑器，编译器，图形用户界面。</li><li>Java程序编译过程中，源代码文件（.java）被编译器编译后，会生成字节码文件（类文件.class）。字节码可以被Java虚拟机（JVM）解释执行。（两个阶段：编译，解释执行）<br>Java程序生成的字节码文件与平台无关。<br>Java解释执行Java字节码。（不是源程序）<br>Java没有指针。</li><li>Java运行的是<>与机器无关</>的二进制格式的类文件。</li><li>Java源文件中最多只能有一个public类，其他类的个数不限。</li><li>面向对象的方法学：面向对象的分析，面向对象的设计，面向对象的程序设计（OOP）。</li><li>Java语言的特性：无用内存自动回收机制，面向对象，多线程，JVM。<br>C语言的特性：全局变量，指针，预处理器，结构和类型定义。</li><li>编译java文件的命令：javac Test.java</li><li>面向对象语言机制：封装，继承，多态。<br>面向过程语言机制：方法调用，模块，结构化。</li><li>英文名词：<br>API：应用程序编程接口<br>OOP：面向对象程序设计<br>constructor：JDK文档中的构造方法</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/29/04747-Java/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：91-100解析</title>
      <link>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/</link>
      <guid>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/</guid>
      <pubDate>Fri, 23 May 2025 14:09:28 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;91-不同路径（多维动态规划-不同路径）&quot;&gt;&lt;a href=&quot;#91-不同路径（多维动态规划-不同路径）&quot; class=&quot;headerlink&quot; title=&quot;91. 不同路径（多维动态规划/不同路径）&quot;&gt;&lt;/a&gt;91. 不同路径（多维动态规划/不同路径）&lt;/h3</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="91-不同路径（多维动态规划-不同路径）"><a href="#91-不同路径（多维动态规划-不同路径）" class="headerlink" title="91. 不同路径（多维动态规划/不同路径）"></a>91. 不同路径（多维动态规划/不同路径）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<br>假设：1 &lt;= m, n &lt;= 100；题目数据保证答案小于等于 2 * $(10)^9$。<br>示例：输入：m = 3, n = 7；输出：28。</p><blockquote><p>【分析】</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">UniquePaths</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：81-90解析</title>
      <link>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/</link>
      <guid>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/</guid>
      <pubDate>Fri, 23 May 2025 14:08:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;81-爬楼梯（动态规划-70）&quot;&gt;&lt;a href=&quot;#81-爬楼梯（动态规划-70）&quot; class=&quot;headerlink&quot; title=&quot;81. 爬楼梯（动态规划/70）&quot;&gt;&lt;/a&gt;81. 爬楼梯（动态规划/70）&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="81-爬楼梯（动态规划-70）"><a href="#81-爬楼梯（动态规划-70）" class="headerlink" title="81. 爬楼梯（动态规划/70）"></a>81. 爬楼梯（动态规划/70）</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>假设：1 &lt;= n &lt;= 45。<br>示例：输入：n = 3；输出：3。(1,1,1; 1,2; 2,1)</p><blockquote><p>【分析】<br>到达第n阶的方法数等于达到第n-1阶和到达第n-2阶的方法数之和。<br>要到达第 n 阶，你可以选择从第 n−1 阶走一步上来，或者从第 n−2 阶走两步上来（从n-2阶走一步再走一步的情况，走一步时和第一种方法重了）。因此，到达第 n 阶的总方法数是到达第 n−1 阶和第 n−2 阶的方法数之和。<br>这种方法确保了每个子问题只被解决一次，并且其解被存储起来供后续使用，从而提高了算法的效率。<br>res[n]=res[n-1]+res[n-2]</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个变量的值随着n的变大动态地变大</span></span><br><span class="line"><span class="built_in">int</span> resN_2=<span class="number">1</span>;<span class="comment">//初始化可指代n=1时的result</span></span><br><span class="line"><span class="built_in">int</span> resN_1=<span class="number">2</span>;<span class="comment">//初始化可指代n=2时的result</span></span><br><span class="line"><span class="built_in">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">result=resN_1+resN_2;<span class="comment">//当下的i的result是由n-1时的result和n-2时的result组成</span></span><br><span class="line">resN_2=resN_1;<span class="comment">//res[n-1]对于下一轮就是res[n-2]</span></span><br><span class="line">resN_1=result;<span class="comment">//当前res对于下一轮就是res[n-1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（一）——绪论</title>
      <link>https://pearlchocolatezy.com/2025/05/20/02333-1/</link>
      <guid>https://pearlchocolatezy.com/2025/05/20/02333-1/</guid>
      <pubDate>Tue, 20 May 2025 13:59:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[绪论] --&gt; A1[软件工程的提出与发展]
    A --&gt; A2[软件开发的本质]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-s</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[绪论] --> A1[软件工程的提出与发展]    A --> A2[软件开发的本质]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><ol><li>目的：解决软件危机。</li><li>成果：<br>20世纪60年代-80年代初：瀑布模型，C语言，Pascal语言，Jackson方法，结构化方法，支持工具。<br>20世纪80年代-：软件生存周期过程，辅助工程CASE，面向对象。</li><li>软件危机的表现：生产效率低、质量低，缺乏原理、原则、方法、管理，超预算，时间拖延，无法满足需求，可维护性查，可靠性差。（背）</li><li>计算机软件的概念：（1）计算机软件一般是指计算机系统中的<i id="answer1_4_1" class="answer" onclick="showOrHide('1_4_1')">程序</i>及其<i id="answer1_4_2" class="answer" onclick="showOrHide('1_4_2')">文档</i>；（2）程序是计算机任务的处理对象和处理规则的描述；（3）文档是为了理解程序所需的阐述性资料。（4）软件是一个特定问题域的抽象，是一种逻辑实体。（背）</li><li>提出软件工程的目的：倡导以工程的原理、原则、方法进行软件开发，以期解决“软件危机”。（背）</li><li>软件危机的概念：软件生产率、软件质量远远满足不了社会发展的需求，成为社会、经济发展的制约因素。</li><li>软件工程的两个时期：前期研究系统实现技术，后期关注<i id="answer1_7_1" class="answer" onclick="showOrHide('1_7_1')">软件质量</i>和<i id="answer1_7_2" class="answer" onclick="showOrHide('1_7_2')">软件工程管理</i>。</li><li>软件系统模型大体分两类：软件模型，概念模型。</li><li>软件模型进一步分为：设计模型，实现模型，部署模型。</li><li>系统模型：系统模型是代建系统的任意抽象，其中包括所有的基本能力、特性或其他方面，没有任何冗余的细节。（背）</li><li>软件开发的本质：实现<i id="answer1_11_1" class="answer" onclick="showOrHide('1_11_1')">问题空间</i>的概念和处理逻辑到<i id="answer1_11_2" class="answer" onclick="showOrHide('1_11_2')">解空间</i>的概念和处理逻辑之间的<i id="answer1_11_3" class="answer" onclick="showOrHide('1_11_3')">映射</i>。实现这一映射的基本途径可采用<i id="answer1_11_4" class="answer" onclick="showOrHide('1_11_4')">系统建模</i>。（背）</li><li>软件开发的本质所涉及的问题：（1）技术层面如何实现这样的映射。涉及两方面：过程方向，即求解软件的开发逻辑；过程途径，即求解软件的开发手段。（2）管理层面如何管理这样的映射，以保障映射的有效性和正确性，主要功能包括：软件项目的规划、组织、人员安排、控制、领导。（背）</li><li>系统建模：运用所掌握的知识，通过抽象，给出该系统的一个结构——系统模型。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/20/02333-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：71-80解析</title>
      <link>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/</link>
      <guid>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/</guid>
      <pubDate>Mon, 19 May 2025 15:23:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;74-数组中的第K个最大元素（堆-215）&quot;&gt;&lt;a href=&quot;#74-数组中的第K个最大元素（堆-215）&quot; class=&quot;headerlink&quot; title=&quot;74. 数组中的第K个最大元素（堆/215）&quot;&gt;&lt;/a&gt;74. 数组中的第K个最大元素（堆/215）</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="74-数组中的第K个最大元素（堆-215）"><a href="#74-数组中的第K个最大元素（堆-215）" class="headerlink" title="74. 数组中的第K个最大元素（堆/215）"></a>74. 数组中的第K个最大元素（堆/215）</h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。<br>假设：<br>    1 &lt;= k &lt;= nums.length &lt;= $(10)^5$；<br>    $(-10)^4$ &lt;= nums[i] &lt;= $(10)^4$。<br>示例：输入: [3,2,1,5,6,4], k = 2；输出: 5。</p><blockquote><p>【分析】<br>解法1：使用堆，空间换时间，时间复杂度O(nlogk)。<br>堆（heap,数据结构）：堆是一种特殊的完全二叉树。C#中没有具体的接口或类可用于堆，可以自己建一个，使用数组来存储，为堆结构写一个上浮和下沉的方法使堆可以排序为大顶堆或小顶堆。<br>最大堆（大顶堆）：每个节点的值都大于或等于其子节点的值。<br>最小堆（小顶堆）：每个节点的值都小于或等于其子节点的值。<br>解法2：快速选择算法，时间复杂度O(n)。<br>快速选择算法是快速排序的一个变种，它用于在未排序的数组中找到第 k 大（或第 k 小）的元素。<br>分区函数式为了找到枢纽元素在数组中的最终位置，也是快排的核心算法。<br>每次调整后只取随机枢纽元素的一侧进行递归再排序。<br>就取第K个最大元素这个需求而言，不需要把整个数组排序，只要找到第K个最大元素的正确位置即可。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="comment">//1. 使用堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindKthLargest1</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 快速选择算法（快速排序）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindKthLargest2</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line">QuickSort(nums,<span class="number">0</span>,nums.Length<span class="number">-1</span>,k);</span><br><span class="line"><span class="keyword">return</span> nums[nums.Length-k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="built_in">int</span> pviot=Partition(nums,left,right);</span><br><span class="line"><span class="comment">//快排提前终止（不需要无限递归到数组结束）</span></span><br><span class="line"><span class="keyword">if</span>(pviot==nums.Length-k)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快排分区优化</span></span><br><span class="line"><span class="keyword">if</span>(pviot&gt;nums.Length-k)&#123;</span><br><span class="line">QickSort(nums,left,pviot<span class="number">-1</span>,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">QickSort(nums,pviot+<span class="number">1</span>,right,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Partition</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span>&#123;</span><br><span class="line">Swap(nums,left,(left+right)/<span class="number">2</span>);<span class="comment">//随机数和中位数的意义差不多</span></span><br><span class="line"><span class="built_in">int</span> pviotNum=nums[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]&gt;=pviotNum)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=nums[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;=pviotNum)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">nums[right]=nums[left];</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=pviotNum;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[a]!=nums[b])&#123;</span><br><span class="line"><span class="built_in">int</span> temp=nums[a];</span><br><span class="line">nums[a]=nums[b];</span><br><span class="line">nums[b]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="77-买股票的最佳时机（贪心算法-121）"><a href="#77-买股票的最佳时机（贪心算法-121）" class="headerlink" title="77. 买股票的最佳时机（贪心算法/121）"></a>77. 买股票的最佳时机（贪心算法/121）</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>假设：<br>    1 &lt;= prices.length &lt;= $(10)^5$；<br>    0 &lt;= prices[i] &lt;= $(10)^4$。<br>示例：输入：[7,1,5,3,6,4]；输出：5。</p><blockquote><p>【分析】<br>找到整数数组中的两个元素，使得后一元素减去前一元素的差最大。<br>时间复杂度O(n)，空间复杂度O(1)。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> minPrice=prices[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> price <span class="keyword">in</span> prices)&#123;</span><br><span class="line">minPrice=Math.Min(minPrice,price);</span><br><span class="line">maxProfit=Math.Max(maxProfit,price-minPrice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：61-70解析</title>
      <link>https://pearlchocolatezy.com/2025/05/19/LeetCode100-61-70/</link>
      <guid>https://pearlchocolatezy.com/2025/05/19/LeetCode100-61-70/</guid>
      <pubDate>Mon, 19 May 2025 15:21:55 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;63-搜索插入位置（二分查找-35）&quot;&gt;&lt;a href=&quot;#63-搜索插入位置（二分查找-35）&quot; class=&quot;headerlink&quot; title=&quot;63. 搜索插入位置（二分查找/35）&quot;&gt;&lt;/a&gt;63. 搜索插入位置（二分查找/35）&lt;/h3&gt;&lt;p&gt;给定一个</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="63-搜索插入位置（二分查找-35）"><a href="#63-搜索插入位置（二分查找-35）" class="headerlink" title="63. 搜索插入位置（二分查找/35）"></a>63. 搜索插入位置（二分查找/35）</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。<br>假设：<br>    1 &lt;= nums.length &lt;= $(10)^4$；<br>    $(-10)^4$ &lt;= nums[i] &lt;= $(10)^4$；<br>    nums 为 无重复元素 的 升序 排列数组；<br>    $(-10)^4$ &lt;= target &lt;= $(10)^4$。<br>示例：输入: nums = [1,3,5,6], target = 5；输出: 2。</p><blockquote><p>【分析】<br>解法：二分法</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SearchInsert</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span>&#123;</span><br><span class="line"><span class="comment">//定义两个指针</span></span><br><span class="line"><span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> right = nums.Length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line"><span class="built_in">int</span> mid=left+(right-left)/<span class="number">2</span>;<span class="comment">//转整数</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="69-有效的括号（栈-20）"><a href="#69-有效的括号（栈-20）" class="headerlink" title="69. 有效的括号（栈/20）"></a>69. 有效的括号（栈/20）</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>1.左括号必须用相同类型的右括号闭合。<br>2.左括号必须以正确的顺序闭合。<br>3.每个右括号都有一个对应的相同类型的左括号。<br>假设：<br>    1 &lt;= s.length &lt;= $(10)^4$；<br>    s 仅由括号 ‘()[]{}’ 组成。<br>示例：输入：s = “(]”；输出：false。</p><blockquote><p>【分析】<br>解法：使用栈数据结构。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>&#123;</span><br><span class="line">Stack&lt;<span class="built_in">char</span>&gt; stack=<span class="keyword">new</span> Stack&lt;<span class="built_in">char</span>&gt;();</span><br><span class="line">Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">char</span>&gt; map=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">char</span>&gt;()&#123;</span><br><span class="line">&#123;<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">char</span> c <span class="keyword">in</span> s)&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span> || c==<span class="string">&#x27;&#123;&#x27;</span> || c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">stack.Push(c);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span> || c==<span class="string">&#x27;&#125;&#x27;</span> || c==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(stack.Count==<span class="number">0</span> || stack.Pop()!=map[c])&#123;<span class="comment">//或条件：第一个条件判断为true即返回false出去，第一个条件判断为false则走第二个条件，第二个条件要Pop也必然stack.Count!=0，第二个条件判断的同时也是执行stack.Pop()。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.Count==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/19/LeetCode100-61-70/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：51-60解析</title>
      <link>https://pearlchocolatezy.com/2025/05/18/LeetCode100-51-60/</link>
      <guid>https://pearlchocolatezy.com/2025/05/18/LeetCode100-51-60/</guid>
      <pubDate>Sun, 18 May 2025 12:37:23 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;51-岛屿数量（图论-200）&quot;&gt;&lt;a href=&quot;#51-岛屿数量（图论-200）&quot; class=&quot;headerlink&quot; title=&quot;51. 岛屿数量（图论/200）&quot;&gt;&lt;/a&gt;51. 岛屿数量（图论/200）&lt;/h3&gt;&lt;p&gt;给你一个由 ‘1’（陆地）和 ‘</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="51-岛屿数量（图论-200）"><a href="#51-岛屿数量（图论-200）" class="headerlink" title="51. 岛屿数量（图论/200）"></a>51. 岛屿数量（图论/200）</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。<br>假设：<br>    m == grid.length；<br>    n == grid[i].length；<br>    1 &lt;= m, n &lt;= 300；<br>    <code>grid[i][j]</code> 的值为 ‘0’ 或 ‘1’。</p><blockquote><p>【分析】<br>解法1：深度优先搜索（DFS）<br>循环每个元素，遇到“1”则增加岛屿数，同时调用深度优先搜索方法，递归地根据当前元素是否为“1”将当前元素十字路线上的元素都置“0”，使每个岛屿块最终只剩一个“1”。<br>解法2：广度优先搜索（BFS）</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">NumIslands1</span>(<span class="params"><span class="built_in">char</span>[][] grid</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(grid==<span class="literal">null</span> || grid.Length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> numIslands=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> rows=grid.Length;</span><br><span class="line"><span class="built_in">int</span> cols=grid[<span class="number">0</span>].Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">numIslands++;</span><br><span class="line">DFS(grid,i,j,rows,cols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numIslands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span>(<span class="params"><span class="built_in">char</span>[][] grid, <span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">int</span> rows, <span class="built_in">int</span> cols</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=rows || j&lt;<span class="number">0</span> || j&gt;=cols || grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//中断递归</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序为“下、上、右、左”，不是固定顺序</span></span><br><span class="line">DFS(grid,i+<span class="number">1</span>,j,rows,cols);</span><br><span class="line">DFS(grid,i<span class="number">-1</span>,j,rows,cols);</span><br><span class="line">DFS(grid,i,j+<span class="number">1</span>,rows,cols);</span><br><span class="line">DFS(grid,i,j<span class="number">-1</span>,rows,cols);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="55-全排列（回溯-46）"><a href="#55-全排列（回溯-46）" class="headerlink" title="55. 全排列（回溯/46）"></a>55. 全排列（回溯/46）</h3><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。<br>假设：<br>    1 &lt;= nums.length &lt;= 6；<br>    -10 &lt;= nums[i] &lt;= 10；<br>    nums 中的所有整数 互不相同。<br>示例：输入：nums = [1,2,3]；输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]。</p><blockquote><p>【分析】<br>解法：回溯法（递归）<br>时间复杂度O(n*n!)<br>递推：函数不断调用自身，将问题分解为更小的子问题。<br>回溯：当递归达到基本情况（即不能再分解的子问题）时，逐层返回结果。<br>回溯算法通常基于递归实现。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; Permute(<span class="built_in">int</span>[] nums)&#123;</span><br><span class="line">IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; resAll=<span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">int</span>&gt;&gt;();</span><br><span class="line"><span class="comment">//Q:为什么只有第一个IList转为List：</span></span><br><span class="line"><span class="comment">//A:将外层的IList接口转为具体实现的List，这个实例化过程是正确的。</span></span><br><span class="line"><span class="comment">//不能写成IList&lt;IList&lt;int&gt;&gt; res = new List&lt;List&lt;int&gt;&gt;();</span></span><br><span class="line"><span class="comment">//因为res所声明的变量类型IList&lt;IList&lt;int&gt;&gt; 要求存储的是 IList&lt;int&gt; 类型的对象，而 List&lt;List&lt;int&gt;&gt; 无法满足这个要求。</span></span><br><span class="line"><span class="comment">//IList&lt;IList&lt;int&gt;&gt; 是声明类型，表示可以存储 IList&lt;int&gt; 类型对象的集合。</span></span><br><span class="line"><span class="comment">//new List&lt;IList&lt;int&gt;&gt;() 是具体的实现，表示创建一个可以存储 IList&lt;int&gt; 类型对象的 List。</span></span><br><span class="line"><span class="comment">//这种写法符合接口和实现类的关系，同时也符合泛型的类型安全要求。</span></span><br><span class="line"></span><br><span class="line">IList&lt;<span class="built_in">int</span>&gt; resOne=<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();<span class="comment">//用于记录其中一组排列</span></span><br><span class="line">Trackback(nums,resAll,resOne);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Trackback</span>(<span class="params"><span class="built_in">int</span>[] nums, IList&lt;IList&lt;<span class="built_in">int</span>&gt;&gt; resAll, IList&lt;<span class="built_in">int</span>&gt; resOne</span>)</span>&#123;</span><br><span class="line"><span class="comment">//Q:为什么声明res时具体实现为List&lt;IList&lt;int&gt;&gt;类型后，Trackback接收的类型还是IList&lt;IList&lt;int&gt;&gt;？</span></span><br><span class="line"><span class="comment">//A:接口的多态性</span></span><br><span class="line"><span class="comment">//使用接口类型作为参数可以让方法更加通用。Trackback 方法不需要知道 res 的具体实现是什么，只需要知道它是一个实现了 IList&lt;IList&lt;int&gt;&gt; 接口的对象即可。这意味着你可以传递任何实现了 IList&lt;IList&lt;int&gt;&gt; 的对象，而不仅仅是 List&lt;IList&lt;int&gt;&gt;。</span></span><br><span class="line"><span class="comment">//在Permute方法中传给Trackback的res是List&lt;IList&lt;int&gt;&gt;，其它地方可能调用Trackback可以使用IList&lt;IList&lt;int&gt;&gt;，参数类型可以使用接口。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(resOne.Count==nums.Length)&#123;<span class="comment">//跳出一次递归（循环）</span></span><br><span class="line">resAll.Add(<span class="keyword">new</span> List&lt;resOne&gt;);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!resOne.Contains(nums[i]))&#123;</span><br><span class="line">resOne.Add(nums[i]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Trackback(nums,resAll,resOne);</span><br><span class="line">resOne.RemoveAt(resOne.Count<span class="number">-1</span>);<span class="comment">//回撤</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/18/LeetCode100-51-60/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
