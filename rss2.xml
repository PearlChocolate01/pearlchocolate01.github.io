<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Thu, 15 May 2025 14:48:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode热题100：31-40解析</title>
      <link>https://pearlchocolatezy.com/2025/05/15/LeetCode100-31-40/</link>
      <guid>https://pearlchocolatezy.com/2025/05/15/LeetCode100-31-40/</guid>
      <pubDate>Thu, 15 May 2025 13:43:58 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;36-二叉树的中序遍历（二叉树-94）&quot;&gt;&lt;a href=&quot;#36-二叉树的中序遍历（二叉树-94）&quot; class=&quot;headerlink&quot; title=&quot;36. 二叉树的中序遍历（二叉树/94）&quot;&gt;&lt;/a&gt;36. 二叉树的中序遍历（二叉树/94）&lt;/h3&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="36-二叉树的中序遍历（二叉树-94）"><a href="#36-二叉树的中序遍历（二叉树-94）" class="headerlink" title="36. 二叉树的中序遍历（二叉树/94）"></a>36. 二叉树的中序遍历（二叉树/94）</h3><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。<br>假设：树中节点数目在范围 [0, 100] 内；-100 &lt;= Node.val &lt;= 100。<br>输入：root = [1,null,2,3]；输出：[1,3,2]。</p><blockquote><p>【分析】<br>中序遍历：左子树-&gt;根节点-&gt;右子树<br>简单解法：递归算法。复杂解法：迭代算法。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;</span></span><br><span class="line"><span class="comment"> *     public TreeNode left;</span></span><br><span class="line"><span class="comment"> *     public TreeNode right;</span></span><br><span class="line"><span class="comment"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">InorderTraversal</span>(<span class="params">TreeNode root</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/15/LeetCode100-31-40/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：21-30解析</title>
      <link>https://pearlchocolatezy.com/2025/05/15/LeetCode100-21-30/</link>
      <guid>https://pearlchocolatezy.com/2025/05/15/LeetCode100-21-30/</guid>
      <pubDate>Thu, 15 May 2025 13:42:17 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;22-相交链表（链表-160）&quot;&gt;&lt;a href=&quot;#22-相交链表（链表-160）&quot; class=&quot;headerlink&quot; title=&quot;22. 相交链表（链表/160）&quot;&gt;&lt;/a&gt;22. 相交链表（链表/160）&lt;/h3&gt;&lt;p&gt;给你两个单链表的头节点 head</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="22-相交链表（链表-160）"><a href="#22-相交链表（链表-160）" class="headerlink" title="22. 相交链表（链表/160）"></a>22. 相交链表（链表/160）</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>假设：整个链式结构中不存在环；函数返回结果后，链表必须 保持其原始结构；<br>    intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>    listA - 第一个链表<br>    listB - 第二个链表<br>    skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>    skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>    listA 中节点数目为 m；<br>    listB 中节点数目为 n；<br>    1 &lt;= m, n &lt;= 3 * $(10)^4$；<br>    1 &lt;= Node.val &lt;= $(10)^5$；<br>    0 &lt;= skipA &lt;= m；<br>    0 &lt;= skipB &lt;= n；<br>    如果 listA 和 listB 没有交点，intersectVal 为 0；<br>    如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]。<br>示例：输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3；输出：Intersected at ‘8’。</p><blockquote><p>【分析】<br>链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br>链表的本质就是它的数据结构存在一个变量存储下一个同类型变量（或可能为其地址），<strong>注意看下面ListNode的定义，非常重要！！！</strong><br>链表是一种抽象的结构，代码中看不到整个表，只能看到两两结点之间的关系。<br>由答案可知假设，如果两链表相交，相交以后就不再分开<br>方法1：哈希集合<br>先遍历链表A，把所有A的结点记录在HashSet<ListNode>；后遍历链表B，遇到已存在哈希表中的结点就返回出去。<br>这种方法时间复杂度O(m+n)，空间复杂度O(m)。<br>方法2：双指针法<br>如果 A 到达链表 A 的末尾（null），则将其重定向到链表 B 的头节点 headB。<br>如果 B 到达链表 B 的末尾（null），则将其重定向到链表 A 的头节点 headA。<br>设链表 A 的非公共部分长度为 a，链表 B 的非公共部分长度为 b，公共部分长度为 c。<br>指针 A 走过的路径：a + c + b。<br>指针 B 走过的路径：b + c + a。<br>两者路径长度相同，因此会在相交点相遇。<br>该方法时间复杂度O(m+n)，空间复杂度O(1)。</ListNode></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public int val;// 存储节点的数据值</span></span><br><span class="line"><span class="comment"> *     public ListNode next;// 指向链表中下一个节点的引用</span></span><br><span class="line"><span class="comment"> *     public ListNode(int x) // 构造函数，用于创建一个新的ListNode实例</span></span><br><span class="line"><span class="comment"> *     &#123; </span></span><br><span class="line"><span class="comment"> *        val = x; // 初始化节点的数据值为x</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="comment">//哈希集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">GetInterscetionNode1</span>(<span class="params">ListNode headA, ListNode headB</span>)</span>&#123;</span><br><span class="line">HashSet&lt;ListNode&gt; hashSet=<span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"><span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">hashSet.Add(headA);</span><br><span class="line">headA=headA.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(headB!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(hashSet.Contains(headB))&#123;</span><br><span class="line"><span class="keyword">return</span> headB;</span><br><span class="line">&#125;</span><br><span class="line">headB=headB.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">GetIntersectionNode2</span>(<span class="params">ListNode headA, ListNode headB</span>)</span> &#123;</span><br><span class="line">        ListNode ap=headA, bp=headB;</span><br><span class="line"><span class="keyword">while</span>(ap!=bp)&#123;</span><br><span class="line">ap=ap==<span class="literal">null</span>?headB:ap.next;</span><br><span class="line">bp=bp==<span class="literal">null</span>?headA:bp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/15/LeetCode100-21-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：11-20解析</title>
      <link>https://pearlchocolatezy.com/2025/05/14/LeetCode100-11-21/</link>
      <guid>https://pearlchocolatezy.com/2025/05/14/LeetCode100-11-21/</guid>
      <pubDate>Wed, 14 May 2025 13:48:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;13-最大子数组和（普通数组-53）&quot;&gt;&lt;a href=&quot;#13-最大子数组和（普通数组-53）&quot; class=&quot;headerlink&quot; title=&quot;13. 最大子数组和（普通数组/53）&quot;&gt;&lt;/a&gt;13. 最大子数组和（普通数组/53）&lt;/h3&gt;&lt;p&gt;给你一个</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="13-最大子数组和（普通数组-53）"><a href="#13-最大子数组和（普通数组-53）" class="headerlink" title="13. 最大子数组和（普通数组/53）"></a>13. 最大子数组和（普通数组/53）</h3><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组是数组中的一个连续部分。<br>假设：1 &lt;= nums.length &lt;= $(10)^5$；$(-10)^4$ &lt;= nums[i] &lt;= $(10)^4$。</p><blockquote><p>【分析】<br>Kadane算法：时间复杂度为O(n)。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxSubArray</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> maxGlobal=nums[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> maxHere=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;nums.Length;i++)&#123;<span class="comment">//循环从第二个元素开始</span></span><br><span class="line"><span class="comment">// 如果当前子数组的和加上当前元素大于当前元素本身，说明继续使用当前子数组更优（下面一行代码的第二项）</span></span><br><span class="line"><span class="comment">// 否则，从当前元素开始新的子数组（下面一行代码的第一项）</span></span><br><span class="line">maxHere=Math.Max(nums[i],maxHere+nums[i]);</span><br><span class="line"><span class="comment">// 更新全局最大子数组和</span></span><br><span class="line">maxGlobal=Math.Max(maxHere,maxGlobal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxGlobal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-矩阵置零（矩阵-73）"><a href="#18-矩阵置零（矩阵-73）" class="headerlink" title="18. 矩阵置零（矩阵/73）"></a>18. 矩阵置零（矩阵/73）</h3><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。<br>假设：m == matrix.length；n == matrix[0].length；1 &lt;= m, n &lt;= 200；$(-2)^(31)$ &lt;= <code>matrix[i][j]</code> &lt;= $2^(31)$ - 1。</p><blockquote><p>【分析】<br>原地算法，又称环形矩阵算法，输入的资料通常会被要输出的部分覆盖掉。<br>题解过程中就是，利用矩阵的第一行和第一列来记录这些信息，而不是额外使用数组，以便减少空间复杂度。<br>先记录首行首列是否本身含0；把有0的行或列标记在首行和首列；再遍历整个矩阵，通过首行首列的0，置零整行整列；最后再根据标记置零第一行第一列。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetZeroes</span>(<span class="params"><span class="built_in">int</span>[][] matrix</span>)</span> &#123;</span><br><span class="line"><span class="comment">//int[][] x=...，左项是行数，右项是列数</span></span><br><span class="line"><span class="comment">//二维数组的表示：[[2,3],[1,2,3],[6],[5,0]]</span></span><br><span class="line"><span class="comment">//上述数组有4行，第一行有2列……</span></span><br><span class="line"><span class="comment">//x[0]=[2,3]; x[0]表示第一行</span></span><br><span class="line"><span class="built_in">int</span> m=matrix.Length;</span><br><span class="line"><span class="built_in">int</span> n=matrix[<span class="number">0</span>].Length;</span><br><span class="line"><span class="built_in">bool</span> firstRowHasZero=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">bool</span> firstColHasZero=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// for(int j=0;j&lt;n;j++)&#123;</span></span><br><span class="line"><span class="comment">// if(matrix[0][j]==0)&#123;</span></span><br><span class="line"><span class="comment">// firstRowHasZero=true;</span></span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// for(int i=0;i&lt;m;i++)&#123;</span></span><br><span class="line"><span class="comment">// if(matrix[i][0]==0)&#123;</span></span><br><span class="line"><span class="comment">// firstColHasZero=true;</span></span><br><span class="line"><span class="comment">// break;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//for循环写法和Any的LINQ语法时间空间复杂度一致，时间复杂度=O(n)，空间复杂度=O(1)。（但是LINQ看起来更简洁）</span></span><br><span class="line">firstRowHasZero=matrix[<span class="number">0</span>].Any(c=&gt;c==<span class="number">0</span>);<span class="comment">//检查第一行是否存在0</span></span><br><span class="line">firstColHasZero=matrix.Any(r=&gt;r[<span class="number">0</span>]==<span class="number">0</span>);<span class="comment">//检查第一行是否存在0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span> || matrix[<span class="number">0</span>][j]==<span class="number">0</span>)&#123;</span><br><span class="line">matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(firstRowHasZero)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(firstColHasZero)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/14/LeetCode100-11-21/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：1-10解析</title>
      <link>https://pearlchocolatezy.com/2025/05/07/LeetCode100-1-10/</link>
      <guid>https://pearlchocolatezy.com/2025/05/07/LeetCode100-1-10/</guid>
      <pubDate>Wed, 07 May 2025 14:27:52 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-两数之和（哈希-1）&quot;&gt;&lt;a href=&quot;#1-两数之和（哈希-1）&quot; class=&quot;headerlink&quot; title=&quot;1. 两数之和（哈希/1）&quot;&gt;&lt;/a&gt;1. 两数之和（哈希/1）&lt;/h3&gt;&lt;p&gt;给定一个整数数组nums和一个目标整数target，请在</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-两数之和（哈希-1）"><a href="#1-两数之和（哈希-1）" class="headerlink" title="1. 两数之和（哈希/1）"></a>1. 两数之和（哈希/1）</h3><p>给定一个整数数组nums和一个目标整数target，请在nums中找到和为target的两个整数的数组下标，求一个时间复杂度小于O($n^2$)的算法。<br>假设：每组给定条件只有一个答案；不能使用相同的数组元素；2 &lt;= nums.length &lt;= $(10)^4$；$(-10)^9$ &lt;= nums[i] &lt;= $(10)^9$；$(-10)^9$ &lt;= target &lt;= $(10)^9$。<br>示例：输入：nums = [2,7,11,15], target = 9。输出：[0,1]。</p><blockquote><p>【分析】<br>方法1：暴力法。复杂度O($n^2$)。<br>方法2：双指针法。先对数组排序，创建两个指针，放置在数组一头一尾，分别向中间移动，和大于target则左移右指针，和小于target则右移左指针，直到两指针相遇，可遍历整个数组，而时间复杂度为O(n)。（排序后一定不存在位置交错的解，比如10=1+9=2+8=3+7=4+6，一定是向内对称的）<br>方法3：哈希表法。存储互补数对应的下标的哈希表，检查互补数是否已在哈希表中。（不需要预先排序）（主要考虑这个解法，因为题意不要求数组排序）</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C#使用Dictionary（哈希表法）</span></span><br><span class="line"><span class="comment">//这种方法的时间复杂度为O(n)，空间复杂度也为O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">int</span> ,<span class="built_in">int</span>&gt; dic= <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();<span class="comment">//Key:互补数, Value:下标。 视作哈希表，存储每一位的互补数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> leftAmt= target-nums[i];<span class="comment">//求互补数</span></span><br><span class="line">            <span class="keyword">if</span>(dic.ContainsKey(leftAmt)&amp;&amp;dic[leftAmt]!=i)&#123;<span class="comment">//检查互补数是否已在哈希表中</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;i, dic[leftAmt]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dic.ContainsKey(nums[i]))&#123;</span><br><span class="line">                dic.Add(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123; &#125;;<span class="comment">//没有找到解，返回一个空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法3：哈希表法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target)&#123;</span><br><span class="line">HashMap&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="type">int</span> leftAmt=target-nums[i];</span><br><span class="line"><span class="keyword">if</span>(map.ContainsKey(leftAmt))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(leftAmt),i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2：双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target)&#123;</span><br><span class="line"><span class="type">int</span>[][] originNums=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">2</span>];<span class="comment">//保存原始索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">originNums[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">originNums[i][<span class="number">1</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(originNums,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双指针</span></span><br><span class="line"><span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="type">int</span> sum=originNums[left][<span class="number">0</span>]+originNums[right][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;originNums[left][<span class="number">1</span>],originNums[right][<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-字母异位词分组（哈希-49）"><a href="#2-字母异位词分组（哈希-49）" class="headerlink" title="2. 字母异位词分组（哈希/49）"></a>2. 字母异位词分组（哈希/49）</h3><p>字母异位词：由重新排列源单词的所有字母得到的一个新单词。<br>给定一个字符串数组strs，请将字母异位词组合在一起。<br>假设：1&lt;=strs.length&lt;=$(10)^4$；0&lt;=strs[i].length&lt;=100；strs仅包含小写字母。<br>示例：输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]。输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]。</p><blockquote><p>【分析】<br>找出由相同字母组成的单词，每种字母的个数也相同，分到一组。输出的是一个二维数组。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法：对数组中的每个字符串按字符排序，放入键值对中</span></span><br><span class="line"><span class="comment">//知识点：IList是一个抽象接口，List是它的一个具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="comment">//写法1：</span></span><br><span class="line"><span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs)&#123;</span><br><span class="line">List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; res=<span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>,IList&lt;<span class="built_in">string</span>&gt;&gt; grp=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,IList&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> str <span class="keyword">in</span> strs)&#123;</span><br><span class="line"><span class="built_in">string</span> rt=String.Concat(str.OrderBy(ch=&gt;ch));<span class="comment">//按字符升序排序</span></span><br><span class="line"><span class="keyword">if</span>(grp.ContainsKey(rt))&#123;</span><br><span class="line">grp[rt].Add(str);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">grp[rt]=<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123;str&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> key <span class="keyword">in</span> grp.Keys)&#123;</span><br><span class="line">res.Add(grp[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="keyword">public</span> IList&lt;IList&lt;<span class="built_in">string</span>&gt;&gt; GroupAnagrams(<span class="built_in">string</span>[] strs)</span><br><span class="line">&#123;</span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> str <span class="keyword">in</span> strs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">char</span>[] arr = str.ToCharArray();</span><br><span class="line">Array.Sort(arr);</span><br><span class="line"><span class="built_in">string</span> key = <span class="keyword">new</span> <span class="built_in">string</span>(arr); </span><br><span class="line"><span class="keyword">if</span> (!dic.ContainsKey(key))</span><br><span class="line">dic[key] = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">dic[key].Add(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> List&lt;IList&lt;<span class="built_in">string</span>&gt;&gt;(dic.Values);<span class="comment">//用dic转list</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;string&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String s:strs)&#123;</span><br><span class="line"><span class="type">char</span>[] ca=s.toCharArray();</span><br><span class="line">Array.sort(ca);</span><br><span class="line">String key=String.valueOf(ca);</span><br><span class="line"><span class="keyword">if</span>(!ans.containsKey(key))&#123;</span><br><span class="line">ans.put(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line">ans.get(key).add(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans.values());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-移动零（双指针-283）"><a href="#4-移动零（双指针-283）" class="headerlink" title="4. 移动零（双指针/283）"></a>4. 移动零（双指针/283）</h3><p>给定一个数组nums，将所有0移动到数组的末尾，同时保持非零元素的相对顺序。<br>假设：不能复制数组；1 &lt;= nums.length &lt;= $(10)^4$；$(-2)^(31)$ &lt;= nums[i] &lt;= $2^(31)$ - 1。<br>示例：输入: nums = [0,1,0,3,12]，输出: [1,3,12,0,0]。</p><blockquote><p>【分析】</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> current=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">nums[current]=nums[i];<span class="comment">//一定是往前替换0，不会出现非0数被替换的情况</span></span><br><span class="line"><span class="keyword">if</span>(current!=i)&#123;</span><br><span class="line">nums[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">current++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-盛最多水的容器（双指针-11）"><a href="#5-盛最多水的容器（双指针-11）" class="headerlink" title="5. 盛最多水的容器（双指针/11）"></a>5. 盛最多水的容器（双指针/11）</h3><p>给定一个长度为n的整数数组heightArr，有n条垂线，第i条线的两个端点是(i,0)和(i,heightArr[i])。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水，返回容器可存储的最大水量。</p><blockquote><p>【分析】<br>面积按最短板来求，在两个指针移动过程中求最大面积。<br>因为每一次都重新取最大值，所以高度数组不用提前排序。<br>间复杂度为 O(n)，空间复杂度为 O(1)。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxArea</span>(<span class="params"><span class="built_in">int</span>[] heightArr</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> left=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> right=heightArr.Length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="built_in">int</span> currentArea=Math.Min(heightArr[left],heightArr[right])*(right-left);</span><br><span class="line">maxArea=Math.Max(maxArea,currentArea);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(heightArr[left]&lt;heightArr[right])&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-无重复字符的最长子串（滑动窗口-3）"><a href="#8-无重复字符的最长子串（滑动窗口-3）" class="headerlink" title="8. 无重复字符的最长子串（滑动窗口/3）"></a>8. 无重复字符的最长子串（滑动窗口/3）</h3><p>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。<br>假设：0 &lt;= s.length &lt;= 5 * $(10)^4$；s 由英文字母、数字、符号和空格组成。<br>示例：输入: s = “pwwkew”；输出: 3。（最长子串是“wke”）</p><blockquote><p>【分析】<br>解法：滑动窗口。<br>这种方法的核心思想是使用两个指针来表示当前考察的子串的左右边界，并通过移动右边界来扩展子串，如果遇到重复字符，则移动左边界来缩小子串，直到重复字符被移除。在这个过程中，我们维护一个变量来记录当前无重复字符的最长子串的长度。<br>（1）使用HashSet作为滑动窗口。时间复杂度：O(2n) = O(n)，空间复杂度：O(min(m,n)) 。<br>HashSet<T> 是一个非常有用的集合类，是基于哈希表实现的，提供了平均时间复杂度为 O(1) 的操作性能。HashSet<T> 中的元素没有特定的顺序；集合中的元素是唯一的；添加、删除和查找操作的平均时间复杂度为 O(1)；不是线程安全的（如果在多线程环境中，可以使用Dictionary）。<br>（2）使用Dictionary的滑动窗口。时间复杂度：O(n)，空间复杂度：O(min(m,n)) 。</T></T></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LengthOfLongestSubstring</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>&#123;</span><br><span class="line">Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt; dic=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">char</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="built_in">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> left=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> right=<span class="number">0</span>;right&lt;s.Length;right++)&#123;</span><br><span class="line"><span class="built_in">char</span> c=s[right];</span><br><span class="line"><span class="keyword">if</span>(dic.ContainsKey(c))&#123;</span><br><span class="line">left=Math.Max(dic[c]+<span class="number">1</span>,left);</span><br><span class="line">&#125;</span><br><span class="line">dic[c]=right;</span><br><span class="line">result=Math.Max(result,right-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-和为K的子数组（子串-560）"><a href="#10-和为K的子数组（子串-560）" class="headerlink" title="10. 和为K的子数组（子串/560）"></a>10. 和为K的子数组（子串/560）</h3><p>给定一个整数数组nums和一个整数k，请统计并返回该数组中和为k的子数组的个数。<br>子数组是数组中元素的连续非空序列。<br>假设：1 &lt;= nums.length &lt;= 2 * $(10)^4$；-1000 &lt;= nums[i] &lt;= 1000；$(-10)^7$ &lt;= k &lt;= $(10)^7$。<br>示例：输入：nums = [1,2,3], k = 3；输出：2。<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">SubarraySum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; prefixSum=<span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">prefixSum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">sum+=nums[i];</span><br><span class="line"><span class="built_in">int</span> target=sum-k;</span><br><span class="line"><span class="keyword">if</span>(prefixSum.ContainsKey(target))&#123;</span><br><span class="line">count+=prefixSum[target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!prefixSum.ContainsKey(sum))&#123;</span><br><span class="line">prefixSum[sum]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">prefixSum[sum]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/07/LeetCode100-1-10/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Pgsql小技巧</title>
      <link>https://pearlchocolatezy.com/2025/04/17/PgsqlTips/</link>
      <guid>https://pearlchocolatezy.com/2025/04/17/PgsqlTips/</guid>
      <pubDate>Thu, 17 Apr 2025 13:58:56 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个用逗号隔开的id字符串内，怎样用where in查找某个指定id：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li><p>一个用逗号隔开的id字符串内，怎样用where in查找某个指定id：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将用逗号隔开的id字符串转为可供where in使用的数组</span></span><br><span class="line"><span class="comment">--写法1：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="string">&#x27;目标id&#x27;</span> <span class="keyword">in</span> <span class="keyword">any</span>(string_to_array(id_list,<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--写法2：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id::text <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">unnest</span>((string_to_array(id_list,<span class="string">&#x27;,&#x27;</span>))))</span><br></pre></td></tr></table></figure></li><li><p>时间类型用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--已有两个月初的日期，展示这两个日期之间所有月的月初：</span></span><br><span class="line"><span class="keyword">select</span> generate_series(start_date,end_date,<span class="string">&#x27;1 month&#x27;</span>::<span class="type">interval</span>) <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> start_date,end_date <span class="keyword">from</span> <span class="keyword">table</span></span><br><span class="line">) t</span><br><span class="line"></span><br><span class="line"><span class="comment">--日期字符串转特定格式</span></span><br><span class="line"><span class="keyword">select</span> to_timestamp(<span class="string">&#x27;2023-10-01 21:30:00&#x27;</span>,<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>REGEXP_SPLIT_TO_TABLE:行转列，string_agg:列转行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将id字段的每个值转为某字符隔开的一个字符串：</span></span><br><span class="line"><span class="keyword">select</span> string_agg(id,<span class="string">&#x27;-&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> id::text) <span class="keyword">as</span> ids <span class="keyword">from</span> <span class="keyword">table</span>;<span class="comment">--string_agg带order by</span></span><br><span class="line"><span class="keyword">select</span> string_agg(id,<span class="string">&#x27;;&#x27;</span>) <span class="keyword">filter</span> (<span class="keyword">where</span> id<span class="operator">&lt;&gt;</span><span class="string">&#x27;abc&#x27;</span>) <span class="keyword">from</span> <span class="keyword">table</span>;<span class="comment">--string_agg带filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--将一个用斜杠隔开的id字符串转为列分别展示每个id：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> REGEXP_SPLIT_TO_TABLE((<span class="keyword">select</span> ids <span class="keyword">from</span> <span class="keyword">table</span>), <span class="string">&#x27;/&#x27;</span>)<span class="comment">--这个查询可以作为in条件</span></span><br></pre></td></tr></table></figure></li><li><p>json/jsonb类型用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--json/jsonb内可以是对象数组，也可以是对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--添加/修改jsonb属性：第四个参数，如果不填表示update，如果值为true表示如果没有该属性则增加，有则更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> attr <span class="operator">=</span> jsonb_set(<span class="built_in">COALESCE</span>(attr, <span class="string">&#x27;&#123;&#125;&#x27;</span>::jsonb), <span class="string">&#x27;&#123;property&#125;&#x27;</span>,<span class="string">&#x27;&quot;content&quot;&#x27;</span>, <span class="literal">true</span>) <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--移除某一属性</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> attr<span class="operator">=</span>attr::jsonb <span class="operator">-</span> <span class="string">&#x27;property&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--读取整个jsonb单元格：</span></span><br><span class="line"><span class="keyword">select</span> attr::jsonb <span class="keyword">from</span> <span class="keyword">table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--读取jsonb（对象）某一属性</span></span><br><span class="line"><span class="keyword">select</span> attr<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;property&#x27;</span> <span class="keyword">as</span> prop <span class="keyword">from</span> <span class="keyword">table</span>;<span class="comment">--读出了属性值原本的数据类型</span></span><br><span class="line"><span class="keyword">select</span> attr<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;property&#x27;</span> <span class="keyword">as</span> prop <span class="keyword">from</span> <span class="keyword">table</span>;<span class="comment">--将属性值转为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--将对象数组中的每个对象转变为多行（json中的行转列）：</span></span><br><span class="line"><span class="keyword">SELECT</span> (jsonb_array_elements_text(attr<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;property&#x27;</span>))::jsonb <span class="keyword">as</span> <span class="type">row</span> <span class="keyword">from</span> <span class="keyword">table</span><span class="comment">--attr是对象，attr中属性property的值是数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--从对象数组中取出每一对象内的某一属性，归类合并在同一行里（json中的先行转列，再列转行）：</span></span><br><span class="line"><span class="keyword">select</span> string_agg(<span class="type">row</span><span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;prop1&#x27;</span>,<span class="string">&#x27;,&#x27;</span>) <span class="keyword">as</span> ids <span class="keyword">from</span> (<span class="comment">--从对象数组property中获取每一组的属性prop1的值，组成逗号隔开的字符串</span></span><br><span class="line"><span class="keyword">select</span> (jsonb_array_elements_text(attr<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;property&#x27;</span>))::jsonb <span class="keyword">as</span> <span class="type">row</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">123</span><span class="comment">--attr是对象，attr中属性property的值是对象数组</span></span><br><span class="line">) t</span><br></pre></td></tr></table></figure></li><li><p>序号自增</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> id) <span class="keyword">as</span> <span class="keyword">no</span> <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure></li><li><p>sql查询为空时如何显示一行空记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">999</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">as</span> a, <span class="string">&#x27;&#x27;</span> <span class="keyword">as</span> b, <span class="number">0</span> <span class="keyword">as</span> c <span class="keyword">from</span> <span class="keyword">table</span></span><br><span class="line">) limit <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>按中文拼音排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> convert_to(<span class="keyword">column</span>,<span class="string">&#x27;GBK&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/04/17/PgsqlTips/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JS实现异步复制</title>
      <link>https://pearlchocolatezy.com/2025/04/17/JS-copy/</link>
      <guid>https://pearlchocolatezy.com/2025/04/17/JS-copy/</guid>
      <pubDate>Thu, 17 Apr 2025 13:49:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;为HTML元素添加点击事件&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c</description>
        
      
      
      
      <content:encoded><![CDATA[<p>为HTML元素添加点击事件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;copyFun(&#x27;text for copy&#x27;)&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br>使用JavaScript自带的Clipboard API（需要HTTPS或localhost）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copyFun</span>(<span class="params">text</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步复制成功！&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步复制失败：&#x27;</span>,err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/04/17/JS-copy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TCP拥塞控制</title>
      <link>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/</link>
      <guid>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/</guid>
      <pubDate>Mon, 17 Mar 2025 13:26:38 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;一、原理-概念&quot;&gt;&lt;a href=&quot;#一、原理-概念&quot; class=&quot;headerlink&quot; title=&quot;一、原理/概念&quot;&gt;&lt;/a&gt;一、原理/概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;拥塞：某段时间内，对网络的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="一、原理-概念"><a href="#一、原理-概念" class="headerlink" title="一、原理/概念"></a>一、原理/概念</h3><ol><li>拥塞：某段时间内，对网络的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫拥塞。</li><li>拥塞的直接后果：（1）时延增加；（2）分组丢弃。</li><li>拥塞控制：通过合理调度、规范、调整向网络中发送数据的主机数量、发送速率或数据量，以避免拥塞或尽快消除已发生的拥塞。</li><li>拥塞控制与流量控制的区别：拥塞控制就是防止过多的数据注入到网络中这样可以使网络中的路由器或链路不至于过载，拥塞控制有一个前提，就是网络能够承受现有的网络负荷，他是一个全局性过程。而流量控制往往是指点对点通信量的控制，是个端到端的问题。</li></ol><h3 id="二、方法-算法"><a href="#二、方法-算法" class="headerlink" title="二、方法/算法"></a>二、方法/算法</h3><p><pre class="mermaid">graph LRA[拥塞控制策略] -->B[拥塞预防]A-->C[拥塞消除]B-->B1[流量感知路由]B-->B2[准入控制]C-->|网络层| D[基于拥塞状态反馈的拥塞控制方法]C-->|传输层| E[无须拥塞状态反馈的拥塞控制方法]E-->F[慢开始 - 拥塞避免 - 快重传 - 快恢复]D-->D1[抑制分组]D-->D2[背压]D-->D3[负载脱落]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div><br>无须进行拥塞状态反馈的拥塞控制方法：在主机(即端系统)推断网络是否发生拥塞（是否发生报文段的超时），如果推断网络已发生拥塞，则主动调整向网络中发送数据的速率和数据量，以便消除拥塞。e.g.TCP拥塞控制。</p><p>TCP进行拥塞控制的算法有四种（拥塞控制过程的四个部分）：慢开始，拥塞避免，快重传，快恢复。</p><p>窗口是什么？ 拥塞窗口是一个状态变量，变量大小取决于网络拥塞程度。<br>MSS是指TCP/IP协议栈中TCP协议层所能发送的最大报文段长度。</p><p>TCP 的拥塞控制也叫做基于窗口的拥塞控制。为此，发送方维持了叫做<strong>拥塞窗口 cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。发送方让自己的发送窗口等于拥塞窗口。<br><img src="/2025/03/17/13017-TCP-CC/TCP拥塞控制.png" width="70%"><br><img src="/2025/03/17/13017-TCP-CC/TCP拥塞控制2.png" width="70%"></p><p>发送方控制拥塞窗口cwnd的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提供网络的利用率。但只要网络出现拥塞或者可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。<br>当网络发生拥塞时，路由器就要丢弃分组。只要发送方没有按时收到应当到达的确认报文，即出现了超时，可判断出现了网络拥塞。</p><p>TCP拥塞控制的窗口调节分为慢启动阶段和拥塞避免阶段，慢启动阶段窗口从一个MSS快速增长，达到某个阈值后转为拥塞避免阶段，拥塞避免阶段的窗口增长放慢。</p><p>慢启动阶段，每收到1个确认段，拥塞窗口增加1个MSS，每经过1RTT，拥塞窗口增长1倍；<br>在拥塞避免阶段，每经过l个RTT，拥塞窗口增加1个MSS。<br>发生超时（丢包）时，cwnd降至1MSS，阈值下降一半。<br>3次重复确认（丢包）时，旧版Tahoe中cwnd降至1MSS，新版Reno只下降一半。（题意不明时以新版为主）阈值均下降一半。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/17/13017-TCP-CC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13017 计算机网络与信息安全——计算题</title>
      <link>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/</link>
      <guid>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/</guid>
      <pubDate>Mon, 17 Mar 2025 12:53:40 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。&quot;&gt;&lt;a href=&quot;#</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。"><a href="#1-当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit-s。" class="headerlink" title="1. 当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到8Mbit/s。"></a>1. 当用户线路长度在3-5km，ADSL技术标准允许的下行速率最高可以达到<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">8Mbit/s</i>。</h3><p>【分析】计算机网络结构分为：①网络边缘 ②接入网络 ③网络核心<br>常见的接入网络：电话拨号接入、ADSL、HFC、局域网、移动接入网络。<br>ADSL（Asymmehic Digital Subscriber Line，非对称数字用户线路）是利用现有的电话网络的用户线路实现的接入网络。是家庭用户接入网络中常见的接入网络之一。<br>ASDL可以实现的上行和下行带宽与用户线路的长度有关系，当用户线路长度在3~5km范围内时，典型的上行带宽为 512kbit/s ~ 1Mbit/s，下行带宽为 1Mbit/s ~ 8Mbit/s。（记忆）<font color="mediumvioletred">（ADSL上行带宽比下行带宽小）</font></p><h3 id="2-主机A到主机B之间有一条链路，长度D-100m，带宽R-10-8-bit-s，信号传播速率V-250000km-s。如果主机A从t-0时刻向主机B发送长度L-1024bit的分组，求："><a href="#2-主机A到主机B之间有一条链路，长度D-100m，带宽R-10-8-bit-s，信号传播速率V-250000km-s。如果主机A从t-0时刻向主机B发送长度L-1024bit的分组，求：" class="headerlink" title="2. 主机A到主机B之间有一条链路，长度D=100m，带宽R=$10^8$bit/s，信号传播速率V=250000km/s。如果主机A从t=0时刻向主机B发送长度L=1024bit的分组，求："></a>2. 主机A到主机B之间有一条链路，长度D=100m，带宽R=$10^8$bit/s，信号传播速率V=250000km/s。如果主机A从t=0时刻向主机B发送长度L=1024bit的分组，求：</h3><h3 id="（1）主机A和主机B间的链路传输延迟-d-t-；"><a href="#（1）主机A和主机B间的链路传输延迟-d-t-；" class="headerlink" title="（1）主机A和主机B间的链路传输延迟$d_t$；"></a>（1）主机A和主机B间的链路传输延迟$d_t$；</h3><h3 id="（2）主机A发送该分组的传播延迟-d-p-；"><a href="#（2）主机A发送该分组的传播延迟-d-p-；" class="headerlink" title="（2）主机A发送该分组的传播延迟$d_p$；"></a>（2）主机A发送该分组的传播延迟$d_p$；</h3><h3 id="（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；"><a href="#（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；" class="headerlink" title="（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；"></a>（3）该分组从主机A到主机B的延迟T（忽略节点处理延迟和排队延迟）；</h3><h3 id="（4）在t-d-t-时刻，分组的第一位在何处，并说明原因；"><a href="#（4）在t-d-t-时刻，分组的第一位在何处，并说明原因；" class="headerlink" title="（4）在t=$d_t$时刻，分组的第一位在何处，并说明原因；"></a>（4）在t=$d_t$时刻，分组的第一位在何处，并说明原因；</h3><h3 id="（5）主机A与主机B之间链路的时延带宽积。"><a href="#（5）主机A与主机B之间链路的时延带宽积。" class="headerlink" title="（5）主机A与主机B之间链路的时延带宽积。"></a>（5）主机A与主机B之间链路的时延带宽积。</h3><blockquote><p>(1) <script type="math/tex">d_t=\frac{L}{R}=\frac{1024bit}{10^8bit/s}=1.024*10^{-5}s</script><br>(2) <script type="math/tex">d_p=\frac{100m}{250000km/s}=4*10^{-7}s</script><br>(3) <script type="math/tex">T=d_t+d_p=1.064*10^{-5}s</script><br>(4) 分组的第一位已到达主机B，因为<script type="math/tex">d_t>d_p</script></p></blockquote><p>【分析】个人认为问题（1）（2）的叙述有问题，传输延迟是发送方处理的（是指数据从发送端开始进入链路直到完全进入链路所需的时间），是数据上的；传播延迟才是在链路上的，是物理上的。<br><img src="/2025/03/17/LearnNet13017-2/4种时延.png" width="50%"></p><h3 id="3-若信号传播速度250000km-s-链路带宽1000Mbit-s-则时延带宽积刚好为分组长度1024bit时得到链路长度为256m。"><a href="#3-若信号传播速度250000km-s-链路带宽1000Mbit-s-则时延带宽积刚好为分组长度1024bit时得到链路长度为256m。" class="headerlink" title="3. 若信号传播速度250000km/s,链路带宽1000Mbit/s,则时延带宽积刚好为分组长度1024bit时得到链路长度为256m。"></a>3. 若信号传播速度250000km/s,链路带宽1000Mbit/s,则时延带宽积刚好为分组长度1024bit时得到链路长度为<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">256m</i>。</h3><blockquote><p><font color="mediumvioletred">物理:D,V  数据:L,R</font><br>V=2.5×$10^8$m/s<br>R=$10^9$bps<br>L=1024bit<br>G=$d_p×R=\frac{D}{V}×R=\frac{D}{2.5×10^8}×10^9=1024bit$<br>∴ 4D=1024<br>D=256m</p></blockquote><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><h2 id="三、传输层"><a href="#三、传输层" class="headerlink" title="三、传输层"></a>三、传输层</h2><h3 id="1-假设甲、乙双方采用GBN协议发送报文段，甲已经发送了编号为0-7的报文段。当计时器超时时，若甲只收到0号和3号报文段的确认，则甲需要重发的报文段有哪些？"><a href="#1-假设甲、乙双方采用GBN协议发送报文段，甲已经发送了编号为0-7的报文段。当计时器超时时，若甲只收到0号和3号报文段的确认，则甲需要重发的报文段有哪些？" class="headerlink" title="1. 假设甲、乙双方采用GBN协议发送报文段，甲已经发送了编号为0~7的报文段。当计时器超时时，若甲只收到0号和3号报文段的确认，则甲需要重发的报文段有哪些？"></a>1. 假设甲、乙双方采用<font color="mediumvioletred">GBN协议</font>发送报文段，甲已经发送了编号为0~7的报文段。当计时器超时时，若甲只收到0号和3号报文段的确认，则甲需要重发的报文段有哪些？</h3><blockquote><p>4~7号报文段要重新发送。</p></blockquote><p>【分析】GBN协议采用累积确认机制：即接收方只能按序接收数据分组，当发送方收到$ACK_n$时，表明接收方已正确接收序号$\le{n}$的所有分组。<br>GBN协议发送端的发送窗口数量$W_s\ge1$，接收端的接收窗口数量$W_r=1$（GBN协议的接收端无缓存能力，不能缓存未按序到达的分组）。<br>GBN发送方必须响应的三种事件：<br>（1）上层调用；<br>（2）收到1个$ACK_n$；<br>（3）计时器超时。<br>发送方收到3号帧的确认，意味着0、1、2、3号帧已被接收，因此需要重传的帧是 4、5、6、7 号帧。</p><h3 id="2-主机甲、乙通过128kbit-s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80-，分组序号字段的位数至少要达到多少？"><a href="#2-主机甲、乙通过128kbit-s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80-，分组序号字段的位数至少要达到多少？" class="headerlink" title="2. 主机甲、乙通过128kbit/s卫星信道互连，采用滑动窗口协议发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80%，分组序号字段的位数至少要达到多少？"></a>2. 主机甲、乙通过128kbit/s卫星信道互连，采用<font color="mediumvioletred">滑动窗口协议</font>发送数据，链路单向传播时延为250ms，分组长度为1000B。不考虑确认分组的开销，为使信道利用率不小于80%，分组序号字段的位数至少要达到多少？</h3><blockquote><p>至少4位。</p></blockquote><p><img src="/2025/03/17/LearnNet13017-2/滑动窗口协议.png" width="70%"><br>【分析】（本题的分组理解为图上的帧）数据链路层，一次发一帧，相当于一次发1000B。发送帧有延迟，确认帧无延迟。<br>发送一帧的时间=发送延迟+发送时延+接收时延+接受延迟（接受延迟为0），即图中的a+b+c。<font color="silver">（一个RTT=一组发送时延+接收时延）</font><br>发送一帧的时间= $t_{seg}$ +RTT+ $t_{ack}$ ，本题$t_{seg}$=250ms，$t_{ack}$=0，RTT=1000*8bit/(128*1000)*2=1/$2_4$ms<br>按照信号利用率公式：<script type="math/tex">U_{sender} = \frac{W_s \times t_{seg}}{t_{seg}+RTT+t_{ack}}</script><br>发送延迟=一帧长度的发送延迟=$t_{seg}$=1000*8bit/(128*1000)=1/$2^3$ms<br>$W_s$相当于发送窗口的个数。</p><script type="math/tex; mode=display">U_{sender} = \frac{W_s \times 1/2^3}{1/2^4 + 1/2^3} \ge 0.8</script><script type="math/tex; mode=display">W_s \ge 7.2</script><p>分组序号范围是[1,$2^{n-1}$]<br>至少有：$7.2 \le W_s \le 8=2^3=2^{4-1}$<br>即窗口个数至少为8，n（位数）至少为4。</p><h3 id="3-若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？"><a href="#3-若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？" class="headerlink" title="3. 若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？"></a>3. 若甲、乙之间已建立一条TCP连接，拥塞控制处于拥塞避免阶段，阈值为8MSS，当甲的拥塞窗口大小为24MSS时发生了超时，则甲的拥塞窗口和阈值将分别调整为多少？</h3><blockquote><p>阈值=24/2=12MSS<br>拥塞窗口=1MSS</p></blockquote><p>【分析】结合 <a href="/2025/03/17/13017-TCP-CC/" title="TCP拥塞控制">TCP拥塞控制</a> 理解。<br>TCP拥塞避免阶段发生超时，cwnd降至1MSS，阈值降至原来的一半。</p><h3 id="4-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？"><a href="#4-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？" class="headerlink" title="4. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？"></a>4. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了两个连续的TCP报文段，分别包含300B和500B的有效载荷，第一个报文段的序号为200，主机乙正确接收两个报文段后，发送给主机甲的确认序号是多少？</h3><blockquote><p>第一个报文段的确认序列号是200+300=500<br>第二个报文段的确认序列号是500+500=1000</p></blockquote><p>【分析】<font color="mediumvioletred">确认序列号=原始序列号+TCP段的长度</font></p><h3 id="5-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？"><a href="#5-主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？" class="headerlink" title="5. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？"></a>5. 主机甲与主机乙之间已建立一条TCP连接，主机甲向主机乙发送了3个连续的TCP报文段，分别包含300B、400B和500B的有效载荷，第3个报文段的序号为900。若主机乙仅正确接收到第1和第3个报文段，则主机乙发送给主机甲的确认序号是多少？</h3><blockquote><p>500</p></blockquote><p>【分析】题目中给出的某个报文段的序号就是原始序列号。<br><img src="/2025/03/17/LearnNet13017-2/确认序号.png" width="60%"><br>由于TCP是累积确认，收到了第3段没收到第2段的情况，确认序号仍停留在第一段的末尾第二段的起始，即500。</p><h3 id="6-主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？"><a href="#6-主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？" class="headerlink" title="6. 主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？"></a>6. 主机甲与主机乙之间已建立一条TCP连接，双方持续有数据传输，且数据无差错与丢失。若甲收到1个来自乙的TCP报文段，该报文段的序号为1913、确认序号为2046、有效载荷为100B，则甲立即发送给乙的TCP报文段的序号和确认序号分别是多少？</h3><blockquote><p>2046 2013</p></blockquote><p>【分析】考查TCP的数据编号与确认。<br>有效载荷为100B，即TCP段长度为100B。报文段的序号即该报文段的原始序号，即乙发送给甲的，即甲发送之前的，是1913。那么甲即将要发送的报文段的初始序号=乙发来的报文段的确认序号=1913+100=2013。<br>交错现象的出现是因为TCP使用累积确认，这意味着确认号表示接收方期望收到的下一个字节的序号。<br>当接收方收到一个数据段后，它发送一个确认，这个确认号表示接收方已经成功接收了所有序号小于或等于确认号的数据。<br>乙发来的确认号是2046，表示乙成功接收所有序号小于等于2045的数据；<br>甲发送的确认号是2013，表示甲成功接收所有序号小于等于2012的数据。</p><font color="mediumvioletred">初始序列号是对方的报文走到哪个位置。<br>确认序列号是自己的报文走到哪个位置。</font><h3 id="7-主机甲和主机乙已建立TCP连接，甲始终以MSS-1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？"><a href="#7-主机甲和主机乙已建立TCP连接，甲始终以MSS-1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？" class="headerlink" title="7. 主机甲和主机乙已建立TCP连接，甲始终以MSS=1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？"></a>7. 主机甲和主机乙已建立TCP连接，甲始终以MSS=1KB大小的报文段发送数据，并一直有数据发送；乙每收到一个报文段都会发出一个接收窗口大小为10KB的确认段。若甲在t时刻发生超时时拥塞窗口大小为8KB，则从t时刻起，不再发生超时的情况下，经过10个RTT后，甲的发送窗口大小是多少？</h3><blockquote><p>10KB</p></blockquote><p>【分析】从发生超时的那一刻起，阈值调整为t时刻cwnd大小的一半，即ssthresh=8KB/2=4KB。<br>RTT=1, cwnd=1MSS<br>RTT=2, cwnd=2MSS<br>RTT=3, cwnd=4MSS, 此时到达门限值ssthresh，之后进入拥塞避免阶段<br>RTT=4, cwnd=5MSS, cwnd会一直线性增长到接收窗口大小<br>RTT=5, cwnd=6MSS<br>RTT=6, cwnd=7MSS<br>RTT=7, cwnd=8MSS<br>RTT=8, cwnd=9MSS<br>RTT=9, cwnd=10MSS<br>RTT=10, cwnd=10MSS, 发送端不能超过接收端10，此后拥塞窗口一直保持cwnd=10KB。</p><h3 id="8-主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？"><a href="#8-主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？" class="headerlink" title="8. 主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？"></a>8. 主机甲和主机乙之间已建立一条TCP连接，TCP最大报文段长度为1000B。若主机甲的当前拥塞窗口大小为4000B，它向主机乙连续发送两个最大报文段后，成功收到主机乙发送的对第一个报文段的确认，确认段中通告的接收窗口大小为2000B，则随后主机甲还可以继续向主机乙发送的最大字节数是多少？</h3><blockquote><p>1000B</p></blockquote><p>【分析】甲总共发送了2000B给乙，只确认了1000B，还有1000B未确认，说明乙的接收窗口还有1000B未确认占用了总共2000B的空间，剩下最多可接收1000B，1000B&lt;=4000B，因此甲最大可发1000B（最大还能发一个报文段）。</p><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="1-请将建网络183-164-128-0-17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"><a href="#1-请将建网络183-164-128-0-17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。" class="headerlink" title="1. 请将建网络183.164.128.0/17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"></a>1. 请将建网络183.164.128.0/17划分为等长的8个子网，并分别给出每个子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。</h3><div class="table-container"><table><thead><tr><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP总数</th><th>可分配IP数量</th><th>可分配IP范围</th></tr></thead><tbody><tr><td>183.164.128.0/20</td><td>183.164.143.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.128.1 ~ 183.164.143.254</td></tr><tr><td>183.164.144.0/20</td><td>183.164.159.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.144.1 ~ 183.164.159.254</td></tr><tr><td>183.164.160.0/20</td><td>183.164.175.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.160.1 ~ 183.164.175.254</td></tr><tr><td>183.164.176.0/20</td><td>183.164.191.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.176.1 ~ 183.164.191.254</td></tr><tr><td>183.164.192.0/20</td><td>183.164.206.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.192.1 ~ 183.164.206.254</td></tr><tr><td>183.164.207.0/20</td><td>183.164.211.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.207.1 ~ 183.164.211.254</td></tr><tr><td>183.164.212.0/20</td><td>183.164.226.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.212.1 ~ 183.164.226.254</td></tr><tr><td>183.164.227.0/20</td><td>183.164.241.255</td><td>255.255.240.0</td><td>4096</td><td>4094</td><td>183.164.227.1 ~ 183.164.256.254</td></tr></tbody></table></div><p>【分析】IP网络地址183.164.128.0/17：前17位是网络部分，用于标识网络；剩余的（32-17）15位是主机部分，用于标识该网络中的单个设备。183.164.128.0/17表示的是一个包含$2^{(32-17)} = 2^{15} = 32768$个地址的网络，其中包含32766个可用的主机地址（因为一个地址用于网络地址，一个用于广播地址）。这个网络的范围从183.164.128.0到183.164.255.255。<br>网络地址：在任何网络中，网络地址总是该网络的第一个地址。对于183.164.128.0/17这个网络，网络地址就是183.164.128.0。<br>广播地址：广播地址是该网络的最后一个地址，用于向该网络内的所有主机发送数据包。对于183.164.128.0/17这个网络，广播地址是183.164.255.255。<br>剩下的32766个可以分配给主机。</p><p>183.164.128.0/17分为8个子网，$2^3$=8，所以我们需要3位来划分子网。<br>分为8个子网后，网络部分有17+3=20位，剩下12位可分给主机。<br>183.164.128.0也就是183.164.10000000.0（第三个位置用8个二进制表示），子网地址紧跟在前17位后面，即占用18、19、20三位来划分：<br>（绿色部分4+8=12位用于分配主机，共$2^{12}$个主机地址，第一个分给子网的网络地址，最后一个分给广播地址，剩下中间$2^{12}-2$个分配给主机）<br>183.164.1<font color="mediumvioletred">000</font><font color="limegreen">0000.0</font>，<br>183.164.1<font color="mediumvioletred">001</font>0000.0，<br>183.164.1<font color="mediumvioletred">010</font>0000.0，<br>183.164.1<font color="mediumvioletred">011</font>0000.0，<br>183.164.1<font color="mediumvioletred">100</font>0000.0，<br>183.164.1<font color="mediumvioletred">101</font>0000.0，<br>183.164.1<font color="mediumvioletred">110</font>0000.0，<br>183.164.1<font color="mediumvioletred">111</font>0000.0。<br>广播地址：就是前20位网络地址不变，主机地址的12位IP地址都是1：183.164.1XXX1111.255。（表示每个子网的最后一个地址）<br>子网掩码：就是就是前20位网络地址全为1，主机地址的12位IP地址都是0。所以8个子网的子网掩码是一样的：255.255.11110000.0即255.255.240.0。<br>IP总数：共（32-20）12位可用于分配，每个子网有$2^{12}=4096$个。<br>可分配的IP地址：主机地址全为0是该子网的子网地址，全为1是该子网的广播地址，每个子网有4096-2=4094个。<br>可分配IP地址范围：子网地址末尾+1 ~ 广播地址末尾-1。</p><h3 id="2-某ISP拥有一个网络地址块201-123-16-0-21-现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"><a href="#2-某ISP拥有一个网络地址块201-123-16-0-21-现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。" class="headerlink" title="2. 某ISP拥有一个网络地址块201.123.16.0/21, 现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。"></a>2. 某ISP拥有一个网络地址块201.123.16.0/21, 现在该ISP要为4个组织分配IP地址，它们需要的地址数量分别为985、486、246及211，请给出一个合理的分配方案，并说明各组织所分配子网的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。</h3><div class="table-container"><table><thead><tr><th>组织</th><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP总数</th><th>可分配IP数量</th><th>IP地址数</th><th>可分配IP范围</th></tr></thead><tbody><tr><td>A</td><td>201.123.16.0/20</td><td>201.123.19.255</td><td>255.255.248.0</td><td>1024</td><td>1022</td><td>985</td><td>201.123.16.1 ~ 201.123.19.254</td></tr><tr><td>B</td><td>201.123.20.0/20</td><td>201.123.21.255</td><td>255.255.248.0</td><td>512</td><td>510</td><td>486</td><td>201.123.20.1 ~ 201.123.21.254</td></tr><tr><td>C</td><td>201.123.22.0/20</td><td>201.123.22.255</td><td>255.255.248.0</td><td>256</td><td>254</td><td>246</td><td>201.123.22.1 ~ 201.123.22.254</td></tr><tr><td>D</td><td>201.123.23.0/20</td><td>201.123.23.255</td><td>255.255.248.0</td><td>256</td><td>254</td><td>211</td><td>201.123.23.1 ~ 201.123.23.254</td></tr></tbody></table></div><p>【分析】201.123.16.0第三个位置写成二进制：0001 0000，题意已经给出前21位为网络部分，剩余（32-21）=11（3+8）位。<br>子网掩码：（21个1）1111 1111.1111 1111.1111 1000.0000 0000 即255.255.248.0<br>$2^{10}$=1048 &lt; 985+486+246+211=1928 &lt; 2048=$2^{11}$<br>哈夫曼树：</p><p><pre class="mermaid">graph TD    A[2048] --> |0| B1[组织A:1024]    A --> |1| B2[1024]    B2 --> |0| C1[组织B:512]    B2 --> |1| C2[512]    C2 --> |0| D1[组织C:256]    C2 --> |1| D2[组织D:256]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div><br>给第一个子网分配1024=$2^{10}$个地址，组织A实际只用985。范围为：<br>201.123.0001 0<font color="limegreen">000.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">011.1111 1111</font>最大（广播地址）</p><p>给第二个子网分配512=$2^9$个地址，组织B实际只用486。范围为：<br>201.123.0001 0<font color="limegreen">100.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">101.1111 1111</font>最大（广播地址）</p><p>给第三个子网分配256=$2^8$个地址，组织C实际只用256。范围为：<br>201.123.0001 0<font color="limegreen">110.0000 0000</font>最小（子网地址 ~<br>201.123.0001 0<font color="limegreen">110.1111 1111</font>最大（广播地址）</p><p>给第四个子网分配256=$2^8$个地址，组织D实际只用256。范围为：<br>201.123.0001 0<font color="limegreen">111.0000 0000</font>最小（子网地址） ~<br>201.123.0001 0<font color="limegreen">111.1111 1111</font>最大（广播地址）</p><h3 id="3-现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？"><a href="#3-现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？" class="headerlink" title="3. 现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？"></a>3. 现有一个总长度为3800的IP数据报，要通过MTU为1500的链路传输，在IPv4下应如何分片？每片的DF、MF标志的值是什么？片偏移的值是什么？</h3><div class="table-container"><table><thead><tr><th>片</th><th>Length(总长度)</th><th>DF</th><th>MF</th><th>片偏移</th></tr></thead><tbody><tr><td>1</td><td>1500</td><td>0</td><td>1</td><td>0</td></tr><tr><td>2</td><td>1500</td><td>0</td><td>1</td><td>185</td></tr><tr><td>3</td><td>840</td><td>0</td><td>0</td><td>370</td></tr></tbody></table></div><p>【分析】最大传输单元（MTU）是指网络层在一次传输中能够传输的最大数据包（或帧）的大小，以字节为单位。</p><p><font color="mediumvioletred">DF：禁止分片标识，0表示允许分片，1表示禁止分片。<br>MF：更多分片标识，0表示该数据报未被分片或是最后一片，1表示该数据报一定是一个分片且不是最后一个。</font><br>IP数据报总长度：L=3800<br>最大传输单元(MTU)：M=1500<br><img src="/2025/03/17/LearnNet13017-2/IP数据报.png" width="40%"><br>最大分片可封装的数据长度 d=(1500-20)/8×8$\approx$1480（向下取整）<br>需要的IP分片数 n=(3800-20)/1500$\approx$3（向上取整）<br>每个IP的偏移字段：F1=1480/8×(1-1)=0, F2=1480/8×(2-1)=185, F3=1480/8×(3-1)=370<br>每个IP分片的总长度：L1=1480+20=1500，L2=1480+20，L3=3800-1480*(3-1)=840<br>每个IP分片的MF字段：MF1=1, MF2=1, MF3=0<br>由于题意一定分片，所以DF都为0。</p><h3 id="4-某网络拓扑图如下图所示，路由器-R1-通过接口-E1、E2-分别连接局域网1、局域网2，通过接口-L0-连接路由器-R2，并通过路由器-R2-连接域名服务器与互联网。R1-的-L0-接口的-IP-地址是-202-118-2-1-R2-的-L0-接口的-IP-地址是202-118-2-2，L1-接口的-IP-地址是-130-11-120-1，E0-接口的-地址是-202-118-3-1；-城名服务器的-IP-地址-202-118-3-2。"><a href="#4-某网络拓扑图如下图所示，路由器-R1-通过接口-E1、E2-分别连接局域网1、局域网2，通过接口-L0-连接路由器-R2，并通过路由器-R2-连接域名服务器与互联网。R1-的-L0-接口的-IP-地址是-202-118-2-1-R2-的-L0-接口的-IP-地址是202-118-2-2，L1-接口的-IP-地址是-130-11-120-1，E0-接口的-地址是-202-118-3-1；-城名服务器的-IP-地址-202-118-3-2。" class="headerlink" title="4. 某网络拓扑图如下图所示，路由器 R1 通过接口 E1、E2 分别连接局域网1、局域网2，通过接口 L0 连接路由器 R2，并通过路由器 R2 连接域名服务器与互联网。R1 的 L0 接口的 IP 地址是 202.118.2.1;  R2 的 L0 接口的 IP 地址是202.118.2.2，L1 接口的 IP 地址是 130.11.120.1，E0 接口的 地址是 202,118.3.1； 城名服务器的 IP 地址 202.118.3.2。"></a>4. 某网络拓扑图如下图所示，路由器 R1 通过接口 E1、E2 分别连接局域网1、局域网2，通过接口 L0 连接路由器 R2，并通过路由器 R2 连接域名服务器与互联网。R1 的 L0 接口的 IP 地址是 202.118.2.1;  R2 的 L0 接口的 IP 地址是202.118.2.2，L1 接口的 IP 地址是 130.11.120.1，E0 接口的 地址是 202,118.3.1； 城名服务器的 IP 地址 202.118.3.2。</h3><p><img src="/2025/03/17/LearnNet13017-2/网络拓扑.png" width="70%"><br>（1）将IP地址空间202.118.1.0/24分配给局域网1、局域网2，每个局域网需要分配的IP地址数不少于120个。请给出分配结果，并分别写出局域网1、局域网2 的子网地址、广播地址、子网掩码、IP地址总数、可分配IP地址数和可分配IP地址范围。<br>（2）请给出R1的路由表，使其明确包括到局域网1的路由、到局域网2的路由、到域名服务器的主机路由和到互联网的路由。<br>（3）请采用路由聚合技术，分别给出R2到局域网1、局域网2的路由。</p><blockquote><p>（1）</p></blockquote><div class="table-container"><table><thead><tr><th>子网地址</th><th>广播地址</th><th>子网掩码</th><th>IP地址总数</th><th>可分配IP地址数</th><th>可分配IP地址范围</th></tr></thead><tbody><tr><td>202.118.1.0/25</td><td>202.118.1.127</td><td>255.255.255.128</td><td>128</td><td>126</td><td>202.118.1.1 ~ 202.118.1.126</td></tr><tr><td>202.118.1.128/25</td><td>202.118.1.255</td><td>255.255.255.128</td><td>128</td><td>126</td><td>202.118.1.129 ~ 202.118.1.254</td></tr></tbody></table></div><p>【分析】64=$2^6$&lt;120&lt;$2^7$=128<br>每个局域网需要7位作为主机地址，1位为子网号，于是网络前缀变为（24+1）25位。<br>网络地址已用掉24位剩下（32-24）8位正好够用。<br>子网1的地址范围202.118.1.0000 0000~202.118.0111 1111<br>子网2的地址范围202.118.1.1000 0000~202.118.1111 1111<br>可以将子网1分配给局域网1，子网2分配给局域网2；或将子网1分配给局域网2，子网2分配给局域网1。<br>子网掩码：255.255.255.1000 0000，最后一个位置即$2^7$=128</p><blockquote><p>（2）R1的路由表</p></blockquote><p>若子网1分配给局域网1，子网2分配给局域网2：</p><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.0</td><td>255.255.255.128</td><td>-</td><td>E1</td></tr><tr><td>202.118.1.128</td><td>255.255.255.128</td><td>-</td><td>E2</td></tr><tr><td>202.118.3.2</td><td>255.255.255.255</td><td>202.118.2.2</td><td>L0</td></tr><tr><td>0.0.0.0</td><td>0.0.0.0</td><td>202.118.2.2</td><td>L0</td></tr></tbody></table></div><p>若子网2分配给局域网1，子网1分配给局域网2：</p><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.128</td><td>255.255.255.128</td><td>-</td><td>E1</td></tr><tr><td>202.118.1.0</td><td>255.255.255.128</td><td>-</td><td>E2</td></tr><tr><td>202.118.3.2</td><td>255.255.255.255</td><td>202.118.2.2</td><td>L0</td></tr><tr><td>0.0.0.0</td><td>0.0.0.0</td><td>202.118.2.2</td><td>L0</td></tr></tbody></table></div><blockquote><p>（3）局域网1和局域网2的地址可以聚合为202.118.1.0/24</p></blockquote><div class="table-container"><table><thead><tr><th>目的网络IP地址</th><th>子网掩码</th><th>下一条IP地址</th><th>接口</th></tr></thead><tbody><tr><td>202.118.1.0</td><td>255.255.255.0</td><td>202.118.2.1</td><td>L0</td></tr></tbody></table></div><h3 id="5-设子网中某主机的IP地址为220-112-10-134，子网掩码为255-255-255-224，则该子网的直接广播地址是220-112-10-159。"><a href="#5-设子网中某主机的IP地址为220-112-10-134，子网掩码为255-255-255-224，则该子网的直接广播地址是220-112-10-159。" class="headerlink" title="5. 设子网中某主机的IP地址为220.112.10.134，子网掩码为255.255.255.224，则该子网的直接广播地址是220.112.10.159。"></a>5. 设子网中某主机的IP地址为220.112.10.134，子网掩码为255.255.255.224，则该子网的直接广播地址是<i id="answer4_5" class="answer" onclick="showOrHide('4_5')">220.112.10.159</i>。</h3><p>【分析】子网掩码255.255.255.224对应的二进制是11111111.11111111.11111111.11100000，这意味着每个子网有32个地址（$2^5$），其中第一个是网络地址，最后一个是广播地址；<br>IP地址220.112.10.134的二进制形式是：11011100.01110000.00001010.10000110；<br>将IP地址和子网掩码进行<font color="mediumvioletred">按位与运算</font>：11011100.01110000.00001010.10000000；<br>然后，找到广播地址，它是网络地址的主机部分全部置为1：11011100.01110000.00001010.10011111，即220.112.10.159。</p><h2 id="五、数据链路层"><a href="#五、数据链路层" class="headerlink" title="五、数据链路层"></a>五、数据链路层</h2><h3 id="1-对于10-Mbps的基带CSMA-CD网的MAC帧的最小和最大总长度分别为64和1518字节。"><a href="#1-对于10-Mbps的基带CSMA-CD网的MAC帧的最小和最大总长度分别为64和1518字节。" class="headerlink" title="1. 对于10 Mbps的基带CSMA/CD网的MAC帧的最小和最大总长度分别为64和1518字节。"></a>1. 对于10 Mbps的基带CSMA/CD网的MAC帧的最小和最大总长度分别为<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">64</i>和<i id="answer5_2" class="answer" onclick="showOrHide('5_2')">1518</i>字节。</h3><p>【分析】R=10Mbit/s，以太网的CSMA/CD协议中的帧长范围也是固定的。<br>CSMA/CD协议的公式：<script type="math/tex">\frac{L_{min}}{R}\ge\frac{D_{max}}{v}</script></p><p><pre class="mermaid">graph LR    A[数据链路层使用的信道] --> B1[点对点信道]    A --> B2[广播信道]    B2 --> C[多路访问控制协议MAC]    C --> D1[信道划分MAC协议]    C --> D2[随机访问MAC协议]    C --> D3[受控接入MAC协议]    D1 --> E1[频分多路复用FDM]    D1 --> E2[时分多路复用TDM]    D1 --> E3[波分多路复用WDM]    D1 --> E4[码分多路复用CDM]    D2 --> E5[ALOHA协议]    D2 --> E6[载波监听多路访问协议CSMA]    D2 --> E7[带冲突检测的载波监听多路访问协议CSMA/CD]    style E7 stroke:#f9f,stroke-width:2px    D3 --> E8[集中式控制]    D3 --> E9[分散式控制]    E6 --> F1[非坚持CSMA]    E6 --> F2[1-坚持CSMA]    E6 --> F3[P-坚持CSMA]    E5 --> F4[纯ALOHA]    E5 --> F5[时隙ALOHA]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><p>非坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则立即发送数据；若发现信道忙，则等待一个随机时间，然后重新开始侦听信道。<br>1-坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则立即发送数据；若发现信道忙，则继续侦听信道，直至发现信道空闲，然后立即发送数据。<br>P-坚持CSMA：若通信站有数据发送，则先侦听信道；若发现信道空闲，则以概率P在最近时隙开始时刻发送数据，以概率1-P延迟至下一个时隙发送；若发现信道忙，则等待一个随机时间，然后重新开始侦听信道。</p><p>多路复用技术：当传输介质的带宽或容量超过传输单一信号的需求时，可用一个信道同时传输多路信号，从而有效地利用通信线路，节省电缆安装和维护费用。<br>CSMA/CD协议：通信站使用CSMA协议进行数据发送；在发送期间，如果检测到碰撞，立即终止发送，并发出一个冲突强化信号，使所有通信站都知道冲突的发生；在发出冲突强化信号后，等待一个随机时间，再重复上述过程。</p><h3 id="2-有一个电缆长度为2km的CSMA-CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2-3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）-光速值为3×-10-5-km-s-。"><a href="#2-有一个电缆长度为2km的CSMA-CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2-3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）-光速值为3×-10-5-km-s-。" class="headerlink" title="2. 有一个电缆长度为2km的CSMA/CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2/3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）(光速值为3×$10^5$km/s)。"></a>2. 有一个电缆长度为2km的CSMA/CD局域网，数据传输速率为10Mbps，信号传播速度为光速的2/3，数据帧长度是512bit（包括32bit开销），传输成功后的第一个时隙留给接收方，用于捕获信道并发送一个32bit的确认帧。假设没有冲突发生，试求出有效的数据传输速率（不包括开销）(光速值为3×$10^5$km/s)。</h3><blockquote><script type="math/tex; mode=display">D=2km=2*10^3m</script><script type="math/tex; mode=display">v=3*10^5km/s*\frac{2}{3}=2*10^8m/s</script><script type="math/tex; mode=display">L=512bit</script><script type="math/tex; mode=display">R=10Mbps=10*10^6bit/s=10^7bit/s</script><script type="math/tex; mode=display">d_t=\frac{L}{R}=\frac{512bit}{10^7bit/s}=5.12*10^{-5}s  \mathrm{传输时延}</script><script type="math/tex; mode=display">d_p=\frac{D}{v}=\frac{2*10^3m}{2*10^8m/s}=10^{-5}s  \mathrm{传播时延}</script><script type="math/tex; mode=display">d_{确认帧}=\frac{32bit}{10^7bit/s}=3.2*10^{-6}s</script><script type="math/tex; mode=display">T=d_t+2d_p+d_{确认帧}=5.12*10^{-5}s+2*10^{-5}s+3.2*10^{-6}s=7.44*10^{-5}s</script><script type="math/tex; mode=display">数据帧的净荷长度=512 bit - 32 bit = 480 bit</script><script type="math/tex; mode=display">有效数据传输速率=\frac{480bit}{7.44*10^{-5}s}\approx6.45*10^6m/s=6.45Mbps</script></blockquote><p>【分析】512bit中包含的32bit开销可能是头部信息，不算有效数据，和确认帧不是一回事。确认帧是从接收方发送回来的，所以总时间加上$d_{确认帧}$。<br>传播时间乘以2是因为信号需要从发送方传播到接收方，然后再从接收方传播回发送方。这个往返过程确保了在发送方和接收方之间有足够的时间来检测和处理可能发生的冲突。</p><h3 id="3-设码元速率为3600Baud-若采用双相码、无校验位、1位停止位的异步传输，1分钟可传输的汉字个数为5400。"><a href="#3-设码元速率为3600Baud-若采用双相码、无校验位、1位停止位的异步传输，1分钟可传输的汉字个数为5400。" class="headerlink" title="3. 设码元速率为3600Baud,若采用双相码、无校验位、1位停止位的异步传输，1分钟可传输的汉字个数为5400。"></a>3. 设码元速率为3600Baud,若采用双相码、无校验位、1位停止位的异步传输，1分钟可传输的汉字个数为<i id="answer5_3" class="answer" onclick="showOrHide('5_3')">5400</i>。</h3><p>【分析】码元速率$R_B$，也称波特率，单位波特Baud。<br>它与比特率$R_b$、信号进制M之间的公式：<font color="mediumvioletred">$R_b=R_Blog_2M$</font><br>双相码采用二进制，所以M=2<br>$R_b=3600<em>1=3600bps$<br>1分钟能传的数据位=3600</em>60=216000bit<br>每个汉字使用双字节表示，双相码利用两位编码信息码中的一位，无校验位，1位停止位：一个汉字需传输的位数=(8+1+1)<em>2</em>2=40bit<br>第一个乘2表示汉字用双字节，第二个乘2表示双相码。<br>1分钟传输的汉字个数=216000/40=5400</p><h3 id="4-若在传输速率为100Mbit-s的以太网中，A、B主机通过1000m长的链路直接相连，信号传播速度为2×-10-8-m-s-则A、B之间传输的数据帧最小长度为125B。"><a href="#4-若在传输速率为100Mbit-s的以太网中，A、B主机通过1000m长的链路直接相连，信号传播速度为2×-10-8-m-s-则A、B之间传输的数据帧最小长度为125B。" class="headerlink" title="4. 若在传输速率为100Mbit/s的以太网中，A、B主机通过1000m长的链路直接相连，信号传播速度为2×$10^8$m/s,则A、B之间传输的数据帧最小长度为125B。"></a>4. 若在传输速率为100Mbit/s的以太网中，A、B主机通过1000m长的链路直接相连，信号传播速度为2×$10^8$m/s,则A、B之间传输的数据帧最小长度为<i id="answer5_4" class="answer" onclick="showOrHide('5_4')">125B</i>。</h3><p>【分析】A、B间通讯一次的时间=$\frac{2L}{R}=\frac{2×1000}{2×10^8}=10^{-5}s$<br>最小帧长度=100Mbps×$10^{-5}$s=1000bit=125B</p><h3 id="5-设10Mbit-s以太网中的信号传播速度为2×-10-8-m-s，若数据帧最小长度为250bit，则网中站点间的最远距离为2-5km。"><a href="#5-设10Mbit-s以太网中的信号传播速度为2×-10-8-m-s，若数据帧最小长度为250bit，则网中站点间的最远距离为2-5km。" class="headerlink" title="5. 设10Mbit/s以太网中的信号传播速度为2×$10^8$m/s，若数据帧最小长度为250bit，则网中站点间的最远距离为2.5km。"></a>5. 设10Mbit/s以太网中的信号传播速度为2×$10^8$m/s，若数据帧最小长度为250bit，则网中站点间的最远距离为<i id="answer5_5" class="answer" onclick="showOrHide('5_5')">2.5km</i>。</h3><blockquote><p>物理:D,V,$d_p$  数据:L,R,$d_t$<br>$D_{max}=\frac{d_t×V}{2}=\frac{\frac{250bit}{10Mbps}×2×10^8m/s}{2}=2500m$</p></blockquote><h3 id="6-设信号传播速度V-250000km-s，分组长度L-512bit，数据速率R-1000Mbit-s，则使时延带宽积刚好为分组长度L的链路长度为128m。"><a href="#6-设信号传播速度V-250000km-s，分组长度L-512bit，数据速率R-1000Mbit-s，则使时延带宽积刚好为分组长度L的链路长度为128m。" class="headerlink" title="6. 设信号传播速度V=250000km/s，分组长度L=512bit，数据速率R=1000Mbit/s，则使时延带宽积刚好为分组长度L的链路长度为128m。"></a>6. 设信号传播速度V=250000km/s，分组长度L=512bit，数据速率R=1000Mbit/s，则使时延带宽积刚好为分组长度L的链路长度为<i id="answer5_6" class="answer" onclick="showOrHide('5_6')">128m</i>。</h3><blockquote><p>$G=d_p*R=\frac{D}{V}*R=\frac{D}{2.5*10^8}*10^9=512$<br>∴ 4D=512<br>D=128m</p></blockquote><h3 id="7-设生成多项式G-X-X-4-X-1，则对位串100111011101进行CRC编码后的结果为1001110111010110。"><a href="#7-设生成多项式G-X-X-4-X-1，则对位串100111011101进行CRC编码后的结果为1001110111010110。" class="headerlink" title="7. 设生成多项式G(X)=$X^4$+X+1，则对位串100111011101进行CRC编码后的结果为1001110111010110。"></a>7. 设生成多项式G(X)=$X^4$+X+1，则对位串100111011101进行CRC编码后的结果为<i id="answer5_7" class="answer" onclick="showOrHide('5_7')">1001110111010110</i>。</h3><blockquote><p>（待补充）</p></blockquote><h2 id="六、物理层"><a href="#六、物理层" class="headerlink" title="六、物理层"></a>六、物理层</h2><h3 id="1-已知信息码为101001100010000011，则对应的AMI码为-10-100-1-1000-100000-1-1。"><a href="#1-已知信息码为101001100010000011，则对应的AMI码为-10-100-1-1000-100000-1-1。" class="headerlink" title="1. 已知信息码为101001100010000011，则对应的AMI码为+10-100+1-1000+100000-1+1。"></a>1. 已知信息码为101001100010000011，则对应的AMI码为<i id="answer6_1" class="answer" onclick="showOrHide('6_1')">+10-100+1-1000+100000-1+1</i>。</h3><p>【分析】AMI信号交替反转码：用三种电平进行编码。若第一位为0，则从-1开始；若第一位为1，则从+1开始。对每一位“1”交替正负编码。</p><h3 id="2-对于带宽为4kHz的无噪声信道，若采用八进制数字调制，则该信道码元的最大速率和最大数据传输速率分别为8kBaud和24kbps。"><a href="#2-对于带宽为4kHz的无噪声信道，若采用八进制数字调制，则该信道码元的最大速率和最大数据传输速率分别为8kBaud和24kbps。" class="headerlink" title="2. 对于带宽为4kHz的无噪声信道，若采用八进制数字调制，则该信道码元的最大速率和最大数据传输速率分别为8kBaud和24kbps。"></a>2. 对于带宽为4kHz的无噪声信道，若采用八进制数字调制，则该信道码元的最大速率和最大数据传输速率分别为<i id="answer6_2" class="answer" onclick="showOrHide('6_2')">8kBaud和24kbps</i>。</h3><p>【分析】码元速率B与信道带宽公式：<font color="mediumvioletred">B=2W</font>（即Hz与Baud的关系）<br>W=4kHz，最大的B=2×4kHz=8kBaud<br>传输速率$R_b$与码元速率B（$R_B$）的公式（奈奎斯特公式）：$R_b=R_Blog_2M$<br>信号进制M=8，最大的$R_b$=8kHz×3=24kbps</p><h3 id="3-设信噪比为30dB，采用八进制数字调制方式，带宽为8KHz的信道可达到的最大数据传输速率约为240kbps。"><a href="#3-设信噪比为30dB，采用八进制数字调制方式，带宽为8KHz的信道可达到的最大数据传输速率约为240kbps。" class="headerlink" title="3. 设信噪比为30dB，采用八进制数字调制方式，带宽为8KHz的信道可达到的最大数据传输速率约为240kbps。"></a>3. 设信噪比为30dB，采用八进制数字调制方式，带宽为8KHz的信道可达到的最大数据传输速率约为<i id="answer6_3" class="answer" onclick="showOrHide('6_3')">240kbps</i>。</h3><blockquote><p>信噪比分贝与功率换算公式：$SNR_{(dB)} = 10lg(1+SNR_{(功率)})$<br>香农公式： $C = Blog_2(1+SNR_{(功率)})$ ，C为信道容量（bps），B为信道带宽（Hz）<br>$SNR_{(功率)}={10}^{(\frac{SNR_{(dB)}}{10})}={10}^{(\frac{30}{10})}=10^3=1000$<br>$C=8kHz×log_2(1+1000)\approx8k×31\approx240kbps$</p></blockquote><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/17/LearnNet13017-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2024年终总结</title>
      <link>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/</link>
      <guid>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/</guid>
      <pubDate>Sun, 16 Mar 2025 05:57:54 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;已经是2025年的3月了，生活没那么容易，但也没那么难，有很多要做也正在做的事，过去的一年做了很多的探索。生活的表象都仿佛是对内心世界的度量，苦苦渴求却还没得到的，真的不如现在带有偏见却已经拥有的吗？还是说，这苦苦追逐的感觉根本不是我想要的，根本就不存在需要去追逐的外物，我</description>
        
      
      
      
      <content:encoded><![CDATA[<p>已经是2025年的3月了，生活没那么容易，但也没那么难，有很多要做也正在做的事，过去的一年做了很多的探索。生活的表象都仿佛是对内心世界的度量，苦苦渴求却还没得到的，真的不如现在带有偏见却已经拥有的吗？还是说，这苦苦追逐的感觉根本不是我想要的，根本就不存在需要去追逐的外物，我能拥有的，只有当下，那些求不得是否都不如求自己来得痛快……<br>不一样的感觉是从何而来的？是因为我看着事物的区别，我评价，我归类，我选择了其中之一，否定了另一个选择，循环往复……即便我选择了其一，另一种存在也无法凭空消失，我看不惯，我感到不适，我觉得不想要的在干扰我获得想要的……人生就是这样子的吗？不对的。</p><p><strong>我只能创造我想要的生活。</strong></p><p>得不到的，只能祛魅，必须祛魅。已经得到的，学会珍惜，学会发现它们对我的意义。在已有的基础之上，将梦想变为现实。</p><p>前段时间看到的一段话给了我很大的触动，大致是说，“人的欲望分为三种：努力追求而求不得的，努力追求而得到的，没有追求就得到的。”这三种情形的感受是大不相同的，而只有最后一种才是理想的状态。<br>我在2023年终总结中所写的“向内求”，似乎在过去的一年里一定程度的落实了，但还不够，因为我很多时候还会因为求不得而痛苦，不够强大的内心还需要修炼。<br>但是无论如何，相对而言是对自己满意的。过去一年的思考与积累，承受过的情绪波澜，让我在新的一年里，自我攻击越来越少了，面对困难寻求解决方案的执行力更强了，即便还没有做成什么事，我也珍惜此刻充实的生活。</p><p>几年间一直在心头回响的“我不想得到答案”，在潜意识里的愿望就是“我要自己找到答案”。<br>只有创造的过程是幸福的。去创造，无论是否够到达彼岸。<br>这是我对2025年的祈愿。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      
      <comments>https://pearlchocolatezy.com/2025/03/16/YearEndReview2024/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何在hexo-butterfly中画思维导图：Mermaid插件</title>
      <link>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/</link>
      <guid>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/</guid>
      <pubDate>Sat, 15 Mar 2025 13:06:55 GMT</pubDate>
      
      <description>mermaid在butterfly中的配置过程。</description>
      
      
      
      <content:encoded><![CDATA[<p>想要在hexo博客的markdown文档中添加思维导图（树状图/流程图）插件，问了下百度说有mermaid这个工具，发现butterfly的配置选项中自带mermaid。<br><a href="https://butterfly.js.org/posts/4aa8abbe">Butterfly 文檔(三) 主題配置</a>这篇教程说最好hexo要更新至7.0或以上版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --version</span><br></pre></td></tr></table></figure><br>使用这个语句查了一下发现我的hexo版本是6.3.0，时间有限想先试试不更新的办法。</p><ol><li>先在_config.butterfly.yml文件配置mermaid：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">code_write:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure></li><li>在hexo的文件中配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">exclude_languages:</span> [<span class="string">&#x27;mermaid&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>在markdown文章中添加code：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```&quot;mermaid&quot;  (实际没有引号)</span></span><br><span class="line"><span class="code">graph LR</span></span><br><span class="line"><span class="code">A[根节点] --&gt; B[子节点1]</span></span><br><span class="line"><span class="code">A --&gt; C[子节点2]</span></span><br><span class="line"><span class="code">B --&gt; D[子节点1.1]</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">&#123;% endmermaid %&#125; </span><br></pre></td></tr></table></figure>写法很怪，但在hexo没升级的情况下能生效。<br>效果如下：<br><pre class="mermaid">graph LR A[根节点] --> B[子节点1] A --> C[子节点2] B --> D[子节点1.1]</pre><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div> <img class="zy_img_shadow" src="/2025/03/15/LearnMermaid/../../../../album-doge/index/001-code.jpg" width="30%"><!--往上翻这么多层是因为编译后是按年月日分文件夹的--></li></ol><p>mermaid除了可以画思维导图、流程图以外，还可以画饼图等。<br>mermaid<a href="https://zhuanlan.zhihu.com/p/627356428">中文教程</a><br>mermaid<a href="https://mermaid.js.org/">官方文档</a></p><p>End.🐧</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Markdown/">Markdown</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/03/15/LearnMermaid/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
