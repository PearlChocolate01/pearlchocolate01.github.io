<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Wed, 05 Feb 2025 02:21:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ssh: connect to host github.com port 22: Connection timed out</title>
      <link>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</guid>
      <pubDate>Wed, 05 Feb 2025 01:57:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;部署在github上的hexo博客，用了很久的默认22端口突然连不上了&lt;br&gt;&lt;img class=&quot;zy_img_shadow&quot; src=&quot;/2025/02/05/SolveSshError/1.png&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能原因是：&lt;/p&gt;
&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<p>部署在github上的hexo博客，用了很久的默认22端口突然连不上了<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/1.png" width="60%"></p><p>可能原因是：</p><blockquote><p>网络连接问题<br>SSH秘钥配置错误<br>22端口已占用<br>……</p></blockquote><p>排除下来22端口被占用或其他环境因素禁用的可能性比较大，可以改为443端口（HTTPS端口，通常开放）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/2.png" width="60%"><br>跟<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub官网</a>的主机密钥指纹对比确认正确后输入yes<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/3.png" width="60%"><br>尝试重新推送即可。</p><p><strong>可以在.ssh文件夹中配置新的端口号：</strong><br>找到目录：C:\Users\&lt;你的用户名&gt;.ssh\config（Windows）<br>如果没有config文件可以在.ssh文件夹下新建一个config空文件<br>文件内容为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">  <span class="string">HostName</span> <span class="string">ssh.github.com</span></span><br><span class="line">  <span class="string">Port</span> <span class="number">443</span></span><br><span class="line">  <span class="string">User</span> <span class="string">git</span></span><br><span class="line">  <span class="string">PreferredAuthentications</span> <span class="string">publickey</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">C:\Users\&lt;你的用户名&gt;\.ssh\id_rsa</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Git/">Git</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/SolveSshError/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（五）——链路层和局域网</title>
      <link>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</link>
      <guid>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</guid>
      <pubDate>Tue, 04 Feb 2025 08:35:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;链路层&quot;&gt;&lt;a href=&quot;#链路层&quot; class=&quot;headerlink&quot; title=&quot;链路层&quot;&gt;&lt;/a&gt;链路层&lt;/h2&gt;&lt;h3 id=&quot;目标：原理和实现&quot;&gt;&lt;a href=&quot;#目标：原理和实现&quot; class=&quot;headerlink&quot; title=&quot;目标：原理</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="目标：原理和实现"><a href="#目标：原理和实现" class="headerlink" title="目标：原理和实现"></a>目标：原理和实现</h3><p>原理：<br>检错和纠错<br>共享广播信道：多点接入<br>链路层寻址<br>LAN：以太网，VLANs<br>可靠数据传输</p><p>链路层技术的实现</p><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>广域网WAN：网络形式采用点到点链路，实现容易<br>局域网LAN：一般采用多点连接方式，实现复杂<br>链路层的主要功能：一个节点把帧通过链路传到相邻的另一个节点（点到点）。<br>链路层服务：成帧，链路介入；在相邻两个节点完成可靠数据传递；在相邻节点间进行可靠转发；流量控制；错误检测；差错纠正；半双工和全双工（可收可发）。（一个特定的链路层只提供其中一种服务）<br>链路层功能在哪里实现：每个主机上，装了网卡，网卡实现网络层和链路层的功能；路由器上有多个网卡，每个网卡实现了物理层和相应链路层的功能。即，链路层功能在网卡上实现，网卡又称网络适配器（NIC），开机自动运行，按照协议工作。</p><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p>残存错误<br>奇偶校验<br>CRC循环冗余校验码：<br>1）模2运算（按位异或，加法不进位）；<br>2）位串的两种表示（0和1；多项式表示）；<br>3）生成多项式（r次方的比特序列）；<br>4）约定：sender多项式<code>[D][EDC]</code> 使得 receiver多项式<code>[D][EDC]</code>满足 接收方r位多项式/生成多项式=整数，则数据在传输过程中没有出错<br>CRC性能分析：能够查出所有1bit的错误、双bit的错误……</p><h3 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h3><p>多路访问链路和协议：<br>两种类型的链路：点对点，广播（共享线路和媒体）</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/04/LearnNet5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（四）——网络层</title>
      <link>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</link>
      <guid>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</guid>
      <pubDate>Thu, 30 Jan 2025 02:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;网络层：数据平面&quot;&gt;&lt;a href=&quot;#网络层：数据平面&quot; class=&quot;headerlink&quot; title=&quot;网络层：数据平面&quot;&gt;&lt;/a&gt;网络层：数据平面&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解网络服务的基本原理<br>网络服务模型<br>转发和路由<br>路由器工作原理<br>通用转发<br>网络层协议的实例</p><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ol><li>在发送主机和接收主机对之间传送段</li><li>在发送端，将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ol><h3 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h3><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP分片和重组<br>IP编址<br>子网：IP地址高位部分相同，无需路由器介入。<br>IP地址分类：A类（126 networks, 16million hosts），B类，C类（大部分）<br>127.x.x.x 表示回路地址：自上而下到达IP层再反转回去<br>DHCP协议：动态从服务器获取IP地址</p><h3 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h3><p>每个路由器都有控制平面和数据平面，分布化实现，用路由表粘连控制平面和数据平面（控制平面控制路由表，数据平面利用路由表信息进行转发）<br>SDN特点：1）基于流的匹配+行动；2）控制平面和数据平面分离；3）控制平面功能在数据交换设备之外实现；4）可编程控制应用。<br>SDN架构：（自下而上） 数据平面交换机（基于南向API，SDN控制器访问基于流的交换机)，SDN控制器（通过北向API和控制应用交互，通过南向API和网络交换机交互；逻辑上集中，实现上分布），控制应用（采用下层SDN控制器提供的API，实现网络功能，e.g.防火墙、接入控制、负载均衡）。<br>南向接口：SDN控制器（软件层面）与网络设备（硬件层面）之间的通信接口。e.g.OpenFlow<br>北向接口：提供给其他厂家或运营商进行接入和管理的接口，即向上提供的接口。<br>通用流表的组成：模式，行动，优先权，计数器<br>转发表和流表是怎样计算出来的：通过控制平面</p><h2 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>传统路由选择算法<br>SDN控制器<br>ICMP<br>网络管理</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>路由：按照某种指标（站数、延迟、费用、队列长度）找到一条从源节点到目标节点的较好路径<br>路由器之间的最优路径=主机对之间的最优路径<br>路由选择算法就是为所有路由路由器找到并使用汇集树。<br>路由选择算法的原则：正确性，简单性（不应为获取路由信息而增加通信量），健壮性（能适应通信量和网络拓扑变化），稳定性，公平性，最优性。<br><strong>链路状态算法 link state</strong><br>步骤：1）获得整个网络拓扑和边的代价信息（我的链路状态分组在全网泛洪）；2）计算本站点到其它站点的最优路径（Dijkstra算法，可以找例题！复杂度O(n^2)，堆优化后是O(nlogn)），得到路由表；3）按此路由表转发分组。<br>e.g.OSPF，IS-IS<br><strong>距离矢量算法 distance vector</strong><br>思想：各路由器维护一张到目标的路由表；各路由器与相邻路由器交换路由表；根据获得的路由信息更新路由表。（最后让各个节点收敛到一个真实状态）<br>特点：好消息传得快，坏消息传的慢（无穷计算-&gt;水平分裂算法：减少影响，不能杜绝发生）。</p><p>比较：<br>（1）消息复杂度：DV胜出<br>（2）收敛时间：LS胜出<br>（3）健壮性：LS胜出</p><h3 id="因特网中自治系统内部的路由器选择"><a href="#因特网中自治系统内部的路由器选择" class="headerlink" title="因特网中自治系统内部的路由器选择"></a>因特网中自治系统内部的路由器选择</h3><p>路由分为内部网关协议和外部网关协议。<br>内部网关协议有RIP协议和OSPF协议。<br>RIP(routing information protocal)协议基于DV算法。<br>OSPF(open shortest path first)协议基于LS算法。特性：安全，允许多个代价相同的路径存在，有多重代价矩阵。</p><h3 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h3><p>（自治区之间的路由选择协议，外部网关协议）<br>BGP协议：边界网关协议。将互联网各个自治系统(AS)粘在一起的胶水。<br>使用TCP协议交换BGP报文。（只要了解什么是层次性路由，为什么要用层次性路由）<br>层次路由的优点：解决了规模问题，解决了管理问题。<br>热土豆策略：选择具备最小内部区域代价的网关作为出口，不考虑代价。</p><h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><p>传统方式：per-router控制平面<br>SDN方式：逻辑上的集中控制平面（2005年后，详见上）<br>为什么需要逻辑上的集中控制平面：管理更容易，允许可编程的路由器，控制平面的开放实现<br>传统方式实现流量工程困难，用SDN方式容易。<br>SDN控制器的实现：ODL,ONOS</p><h3 id="ICMP-因特网控制报文协议"><a href="#ICMP-因特网控制报文协议" class="headerlink" title="ICMP 因特网控制报文协议"></a>ICMP 因特网控制报文协议</h3><h3 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h3>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/30/LearnNet4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（三）——传输层</title>
      <link>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</link>
      <guid>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</guid>
      <pubDate>Mon, 27 Jan 2025 12:50:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解传输层的工作原理<br>（1）多路复用，解复用<br>（2）可靠数据传输<br>（3）流量控制<br>（4）拥塞控制<br>学习Internet的传输层协议：<br>（1）UDP无连接传输<br>（2）TCP面向连接的可靠传输<br>（3）TCP的可靠控制</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RDT，即reliable data transfer</p><p>物理层：传输实体，链路层：点到点，网络层：端到端，传输层：进程到进程，应用层：客户-服务</p><p>传输层提供进程与进程之间的，以message为单位的通信服务</p><p>传输协议运行在端系统。<br>发送方：讲应用层的报文分成报文段，然后传递给网络层。<br>接收方：将报文段重组成报文，然后传递给应用层。</p><p>有多个传输层协议可供应用选择</p><p>IP向上层提供的服务是不可靠的，TCP加强了可靠性；TCP向上层提供的服务是不安全的，SSL可以加强安全性。TCP无法降低延迟，无法增加带宽。TCP可以加强服务品质，但无法优化性能。</p><p>有连接的单位是分组，无连接的单位是数据报</p><p>字节流：Byte stream；数据报：Datagram；边界信息：Boundary information</p><p>best effort</p><h3 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h3><p>上一层实现IP的区分，到传输层引入端口，区分进程，完成源端的复用，到目标端的解复用。<br>复用是指多个tcp socket的信息都往下交,对方收到再分给不同的socket</p><p>共有65535个端口号</p><p>TCP和UDP使用端口的方式不一样</p><p>为了使穿过层间的信息最少，TCP和四元组相捆绑，即socket，socket包含四个信息：本地IP，本地port，对方IP，对方port。</p><p>socket是网络服务接口，对应进程</p><p>UDP的socket和本地IP，本地port相捆绑（二元组）。</p><p>应用往下传的是：（1）数据（2）socket（3）对方IP和对方port的地址（cad，指针）</p><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><p>应用：实时流媒体；事务性应用（一次往返）<br>UDP：用户数据报协议<br>UDP校验和：检测在被传输报文段中的差错。<br>残存错误：数据部分和EDC部分出错后依然符合校验规则。（概率小，但不可忽略）<br>发送方编码，接收方解码<br>进位回滚</p><h3 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt（可靠数据传输）在应用层、传输层和数据链路层都很重要。是网络Top10问题之一。<br>信道的不可靠特点决定了可靠数据传输协议的复杂性。</p><p>在可靠信道上传输：不出错，不丢失</p><p>超时重传机制（解决传错/丢失问题）</p><p>滑动窗口协议（slide window）：发送缓冲区。<br>发送窗口的最大值&lt;=发送缓冲区的值<br>发送窗口前沿移动的极限：不能超过发送缓冲区<br>接收窗口=接收缓冲区<br>GBN（Go-back-N）协议和SR(Selective Repeat)协议的异同：相同：发送窗口&gt;1，一次可发多个未经确认分组。区别：GBN接收窗口尺寸=1，只能顺序接收，一旦一个分组没有发成功，要返回错误的地方重发；SR接收窗口尺寸&gt;1，可乱序接收，发送未成可以选择性重发错的中间某一项。</p><p>GBN适用范围：出错率低（SR复杂易出错）<br>SR适用范围：链路容量大（延迟大，带宽大）<br>GBN:以时间换空间  SR: 以空间换时间</p><h3 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h3><p>（段结构；可靠数据传输；流量控制；连接管理）<br>TCP概述：点对点，可靠的、按顺序的字节流，管道化（流水线），发送和接收缓存，全双工数据，面向连接，有流量控制</p><p>MSS:Maximum Segment Size, 最大报文段大小，≤当然可以</p><p><strong>TCP往返延时（RTT）和超时</strong><br>在局域网中，两台计算机之间的往返延迟可以设置为固定的值；通过TCP处理进程通信的情况，超时时间是动态的、自适应的。<br>sampleRTT 当前采样RTT<br>estimatedRTT 移动平均RTT</p><p>TCP在IP不可靠服务的基础上建立了RTT</p><p>快速重传算法</p><p><strong>流量控制</strong><br>目的：防止发送方发的太快，超出了接收方的处理能力（防止接收方缓冲区溢出）。</p><p><strong>连接管理</strong><br>连接建立 和 连接拆除</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络拥塞的表现：分组丢失率变高，延迟更多<br>两种拥塞控制方法：端到端拥塞控制，网络辅助的拥塞控制<br>ATM网络：异步传输网络，它的数据单位是RM（信元）<br>ABR模式：弹性服务</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>如何检测拥塞：超时（拥塞）；收到某个段三个重复的ACK（轻微拥塞，没有发生拥塞，但是由于未通过差错检验，给源端一种发生拥塞的错觉）</p><p>rate=CongWin/RTT<br>两种控制同时考虑：接受窗口反映流量控制，拥塞窗口反映拥塞控制<br>拥塞控制的策略：慢启动（每个RTT，CongWin加倍；一开始慢速，但加速是指数性的）</p><p>拥塞控制的机制：线性增加-层性减-线性增加-层性减…<br>（改进）指数增加-线性增加-线性减-指数增加-线性增加-线性减…</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>传输层提供的服务：为应用进程间的逻辑通信服务（相对的，网络层提供的是主机和主机之间的通信服务），传输层协议包括TCP和UDP</li><li>原理：多路复用和解复用<br>区分进程使用的是：端口</li><li>无连接传输层协议UDP</li><li>可靠数据传输原理：停止等待协议（RDT），流水线协议（GBN：接收窗口=1，SR：接收窗口&gt;1）</li><li>TCP协议：TCP特性，面向连接的，进程到进程的；TCP报文段格式；TCO可靠传输机制；超时重传，快速重传；流量控制；连接管理</li><li>拥塞控制原理：拥塞原因，拥塞代价（方式：网络辅助e.g.ATM - 根据网络提供的反馈信息；端到端e.g.TCP - 超时和三个冗余ACK来判断拥塞）</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/27/LearnNet3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（二）——应用层</title>
      <link>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</link>
      <guid>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</guid>
      <pubDate>Mon, 06 Jan 2025 13:19:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;h3 id=&quot;提纲&quot;&gt;&lt;a href=&quot;#提纲&quot; class=&quot;headerlink&quot; title=&quot;提纲&quot;&gt;&lt;/a&gt;提纲&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>目标：原理&amp;实例&amp;编程</p><ol><li>应用层协议原理</li><li>Web and HTTP</li><li>FTP*</li><li>Email<br>（1）SMTP（2）POP3（3）IMAP</li><li>DNS</li><li>P2P应用</li><li>CDN</li><li>TCP套接字（Soclet）编程</li><li>UDP套接字编程</li></ol><h3 id="应用层原理"><a href="#应用层原理" class="headerlink" title="应用层原理"></a>应用层原理</h3><p>网络应用的例子：E-mail，Web，文本消息，远程登录，P2P文件共享，即时通信，多用户网络游戏，流媒体（YouTube,Netflix），Internet电话，实时电视会议，社交网络，搜索……<br>网络应用得到体系结构：客户-服务器模式（C/S），对等模式（P2P），混合体</p><ol><li>客户-服务器（C/S）体系结构<br>服务器：一直运行；固定的IP地址和周知的端口号（约定）；扩展性差；可靠性差（服务器会宕机）。<br>客户端：主动与服务器通信；与互联网有间歇性的连接；可能是动态IP地址；不直接与其它客户端通信。</li><li>对等体（P2P）体系结构<br>（几乎）没有一直运行的服务器；<br>任意端系统之间可以进行通信；<br><font color="purple">每一个节点即是客户端又是服务器</font>，自扩展性；<br>参与的主机间歇性连接且可以改变IP地址（难以管理）。<br>e.g.迅雷</li><li><p>C/S和P2P混合体<br>（1）e.g.Napster</p><blockquote><p>《Napster》是一个真实的案例，是一家音乐分享平台的。它以其革命性的P2P（点对点）文件共享技术引发了音乐行业的巨大变革，但最终因未能应对法律和商业压力而走向失败。如今Napster以经营付费服务为主，而免费的Napster的流行和回响使其在电脑界和娱乐业里成为一个传奇的象征。</p></blockquote><p> 文件搜索：集中<br> 文件传输：P2P<br> （2）即时通信</p></li><li>进程通信<br>进程：在主机上运行的应用程序<br>客户端进程：发起通信的进程<br>服务器进程：等待连接的进程<br>在同一个主机内，使用进程间通信机制通信（由操作系统定义）。<br>不同主机，通过交换报文（message）来通信（使用OS提供的通信服务；借助传输层的服务，按照应用协议交换报文）。<br>P2P架构也有客户端进程和服务器进程之分。</li><li>分布式应用进程需要解决的问题<br>（1）进程标识和寻址问题（服务用户）<br>（2）传输层-应用层怎样提供服务（位置：层间界面的SAP；形式：应用程序接口API）<br>（3）如何使用传输层提供的服务，实现应用进程间的报文交换，实现应用（用户使用服务）（定义应用层协议，编制程序）<br><br><strong>（1）-&gt; 对进程进行编址（addressing）</strong><br>进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）：<br>①每台主机有唯一的32位IP地址，但IP地址无法唯一标识一个进程。<br>②采用的传输层协议：TCP or UDP<br>③端口号（Port Numbers）<br>约定默认端口号：<br>FTP：21<br>Telnet：23<br>HTTP:TCP：80<br>MAIL:TCP：25<br>ftp:TCP：2<br>一个进程：IP+port标示端节点<br>本质上，一对主机进程之间的通信由2个端节点构成。<br>TCP和UDP使用端口的方式不同。<br><strong>（2）-&gt; 传输层提供的服务-需要穿过层间的信息</strong><br>层间接口必须要携带的信息：<br>①要传输的报文（本层SDU）<br>②谁传的：对方的应用进程标示：IP+TCP(UDP)端口<br>③传给谁：对方的应用进程标示：对方的IP+TCP(UDP)端口号<br>传输层实体（TCP or UDP实体）根据这些信息进程TCP报文段（UDP数据报）的封装。<br>如果Socket API每次传输报文，都携带这么多信息（IP+TCP/UDP端口），易出错，不易管理。<br><mark class="hl-label pink">TCP Socket</mark> ：TCP服务，两个进程通信之前需要建立连接（持续一段时间）。<br>可以用一个整数表示两个实体之间的通信关系（本地标示）；穿过层间的信息量最小。<br><font color="purple">TCP Socket是本地IP、本地TCP端口、对方IP、对方TCP端口以及连接状态的一个本地标识，是一个整数。</font>（会话关系的本地标识）<br>Socket是TCP之上的套接字。<font color="purple">4元组</font>，唯一指定一个会话。简单，便于管理。<br>TCP是传数据报和Socket这两样东西。<br><mark class="hl-label pink">UDP Socket</mark> ：UDP服务，两个进程通信前无需建立连接。<br>每条报文独立传输；前后报文可能给不同的分布式进程。因此只能用一个整数表示本应用实体的标示。穿过层间接口的信息量最小。<br><font color="purple">UDP Socket是本地IP、本地端口号的标识。2元组。</font>传输报文时需要提供对方IP、对方端口；接收报文时需要上传对方IP、对方端口。<br>UDP是传数据报、Socket、对方IP、对方端口号这四样东西。<br>套接字Socket像是门（饥荒小木牌）。进程向套接字发送报文或从套接字接收报文。<br><strong>（3.1）-&gt; 如何使用传输层提供的服务实现应用</strong><br>定义应用层协议：报文格式、解释、时序等。<br>编制程序：通过API调用网络基础设施提供通信服务传报文、解析报文、实现应用时序等。<br><mark class="hl-label pink">应用层协议</mark> 定义了运行在不同端系统上的应用进程如何交换报文，规范了报文类型、语法、语义、规则。<br>应用协议是应用的一个组成成分。<br>公开协议：HTTP，SMTP等。由RFC文档定义。<br>私有协议：Skype等。<br><strong>（3.2）-&gt; 应用层需要传输层提供什么样的服务</strong><br>要素：数据丢失率，延迟，吞吐，安全性。</li><li>安全TCP<br>（1）TCP&amp;UDP<br>（2）SSL（Security Socket Layer）：基于TCP提供加密的TCP连接，位于应用层。<br>网站http开头：跑在TCP之上；https开头：跑在SSL over TCP之上。</li></ol><h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><p>Web网页：由一些对象组成（e.g.HTML文件、图片、Java小程序、mp3文件等）。<br>Web页含有一个基本的HTML文件，该文件包含若干对象的引用（链接）。<br>通过URL对每个对象进行引用，URL包含访问协议，用户名，口令字，端口号等。</p><ol><li>HTTP概况<br>HTTP：超文本传输协议。Web的应用层协议。<br>客户/服务器模式：<br>（1）客户：请求、接收和显示Web对象的浏览器。<br>（2）服务器：对请求进行响应，发送对象的Web服务器。<pre><code> PC/mobile browser-&gt;HTTP request                     HTTP response&lt;-Web server</code></pre>HTTP跑在TCP之上：<br>（1）客户发起与服务器的TCP连接（建立套接字）；<br>（2）服务器接收客户的TCP连接；<br>（3）在浏览器与Web服务器交换HTTP报文；<br>（4）关闭TCP连接。<br>HTTP是无状态的，服务器不维护。<br>服务器刚刚建立的时候，守候在默认的80端口，套接字为Socket1（S1）；一个连接建立起来后得到S2，又一个连接建立后得到S3，原来的S1等待着其它Web浏览器的并发建立连接请求。（S1是waiting socket，特殊socket）<br><strong>非持久HTTP</strong><br>最多只有一个对象在TCP连接上发送；<br>下载多个对象需要多个TCP连接；<br>HTTP/1.0使用非持久连接。<br>三次握手：[连接请求，连接确认，http request]，http response，关闭连接。（上传10个文件就重复操作这五步10次）<br>缺点：每个对象要两个RTT；操作系统必须为每个TCP连接分配资源；浏览器通常打开并行TCP连接以获取引用对象。<br><strong>持久HTTP</strong><br>多个对象可以在一个TCP上传输；<br>HTTP/1.1默认使用持久连接。<br>三次握手基础上不关闭连接。<br>优点：保持连接；反复请求，使用相同连接传送；引用对象可以尽快发送。<br>（1）非流水方式的持久HTTP：客户端收到一个响应才能发送新的请求；每个引用对象花费一个RTT。（串行）<br>（2）流水方式的持久HTTP：HTTP/1.1默认模式；客户端遇到一个引用对象就立刻产生一个请求；有可能所有引用对象只花费一个RTT。（并行，多线程）<br><strong>响应时间模型</strong><br>往返时间RTT：一次往返传播的时间（传播是两主机的距离要有时间，传输是把数据打到电线上要的时间。这里传输时间不计）<br>响应时间：一个RTT用来发起TCP连接，一个RTT用来发送HTTP请求并等待HTTP响应。<br>文件传输时间：2RTT+1个对象传输时间</li><li>HTTP请求报文<br>两种类型：请求，响应<br>格式：ASCII，可读<br>HTTP请求报文：请求行（get,post,head命令） + 首部行（host,user-agent,connection等信息） + 换行回车符（表示结束）<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/1.jpg" width="50%"><br>提交表单输入：post方式（网页通常包括表单输入，包含在实体主体中的输入被提交到服务器），url方式（通过请求行额度url字段上载）<br><code>www.123.com/test?monkeys&amp;banana</code></li><li>HTTP响应报文<br>状态行（协议版本，状态码，状态信息） + 首部行 + 数据（e.g.请求的HTML文件）<br><a href>HTTP响应状态码</a>（待补充）</li><li>用户-服务器状态：cookies<br>四个组成部分：。。。（刷到题再记）</li><li>Web缓存 代理服务器（proxy server）<br>不访问原始服务器，就满足客户请求。<blockquote><p>一类是Gib Mib Kib,代表的是1024进制的计数单位,一类是gb mb kb,代表的是1000进制的计数单位无特殊标注。<br>大部分简写都表示1024进制换算单位，u盘厂商一般是按1000进制换算的，这也是u盘插电脑上显示的内存都会比标注的少的原因。<br>速率按1000，大小按1024。<br>b是bit，B是字节。MBps和Mbps不一样。</p></blockquote></li><li>条件get</li></ol><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h3><p>功能：上传&amp;下载-&gt;文件共享<br>默认端口：21（waiting port）<br>明文传输<br>控制连接（port21，带外传送）&amp;数据连接（port20，带内）<br>FTP特点：控制命令和数据传输分别在两个不同TCP连接上。而HTTP的控制和响应数据在一个连接上。<br>HTTP本身无状态，通过cookies变成有状态协议；FTP是有状态协议。</p><h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><p>协议组成部分：用户代理，邮件服务器，简单邮件传输协议SMTP<br>用户代理：又名“邮件阅读器”，e.g.Foxmail、QQ邮箱，输入和输出邮件保存在服务器。<br>三跳：用户代理发给邮件服务器 -&gt; 邮件服务器发给目标邮件服务器 -&gt; 用户代理POP3存取协议从邮件服务器拉取邮件。(前两跳是推，最后一跳是拉)<br>SMTP协议：使用TCP在客户端和服务器之间传送报文，默认端口号25。传输的三个阶段（握手，传输报文，关闭）。<br>MINE：multimedia mail extension 多媒体邮件扩展。编码和解码。<br>原始的SMTP协议只能传输ASCII字符的邮件，引入MINE扩展后可以传输更多内容。<br>POP3协议：邮件的存取协议。拉邮件。用户确认阶段，事务处理阶段。无状态。本地管理文件夹。<br>IMAP：保留用户状态。远程管理文件夹。<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/2.jpg" width="60%"></p><h3 id="DNS（Domain-Name-System）-域名解析系统"><a href="#DNS（Domain-Name-System）-域名解析系统" class="headerlink" title="DNS（Domain Name System） 域名解析系统"></a>DNS（Domain Name System） 域名解析系统</h3><p>不是直接给人用的，是为其它应用服务的，其它应用最终是给人用的。<br>服务：域名（应用层）和IP地址（传输层）的转换。用于Web,ftp等。<br>必要性：IP地址不便记忆，便于通过域名寻址。<br>需要解决的三个问题：分层命名，分布式解析，增加和删除域名（命名，解析，维护）<br>历史：ARPANET解决方案，存在一个维护站，主机数量太大时难以分配<br>DNS的思想：分层命名，分布式数据库（树状关系），运行在UDP之上，核心的Internet功能但以应用层协议实现。<br>核心部分：互连的路由器,网络的网络，为边缘部分提供服务(连通性和数据交换)，核心功能是路由(决定分组采用的到目标的路径)和转发(将分组从路由的输入链路转到输出链路)。互联网很多核心内容在建立在互联网边缘的端系统的应用之上实现的。（应该是核心部分简单稳定却强大，把复杂易错的精细活交给边缘设备）<br>DNS其它目的：别名转换为规范名字；负载均衡。<br>DNS域名结构：层次树状结构（每个树叶代表主机，用dot区分层次）。Internet根被划分为几百个顶级域名，分为通用的（.com, .edu, .gov…）和国家的（.cn, .us…）；顶级域可以分为若干个二级域……<br>全球共13个根名字服务器，可靠。（10个在美国、1个在英国、1个在瑞典、1个在荷兰）<br>域的划分是逻辑的，不是物理的。<br>DNS：保存资源记录（RR）的分布式数据库，RR格式（name,value,type,ttl）。（TTL:生存时间，决定该资源记录从缓存中删除的时间，默认2天）<br>DNS大致工作过程：应用调用解析器；解析器作为客户向Name Server发出查询报文；Name Server返回响应报文。<br>一台设备上网必须具备四个信息：ip地址，子网掩码，默认网关default gateway，local name server(DNS)。（得到Name和IP的对应关系）</p><h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p>（P2P与C/S模式并列）<br>纯P2P架构：几乎没有一直运行的服务器；任意端系统可以直接通信；利用peer的服务能力，peer节点间歇上网，每次IP地址可能有变化。（e.g.Skype, BitTorrent, KanKan）<br>采用C/S方法将一个F大小的文件分发给N个客户端耗时（下限）：</p><script type="math/tex; mode=display">D_{C-S} \geq max\{\dfrac{NF}{u_{s}},\dfrac{F}{d_{min}}\} （随着N线性增长）</script><p>所有用户都从服务器下载。u是服务器上载速率，d是客户端下载速率。总时间与N呈线性增加关系。<br>采用P2P方法讲一个F大小文件分发给N个客户端耗时：</p><script type="math/tex; mode=display">D_{P2P} \geq max\{\dfrac{F}{u_{s}},\dfrac{F}{d_{min}},\dfrac{NF}{u_{s}+\sum{u_{i}}}\}</script><p>所有peer节点（客户端）都可以上载。N越大，时间越长，但相比C/S节省的时间也越多。（斜率变小）<br>随着N的数量增加，请求资源的节点数量在增加，提供服务的节点数量也在增加，可扩充用户数量比C/S多得多。可扩展性好，但难以维护。</p><p>P2P资源共享的两大问题：如何定位所需资源，如何处理对等方的加入与离开；可能的方案：集中，分散，半分散。</p><p><strong>非结构化P2P</strong><br>peer与peer构成了一个覆盖网，构成一条边，是随机的。<br>非结构化P2P：集中式目录，完全分布式，混合体。<br>集中式目录存在的问题：单点故障，性能瓶颈，侵犯版权。（文件传输是分散的，而定位内容是高度集中的）<br>完全分布式例子：查询洪泛：Gnutella：没有中心服务器，许多Gnutella客户端，覆盖网络（图）。（去中心化）<br>Gnutella：对等方加入。X试图与可用对等方列表上的对等方建立TCP连接，X向Y发送一个Ping报文，收到Ping报文的对等方以Pong报文响应，然后它能建立TCP连接。<br>混合体例子：利用不匀称性：KaZaA<br>每个对等方是组长或属于一个组长，对等方与组长间或组长之间存在TCP连接。<br>每个文件有唯一hash值（散列标识码）作为id，一个描述字段用于查询<br>KaZaA实例：BigTorrent：请求，发送文件块。新的Peer节点加入洪流（bitmap），成为吸血鬼，开始白嫖，先下载稀缺块（稀缺优先策略），并且优先向那些为我提供最好服务的节点提供服务，巧妙地将集体利益和个人利益结合在一起。<br><strong>结构化（DHT）P2P</strong><br>peer与peer构成一个有序的overlay，构成一个环/树。<br>结构化P2P维护一个树状或环状有序拓扑，每个节点用ip对应的16字节hash值作为唯一标识。文件也有对应的hash，节点ID与文件是重叠的 文件在哪些节点之上是约定好的，通过有序的节点与节点之间的拓扑，能很快找到内容所在的位置，实现快速内容分发。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>视频流化服务：视频流量占据着互联网的大部分带宽。挑战：规模性，异构性。解决方案：分布式的、应用层面的基础设施。<br>视频：固定速度显示的图像序列。<br>CBR：constant bit rate 以固定速率编码。<br>VBR：variable bit rate 视频编码速率随时间的变化而变化。<br>（画面变化更多的视频比几乎不变的视频丢失帧率更多）<br>AVS：高级视频编码。<br>存储视频的流化服务：缓冲<br>DASH协议：动态自适应流化，基于HTTP。服务器将视频分割成多个块，每个块独立存储，编码于不同码率，告示文件（manifest file）提供不同块的url。客户端先获取告示文件，周期性地测量服务器到客户端的带宽，查询告示文件，一个时刻请求一个块，HTTP头部指定字节范围。（客户端根据带宽、网络能力、播放需求等一边播放一遍决定后续请求哪些块 -&gt; B站）<br>CDN：Content Distribution Networks<br>挑战：服务器如何通过网络向上百万用户同时流化视频内容。<br>方案1：单个大的超级服务中心（缺点：瓶颈链路带宽小导致停顿，单点故障，视频拷贝多效率低，周边网络拥塞）（评价：简单，但不可扩展）<br>方案2：CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务。<br>（1）enter  deep：将CDN服务器深入到许多接入网（优点：距离近，数量多，速度快）（缺点：管理困难）e.g.Akamai<br>（2）bring home：部署在少数（10个左右）关键位置，采用租用线路将服务器簇连接起来。e.g.Limelight<br>在CDN节点中存储内容的多个拷贝，用户从CDN中请求内容。<br>位于应用层，靠主机与主机之间的配合提供服务。<br>Netflix网飞案例：网飞制作内容，上传至亚马逊云端（Amazon Cloud），卖给多个运营商，包括Akamai CDN, Limelight CDN, Level-3 CDN，来加速内部访问。网飞自己维护认证服务器，完成认证后访问网页，网页也在云端，用户可以自己选也可以自动选择最近的运营商缓存节点，从而得到服务。</p><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>作用：通信<br>Socket编程：socket是传输报文应用层和传输层的门，socket api是创建socket的函数。<br>两种传输层服务的socket类型：TCP可靠，UDP不可靠。<br>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户。<br>TCP服务：从一个进程向另一个进程可靠地传输字节流。<br><strong>TCP套接字编程步骤</strong>：<br>（1）服务器首先运行，等待连接建立。创建欢迎socket，和本地端口捆绑，在欢迎socket上阻塞式等待接收用户的连接。<br>（2）客户端主动和服务器建立连接。创建客户端本地套接字（隐式捆绑到本地port），指定服务器进程的IP地址和端口号，与服务器进程连接。<br>（3）当与客户连接请求到来时，服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket，与客户端通信。允许服务器与多个客户端通信，使用源IP和源端口来区分不同的客户。<br>（4）连接API调用有效时，客户端P与服务器建立了TCP连接。建立<br>（原来的welcome socket和本地端口捆绑，connect socket和客户端IP捆绑；<br>连接后，connect socket关闭，welcome socket仍然守候。）<br>从应用进程角度：TCP在客户端和服务器进程之间提供了可靠的字节流（管道）服务。</p><div class="table-container"><table><thead><tr><th>数据结构 socketaddr_in</th><th>IP地址与port跳转关系的数据结构（标识进程的端节点）</th></tr></thead><tbody><tr><td>sin_family</td><td>地址簇，常量，代表用的TCP/IP协议还是IPX协议</td></tr><tr><td>sin_port</td><td>端口号port</td></tr><tr><td>sin_addr</td><td>IP地址</td></tr><tr><td>sin_zero[8]</td><td>对齐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>数据结构 hostent</th><th></th></tr></thead><tbody><tr><td>*h_name</td><td>主机域名</td></tr><tr><td>**h_aliases</td><td>多个域名别名</td></tr><tr><td>h_length</td><td></td></tr><tr><td>**h_addr_list[i]</td><td>多个IP地址（放到socketaddr_in/sin_addr）</td></tr></tbody></table></div><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>UDP socket<br>客户端与服务器之间没有连接，没有握手。<br>包括信息：我的socket值（本地IP和UDP端口），发送内容，发给谁（对方IP对方端口）。<br>收报文时的两件事：对方发送的内容，对方的端节点。<br>传送的数据可能丢失。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>应用程序体系结构：C/S，PSP，混合。</li><li>应用程序需要的服务器品质描述：可靠性，带宽，延时，安全。</li><li>Internet传输层服务模式：TCP（可靠的、面向连接的服务），UDP（不可靠的数据报）。</li><li>流行的应用层协议：HTTP,FTP,SMTP,POP,IMAP,DNS。</li><li>Socket编程。</li><li>应用层协议报文类型：请求/响应报文：客户端请求信息或服务；服务器以数据、状态码进行响应。</li><li>报文格式：首部（关于数据信息的字段），数据（被交换的信息）。</li><li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序，以及一条报文传输和接收或其它事件采取的动作。</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/06/LearnNet2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（一）——概述</title>
      <link>https://pearlchocolatezy.com/2024/12/28/LearnNet/</link>
      <guid>https://pearlchocolatezy.com/2024/12/28/LearnNet/</guid>
      <pubDate>Sat, 28 Dec 2024 08:17:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;核心知识点概览&quot;&gt;&lt;a href=&quot;#核心知识点概览&quot; class=&quot;headerlink&quot; title=&quot;核心知识点概览&quot;&gt;&lt;/a&gt;核心知识点概览&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;top down 自顶向下，从应用层到物理层。&lt;/li&gt;
&lt;li&gt;每个层次的功能（能力）</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="核心知识点概览"><a href="#核心知识点概览" class="headerlink" title="核心知识点概览"></a>核心知识点概览</h2><ol><li>top down 自顶向下，从应用层到物理层。</li><li>每个层次的功能（能力），和提供的主要服务（能力的一个体现）。功能的范围更广。</li><li>每一层的功能都通过向上层提供的接口向上层提供服务。本层功能的实现要通过层间的接口调用下层的服务。（<font color="purple">下为上服务，上调下实现</font>）</li><li>实例（应用层）<br>（1）支持web应用的HTTP协议<br>（2）支持ftp应用的FTP协议<br>（3）传送和接收电子邮件用的SMTP协议和POP3协议</li><li>传输层提供的两种服务：TCP, UDP。</li><li>TCP：传输控制协议（传输层）。很多应用（应用层）都跑在TCP协议之上，包括FTP协议、telnet、web的应用（浏览器）。</li><li>HTTP在传输层TCP的协议之上。</li><li>浏览器：三次握手原理<br><img class="zy_img_shadow" src="/2024/12/28/LearnNet/1.jpg" width="50%"></li><li>可靠性（reliable）：不出错、不失序、不重复、不丢失（可靠越高，代价越大，比如延迟）</li><li>一般的实时多媒体<font color="purple">（游戏串流、直播）：UDP</font>（对丢失要求不高，但对实时性要求高）</li><li>事务性应用（聊天）：UDP（一次往返）</li><li><font color="purple">FTP</font>：客户端和服务器之间的交互（e.g.<font color="purple">上传下载</font>）</li><li>不同应用之间的交互，不同厂商生产的路由器之间的交互（华为&amp;思科），不同厂商生产的网卡之间的交互（华为&amp;清华）</li><li>传输层为远程的应用进程提供服务，传输层是在网络层提供的端到端的服务基础之上实现的，然后区分为进程到进程（<font color="purple">细分且加强</font>）</li><li>网络层提供源主机到目标主机（端到端,end to end,E2E）之间的数据交互（ip数据报）。网络层的服务在链路层P2P的服务基础之上实现。</li><li><font color="purple">网络层有两种工作方式：传统的方式、现代的SDN方式。</font><br>（1）传统方式：路由协议，IP协议。<br>路由协议：运行在路由协议上的软件称为路由实体，和其它路由器的的路由软件交换路由报文（e.g.到哪个子网），按照某种路由选择算法算出路由表，路由表包括IP子网该怎么走，路由表给IP协议使用。<br>网络层得到基本功能：路由（由路由协议交换路由信息，由路由算法得出路由表），转发（IP协议：根据ip目标查路由表，查到表项后，从合适的的端口转发出去，查不到则按照默认路径转走）。<br>缺点：路由器一旦设立好后不变，无法升级更新。<br>（2）SDN方式：数据平面（交换机），控制平面（网络操作系统）<br>网络应用根据不同的运算，得到不同的流表，下发给交换机，交换机（上载分组匹配）根据匹配完的流表可做的工作是多样化的（block阻止，换字段，泛洪，转发…）。<br>优点：更一般化，IP路由器相当于SDN的一个特例，网络运营商可以编程。</li><li>数据链路层（网卡）提供点到点（point to point,P2P）的服务，在物理层提供的基础之上提供帧到帧的数据。</li><li>选学：网络安全，无线和移动网络，多媒体网络，网络管理。</li><li><font color="red">【自顶向下】：应用层传输层网络层：数据平面网络层：控制平面数据链路层&局域网</font></li></ol><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>目标：<br>（1）了解基本术语和概念<br>（2）掌握基本原理<br>（3）方法：以Internet为例<br>提纲：<br>（1）什么是Internet<br>（2）什么是协议<br>（3）网络边缘<br>（4）接入网、物理媒体<br>（5）网络核心：分组交换、线路交换<br>（6）Internet/ISP结构<br>（7）性能：丢包、延时、吞吐量<br>（8）协议层次、服务模型<br>（9）历史</p><h3 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h3><p>网络：节点和边<br>计算机网络：联网的计算机所构成的系统。节点：主机节点（■）&amp;数据交换节点（●，中转节点，不是源，也不是目标，负责转发数据，e.g.路由器、交换机、中继器），路由器工作在网络层，交换机工作在链路层，中继器工作在物理层。边：接入网链路（access,主机连接到互联网）&amp;主干链路（backbone,路由器之间）。协议：（按层次不同…，遵守同样的协议才能互通）<br>互联网：由以TCP协议和IP协议为主的一簇协议支撑的网络，网络之间任意连接。<br>从构成角度，互联网包括节点和边。<br>从服务角度，互联网是分布式的应用进程（分布式的应用是网络存在的理由），以及为分布式应用进程提供服务的基础设施，提供服务的形式是API（TCP提供有连接的可靠服务，UDP提供无连接的不可靠服务）。<br>物联网：为生产生活提供便利的联网产品。<br>互联网的协议：RFC,IETF。<br>协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收或其它事件方面所采取的动作。</p><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>网络边缘：主机&amp;应用程序（客户端和服务器）<br>网络核心：互联着的路由器&amp;网络的网络。作用：数据交换。<br>网络核心的作用：宏观上，全球范围内的，几十亿个节点之间的，数据交换；微观上，大量单个的路由器及其链路相互构成的分布式系统，由它们的相互配合，来完成从源主机到目标主机之间的发送与接收。<br>接入网、物理媒体：有线或者无线通信链路<br>通过网络核心实现主机与主机之间的联通</p><font color="purple">边缘 接入 核心</font><p>基础设置为分布式应用提供通信服务。<br>应用进程通信的模式：<br>（1）CS模式（客户/服务器模式）：客户端向服务器请求、接收服务。e.g.Web浏览器,email客户端/服务器。<br>（2）对等模式（peer-peer）：每个节点即使客户端又是服务器，解决了CS模式不可扩展的缺点</p><p>网络边缘定义：采用网络设施的面向连接服务。<br>网络边缘目标：在端系统之间传输数据。<br>握手：在数据传输之前做好准备。（面向连接的通信方式；通信状态只在端系统维护，网络不知道）<br>TCP：互联网上面向连接服务。<br>TCP服务特性：可靠性，保序，流量控制，拥塞控制<br>使用在UDP之上的两个进程：无连接服务，不可靠，没有流量控制，没有拥塞控制，实时性。</p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心：路由器的网状网络。<br>数据怎样通过网络进行传输：（1）电路交换；（2）分组交换。</p><h4 id="电路交换（线路交换）"><a href="#电路交换（线路交换）" class="headerlink" title="电路交换（线路交换）"></a>电路交换（线路交换）</h4><p>call: 端到端的资源被分配给从源端到目标端的呼叫。<br>为呼叫预留端-端资源。要求建立呼叫连接。<br>一次呼叫采用了某条链路的某条线路（piece）；<br>优点：独享资源，不共享，没人抢，性能有保障；<br>缺点：如果呼叫没有数据发送，被分配的资源就会被浪费；<br>通常被传统网络电话采用。<br>网络资源（如带宽）被分成<font color="purple">片</font><br>将带宽分成片：频分（FDM: frequency-division multiplexing），时分（TDM: time-division multiplexing），波分（WDM: wave-division multiplexing 光纤通信），码分（CDM）。<br>为呼叫分配片。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q：两个节点（主机A和主机B）之间通信的带宽是1.536Mbps，采用时分多路复用，分为24个时隙（时槽，slot），每个用户使用其中第n个时隙。</span><br><span class="line">两个主机在通信前建立线路需要500ms（毫秒），文件大小640k</span><br><span class="line">A：每个用户能获得的带宽（一片的通信能力）=1.536Mbps/24=64Kbps（采用TDM的方式，只能获得这个通信链路的1/24）</span><br><span class="line">①建立连接所需的时间=500ms=0.5s</span><br><span class="line">②文件传输所需的时间=640Kbits/64Kbps=10s</span><br><span class="line">共用时间=0.5s+10s=10.5s</span><br><span class="line">③传播延迟：局域网下，可忽略不计；广域网下，要考虑传播时间</span><br><span class="line">1bit在空间上传输所需的时间=1/64Kbps*30万公里/秒（真空）</span><br></pre></td></tr></table></figure><br>电路交换不适合计算机之间的通信：<br>（1）连接建立时间长；<br>（2）计算机间通信有突发性，使用电路交换浪费的片较多；<br>（3）可靠性不高。</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>以分组为单位存储：网络带宽资源不再分为一个个片，传输时使用全部带宽；主机之间传输的数据被分为一个个分组。<br>优点：资源共享，按需存储。</p><p><font color="purple">以存储-转发的方式工作</font><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在一个速率为R bps的链路</span><br><span class="line">一个长度为L bit的分组的存储转发延时=L/R s</span><br><span class="line">若L=7.5Mbits，R=1.5Mbps</span><br><span class="line">三次存储-转发延时=7.5Mbits/1.5Mbps*3=15s</span><br></pre></td></tr></table></figure><br>缺点：排队和延迟：如果到达速率&gt;链路的输出速率，分组将会排队，等待传输；如果路由器缓存用完，分组将会被丢弃。</p><p>网络核心的关键功能：路由（全局，决定分组采用的源到目标路径） &amp; 转发（局部，查路由表，将分组从路由器的输入链路转移到输出链路）</p><p>分组交换：统计多路复用（没有固定的分组模式）</p><p>分组交换适合突发式数据传输：资源共享；简单，不必建立呼叫。<br>分组交换过度使用会造成网络拥塞：分组延时和丢失。对可靠地数据传输需要协议来约束：拥塞控制。</p><p>分组交换按有无网络层的连接分类：数据报网络（主机之间没建立连接，不维护状态，路由器根据分组的目标地址进行路由），虚电路网络（有连接，虚拟电路建立逻辑连接，每个交换节点都有标识）</p><h4 id="分组交换-VS-电路交换"><a href="#分组交换-VS-电路交换" class="headerlink" title="分组交换 VS 电路交换"></a>分组交换 VS 电路交换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q：n人共享带宽为1Mbps的链路，每个用户活跃时为100Kb/s，有P=10%的时候是活跃的，问采用电路交换或分组交换分别支持的用户人数。（Kb/s即Kbps，Kb每秒）</span><br><span class="line">A：①采用电路交换最多支持的用户人数=1Mbps/(100Kbps)=10人</span><br><span class="line">②采用分组交换：假设共有N=35个用户，那么支持10个用户活跃的可能性为</span><br></pre></td></tr></table></figure><p>$1-\sum_{n=0}^{10} \binom{35}{n} P^n (1-P)^{35-n}$ =0.0004=0.04%（概率论二项分布）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用1减后，就是10个以上用户同时活跃的概率；</span><br><span class="line">总共35个用户时，有0.04%的情况下是不够用的，10人以上就超过1Mbps了，有99.96%的概率没问题。</span><br><span class="line">所以，采用分组交换共享性更好。</span><br></pre></td></tr></table></figure></p><h3 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h3><p>怎样接入核心<br>怎样将端系统和边缘路由器连接：住宅接入网，单位接入网（学校，公司），无线接入网<br>接入网的重要概念：带宽（bps, bits per second）</p><ol><li>住宅接入：modem（调制解调器）<br>调制解调器用于将电话信号或光信号转为网络信号。<br>调制解调器分为连接电话线的和连接光缆的，即猫和光猫。<br>接入网：线缆网络<br>混合光纤同轴电缆（HFC，hybrid fiber coax）：非对称<br>线缆和光纤网络将各家庭用户接入到ISP路由器。</li><li>企业接入网络：Eternet（以太网）<br>有线：出口不止一个<br>以太网一般是指有线连接</li><li>无线接入网<br>各无线端系统共享无线接入网络。<br>无线LANs（局域接入，WiFi，接入带宽越来越快）&amp;广域无线接入（4G or 5G）。</li><li>物理媒体<br>Bit（比特）：在传输-接收对间传播。<br>物理链路：在每个传输-接收对，跨越一种物理媒体。<br>导引型媒体：信号沿着固体媒介被导引（同轴电缆、光纤、双绞线）。<br>非导引型媒体：信号自由传播（无线电）。<br>双绞线（TP）：两根绝缘铜线。<br>同轴电缆：两根同心的铜导线，双向，基带电缆（电缆上一个单信道，Ethernet），宽带电缆（电缆上有多个信道，HFC）。<br>光缆：光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输；高速，低误码率，安全。</li><li>物理媒介：无线链路<br>双向<br>传播环境效应：反射，吸收，干扰<br>无线链路类型：地面微波，LAN，wide-area(蜂窝)，卫星（延迟不可忽略）</li></ol><h3 id="1-5-Internet结构和ISP"><a href="#1-5-Internet结构和ISP" class="headerlink" title="1.5 Internet结构和ISP"></a>1.5 Internet结构和ISP</h3><p>ISP：Internet Service Providers<br>关联比较密集的网络称为ISP。<br>端系统通过接入ISPs接入互联网。<br>接入ISP的端系统彼此互联。ISP之间通过互联网接入点IXP完成交换。<br>任何两个端系统可以相互发送分组到对方。<br>ISP提供接入，提供网（学校，企业，无法为全球提供）；ICP提供业务和内容。<br>ISP之间的连接：高层ISP&amp;低层ISP，2个ISP对等接入（不收费），IXP&amp;ISP（不收费），ICP&amp;ISP</p><p>Internet结构：<font color="purple">松散的层次模型</font><br>（1）中心：第一层ISP（点很少，国家/国际覆盖，速率极高，直接与其它第一层ISP相连，与大量的第二层ISP和其他客户网络相连，<font color="purple">global</font>）<br>（2）第二层ISP：更小些的ISP，区域性的（<font color="purple">regional</font>）<br>（3）第三层ISP与其它本地ISP：接入网与端系统最近（<font color="purple">local</font>）</p><h3 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h3><ol><li>分组延时和丢失的原因：<br>在路由器缓冲区的分组队列，<br>（1）分组到达链路的速率超过了链路输出的能力（分组到达时，没有可用的缓冲区）；<br>（2）分组等待排到队头、被传输</li><li><p>四种分组延时：<br>（1）节点处理延时：检查bit级差错；检查分组首部和决定将分组导向何处；<br>（2）排队延时：在输出链上等待传输的时间；依赖于路由器的拥塞程度（随机）；取决于流量强度（越趋近于1，延时越大，且是无限大）；<br>（3）传输延时：打出bit的时间，将分组发送到链路上的时间=L/R，存储转发延时；<br>（4）传播延时：物理延时=d（物理链路的长度）/s（在媒体上的传播速度≈2*10^8m/s）</p><script type="math/tex; mode=display">d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}</script></li><li><p>分组丢失的原因：<br>（1）链路的队列缓冲区容量有限<br>（2）当分组到达一个满的队列时，该分组将会丢失<br>（3）丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</p></li><li>吞吐量：在源端和目标端之间传输的速率（数据量/单位时间）。<br>（1）瞬间吞吐量：在一个时间点的速率<br>（2）平均吞吐量：在一个长时间内的平均值<br>瓶颈链路：端到端路径上，限制端到端吞吐量。<br>最细的部分决定吞吐多少数据。端到端平均吞吐=min{R1,R2…Rn}（R1-Rn为端到端之间的多条链路）<br>e.g.第一跳的链路共8个人用，我获得1/8的带宽（一跳的意思是一个路由）。每条链路都有确定的最小带宽为瓶颈带宽，它限制了节点A到节点B之间的吞吐量。</li></ol><h3 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h3><p>互联网是一个非常复杂的系统。采用分层的方式实现计算机网络的功能。<br>两个应用进程交换应用报文实现各种网络应用（电子交易，远程登录，数据库查询，域名解析，文件上传下载等）</p><ol><li>服务<br>服务：低层实体向上层实体提供它们之间的通信的能力。（服务用户，服务提供者）<br>原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的。<br>服务访问点（SAP：Service Access Point)：下层的服务提供者来区分不同上层用户穿过层间的信息，因为服务提供者可能同时向多个上层用户提供服务。</li><li>服务的类型<br>（1）无连接的服务（Connectionless Service）：两个对等层实体在通信前不需要建立一个连接，不预留资源；不需要通信双方都是活跃；<br>特点：不可靠、可能重复、可能失序<br>IP分组，数据包<br>适用范围：适合传送零星数据；<br>服务类型：不可靠的数据报、电子方式的函件；有确认的数据报、挂号信；请求回答，信息查询。<br>（2）面向连接的服务（Connection-oriented Service）：建立连接，通信，拆除连接。<br>适用范围：大数据块的传输，不适合小的零星报文<br>特点：保序（不绝对）<br>服务类型：可靠的信息流（传送页面）；可靠的字节流（远程登录）；不可靠的连接（数字化声音）。<br>两个应用进程采用UDP的方式交互，UDP向进程提供的是无连接的服务。</li><li>服务与协议的区别 ★★★<br>（1）服务（Service）：通过相邻层间的接口在系统的内部（Interface上的SAP上，使用SAP是为了一个服务同时向多个用户提供服务），通过原语的形式向上层提供服务。低层实体向上层实体提供它们之间的通信的能力，是通过原语来操作的，垂直。<br>（2）协议（Protocal）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平。<br>服务与协议的联系：<font color="purple">协议的实现借助于下层提供的服务，协议的目的是为了向上层提供服务。<br>（实现本层写一需要借助下层提供的服务，实现本层协议的目的是为了向上层提供更好的服务）<br>协议是水平的，服务是垂直的。（水平协议，垂直服务）<br>服务的形式：原语</font></li><li>数据单元（DU）★★★<br>SDU + ICI = PDU   服务数据单元 + 接口控制信息 = 协议数据单元<br>进入每个子层未被处理的数据称为<font color="purple">服务数据单元</font>(SDU：service data unit)，经过子层处理后形成特定格式的数据被称为<font color="purple">协议数据单元</font>(PDU)<br>上层来了SDU，通过层间接口后，形成了这个SDU在第n层的头部（n-header），加起来形成了第n层的PDU（n-PDU），n-PDU再往下一层又成了下一层的SDU。（只是理论上的完美情况）<br>如果SDU是一个大数据块，SDU到达第n层厚会分成多个块，每一块分别加上n-header，形成多个n-PDU。<br>每一层的PUD都有head和body。body部分一定来自上层的SDU。<br>头部信息，有一部分是ICI附加上去的，有一部分是来自本层。<br>PDU是最常见的数据单元。<br>每一层的数据单元都有特定的称呼：<br>（1）应用层-&gt;应用报文（message）<br>（2）传输层-&gt;报文段（segment，简称：段；TCP:段，UDP:数据报）<br>（3）网络层-&gt;分组（packet，有连接）；数据报（datagram，无连接）<br>（4）链路层-&gt;帧（frame）<br>（5）物理层-&gt;位（bit） 等等</li><li>分层处理和实现复杂系统的好处：<br>（1）概念化：结构清晰，便于标示网络组件，以及描述其相互关系。<br>（2）结构化：模块化更易于维护和系统升级。改变某一层服务的实现不影响系统其它部分。</li><li>分层处理的缺点：效率低</li><li>Internet协议栈（每个层次分别有什么协议）<br>应用层：网络应用，FTP，SMTP，HTTP，DNS（应用层的协议是最多的）<br>传输层：主机之间的数据传输，TCP，UDP，<font color="purple">进程到进程</font>，把网络层提供的可能不可靠的通信服务变为可靠的通信服务<br>网络层：为数据报从源到目的选择路由，IP，路由协议（RIP OSPF BGP），E2E<font color="purple">端到端</font>（End to End）<br>链路层：<font color="purple">相邻</font>网络节点间的数据（以帧为单位）传输，点对点协议PPP，802.11（wifi），Ethernet<br>物理层：在线路上传送bit</li><li>ISO/OSI模型（与TCP/IP模型不同）<br>七层模型：应用层-&gt;<font color="orange">表示层-&gt;会话层</font>-&gt;传输层…<br>表示层：解释传输的数据（e.g.加密，压缩）<br>会话层：数据交换的同步，检查点，恢复<br>这两层的功能在TCP/IP模型中是应用层做的。</li></ol><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>…</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/12/28/LearnNet/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>换电脑后怎样迁移Hexo博客</title>
      <link>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/</link>
      <guid>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/</guid>
      <pubDate>Fri, 06 Dec 2024 00:03:11 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-安装Nodejs&quot;&gt;&lt;a href=&quot;#1-安装Nodejs&quot; class=&quot;headerlink&quot; title=&quot;1. 安装Nodejs&quot;&gt;&lt;/a&gt;1. 安装Nodejs&lt;/h2&gt;&lt;p&gt;安装最新版本的&lt;a href=&quot;https://nodejs.org/z</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1. 安装Nodejs"></a>1. 安装Nodejs</h2><p>安装最新版本的<a href="https://nodejs.org/zh-cn">Nodejs</a>。</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>安装最新版本的<a href="https://git-scm.com/">Git</a>。<br>配置全局email和name：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br></pre></td></tr></table></figure><br>检查配置信息：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></p><h2 id="3-迁移博客文件夹"><a href="#3-迁移博客文件夹" class="headerlink" title="3. 迁移博客文件夹"></a>3. 迁移博客文件夹</h2><ol><li><p>将文件夹迁移到新电脑后，在该文件夹内右键打开Git Bash。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/1.png" width="40%"></p></li><li><p>安装hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>大约需要几分钟的时间。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/2.png" width="60%"><br>然后就可以将博客在本地启动了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>配置新电脑的SSH key<br>在执行<code>hexo d</code>的时候会报<code>Spawn failed</code>错误，原因是新电脑还没有Git全局的SSH key，无法与Github仓库匹配。<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/3.png" width="60%"><br><br><code>win+R</code>运行<code>cmd</code>终端，并输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>两个密钥文件将保存到该默认目录下，不需要更改位置；<br>按照提示信息确认目录，以及是否配置密码（可以为空）：<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/4.jpg" width="60%"><br>找到这个目录下的配置文件，上面的是私钥，下面的是公钥：<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/5.png" width="60%"><br>如果博客仓库在GitHub上，菜单栏打开Settings，找到SSH and GPG keys，新建一个SSH key；<br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/6.png" width="40%"><br><img class="zy_img_shadow" src="/2024/12/06/DeployHexoOnNewComputer/7.png" width="60%"><br>使用记事本打开本地的公钥文件（pub文件），全选文字，复制到GitHub。<br><br>然后就可以博客就可以照常更新了~</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Git/">Git</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/12/06/DeployHexoOnNewComputer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统概述2</title>
      <link>https://pearlchocolatezy.com/2024/10/16/LearnOS2/</link>
      <guid>https://pearlchocolatezy.com/2024/10/16/LearnOS2/</guid>
      <pubDate>Wed, 16 Oct 2024 14:25:33 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 中断系统：中断系统是计算机的重要组成部分。中断装置和中断处理程序统称为中断系统。实时控制、故障自动处理、计算机与外围设备间的数据传送</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 中断系统：中断系统是计算机的重要组成部分。中断装置和中断处理程序统称为中断系统。实时控制、故障自动处理、计算机与外围设备间的数据传送往往采用中断系统。中断系统的应用大大提高了计算机效率。</p><p>1.2 进程的互斥：在逻辑上本来完全独立的若干进程，由于竞争同一个资源而产生相互制约关系。</p><p>1.3 进程的同步：进程间共同完成一项任务时直接发生相互作用的关系，在执行时间次序上必须遵循确定的规律。</p><p>1.4 I/O设备控制方式中的“程序控制方式”（PIO: Programmed I/O）：指由用户进程直接控制处理器，或内存和外部设备之间进行信息传送的方式，也称为“忙-等”方式、轮询方式或循环测试方式。这种方式的控制者是用户进程。</p><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><p>3.1 进程进入临界区的调度原则<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入；</span><br><span class="line">2. 任何时候，处于临界区内的进程不可多于一个，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</span><br><span class="line">3. 进入临界区的进程要在有限时间内退出以便其它进程能及时进入自己的临界区；</span><br><span class="line">4.如果进程不能进入自己的临界区，则应让出CPU避免出现“忙等”现象。</span><br></pre></td></tr></table></figure></p><p>3.2 防止死锁产生的途径<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用某些资源分配策略使死锁的四个条件之一不成立，就能防止死锁。</span><br><span class="line">1. 目前对于“互斥使用资源”条件没有应对策略；</span><br><span class="line">2. 对“占有并等待资源”、“不可抢夺资源”和“循环等待资源”这三个条件，可采用静态分配资源、释放已占资源、抢夺式分配资源和按序分配资源等资源分配策略。</span><br></pre></td></tr></table></figure></p><p>3.3 文件系统为什么要实现“按名存取”？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 要把文件存放到存储介质上或要从存储介质上读出文件，都必须记住存储空间的使用情况、文件存放的物理位置，以及启动相应的存储设备来保存和读出文件。</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/OS/">OS</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/10/16/LearnOS2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>数据库系统原理概述</title>
      <link>https://pearlchocolatezy.com/2024/10/02/LearnDB/</link>
      <guid>https://pearlchocolatezy.com/2024/10/02/LearnDB/</guid>
      <pubDate>Wed, 02 Oct 2024 08:40:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 游标：游标是数据库管理系统(DBMS)中的一种对象，主要用于在处理查询返回结果时逐行读取数据。游标的类型有两种：显示游标（一次读多行</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 游标：游标是数据库管理系统(DBMS)中的一种对象，主要用于在处理查询返回结果时逐行读取数据。游标的类型有两种：显示游标（一次读多行）、隐式游标（一次读一行）。</p><p>1.2 结构化查询语言：一种专门用来与数据库通信的语言，它可以帮助用户操作关系型数据库。例：SQL。</p><p>1.3 触发器：用户定义在关系表上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法。</p><p>1.4 数据库分割：将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 数据库分析与设计阶段的四个环节：需求分析、概念设计、逻辑设计、物理设计。</p><p>2.2 在MySQL中，一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p><p>2.3 视图表是由基本表或其他视图导出的表，是虚表，不对应实际存储的数据。</p><p>2.4 对于填有数据的游标，在MySQL中，可以使用<code>FETCH...INTO</code>语句从中读取数据。</p><p>2.5 完整性约束性条件的作用对象可以是列、元组和表。</p><p>2.6 大数据是指无法在可容忍的时间内用现有信息技术和软、硬件工具对其进行感知、获取、管理、处理的服务和数据聚合。</p><p>2.7 数据的集成是数据库管理系统的主要目的。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 （设计）某高校教师项目信息管理系统的数据库包含三个关系：<br>教师（教师工号，姓名，性别，年龄，职称）<br>项目（项目号，项目名称，级别）<br>申报（教师工号，项目号，工作量）<br>试实现下列操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--(1)使用关系代数查询“省级”级别的项目信息。</span></span><br><span class="line">σ级别<span class="operator">=</span>&quot;省级&quot;(项目)</span><br><span class="line"></span><br><span class="line"><span class="comment">--(2)使用关系代数查询教师的教师工号、姓名和职称。</span></span><br><span class="line">π教师工号,姓名,职称(教师)</span><br><span class="line"></span><br><span class="line"><span class="comment">--(3)使用SQL语句将“王宏”老师的职称改为“教授”。</span></span><br><span class="line"><span class="keyword">update</span> 教师 <span class="keyword">set</span> 职称<span class="operator">=</span>&quot;教授&quot; <span class="keyword">where</span> 姓名<span class="operator">=</span>&quot;王宏&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">--(4)使用SQL语句查询申报项目名称为“图像采集”的教师工号。（用嵌套查询）</span></span><br><span class="line"><span class="keyword">select</span> 教师工号 <span class="keyword">from</span> 申报 <span class="keyword">where</span> 项目号 <span class="keyword">in</span> (<span class="keyword">select</span> 项目号 <span class="keyword">from</span> 项目 <span class="keyword">where</span> 项目名称<span class="operator">=</span><span class="string">&#x27;图像采集&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--(5)使用SQL语句查询每名教师的总工作量</span></span><br><span class="line"><span class="keyword">select</span> 教师工号, <span class="built_in">sum</span>(工作量) <span class="keyword">as</span> 总工作量 <span class="keyword">from</span> 申报 <span class="keyword">group</span> <span class="keyword">by</span> 教师工号;</span><br></pre></td></tr></table></figure><p>3.2 简述三种典型的并发操作问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 丢失更新。</span><br><span class="line">设有两个事务T1和T2，当他们同时读入一个数据并加以修改时，事务T2的提交结果会破坏事务T1提交的结果。</span><br><span class="line">2. 不可重复读。</span><br><span class="line">两个事务T1和T2，不可重复读是指事务T1读取数据后，事务T2执行更新操作，使事务T1无法再现前一次读取的结果。</span><br><span class="line">3. 读“脏”数据。</span><br><span class="line">设有两个事务T1和T2，事务T1修改某一个数据，并将其写回磁盘，事务T2读取同一个数据后，事务T1由于某种原因被撤销，这时事务T1已修改过的数据恢复原值，事务T2读到的数据就与数据库中的数据不一致，则事务T2读到的数据就为“脏”数据。</span><br></pre></td></tr></table></figure></p><p>3.3 简述关系模型完整性约束的检验方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 执行插入操作时，首先检查实体完整性约束，然后检查参照完整性约束，最后检查用户定义完整性约束。</span><br><span class="line">2. 执行删除操作时，一般只需要对被参照关系检查参照完整性约束。</span><br><span class="line">3. 执行更新操作时，因为更新操作可看成是先执行删除操作，再执行插入操作，因此是上述两种情况的综合。</span><br></pre></td></tr></table></figure></p><p>3.4 简述SQL的核心组成部分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 数据定义语言</span><br><span class="line">2. 数据操纵语言。</span><br><span class="line">3. 数据控制语言。</span><br><span class="line">4. 嵌入式和动态SQL规则。</span><br><span class="line">5. SQL调用和会话规则。</span><br></pre></td></tr></table></figure></p><p>3.5 简述删除存储函数的语句及注意事项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除语句：DROP FUNCTION。</span><br><span class="line">注意事项：</span><br><span class="line">（1）在删除之前，必须确认该存储函数没有任何依赖关系，否则会导致其他与之关联的存储函数无法运行。</span><br><span class="line">（2）为防止因删除不存在的存储函数而引发错误，可在DROP FUNCTION语句中添加关键字“IF EXISTS”。</span><br></pre></td></tr></table></figure></p><p>3.6 简述关系数据模型的优化方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 确定各属性间的函数依赖关系。</span><br><span class="line">2. 对于各个关系模型之间的数据依赖进行极小化处理，消除冗余的联系。</span><br><span class="line">3. 判断每个关系模式的范式，根据实际需要确定最合适的范式。</span><br><span class="line">4. 按照需求分析阶段得到的处理要求，对某些模式进行合并或分解。</span><br><span class="line">5. 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率。</span><br></pre></td></tr></table></figure></p><p>3.7 （综合）某大学图书管理信息系统需要管理如下信息：<br>图书（图书号，书名，作者，定价）<br>学生（学号，姓名，专业）<br>出版社（出版社名称，地址，电话，邮编）<br>其中：一个出版社可以出版多种图书，但每本图书只能在一个出版社出版；每位学生可以借阅多本图书，每本图书可以供多维学生借阅；学生借书要记录借书日期和还书日期。试完成下列要求：<br>（1）实体关系的E=R图<br><img class="zy_img_shadow" src="/2024/10/02/LearnDB/3.7.1.jpg" alt width="60%"></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant Alice    participant Bob    Alice -&gt;&gt; Bob: 你好，Bob！    Bob --&gt;&gt; Alice: 你好，Alice！  </pre></div><p>（2）转换成关系模式<br>图书（图书号，书名，作者，定价，）</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/SQL-Server/">SQL Server</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/10/02/LearnDB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>操作系统概述</title>
      <link>https://pearlchocolatezy.com/2024/09/26/LearnOS/</link>
      <guid>https://pearlchocolatezy.com/2024/09/26/LearnOS/</guid>
      <pubDate>Thu, 26 Sep 2024 14:40:51 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;
&lt;p&gt;1.2 线</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1.1 进程：进程是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><p>1.2 线程：线程是进程中的一个实体，是处理器调度和分派的基本单位。可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><p>1.3 原语：原语是由若干条指令所组成的一个指令序列。用来实现某个特定的操作功能。具有连续性，不可分割性。在执行时也不可间断，必须在管态下执行，并且常驻内存。</p><p>1.4 创建原语：是指创建一个新的进程，前者称为父进程，后者称为子进程建立进程控制块PCB。</p><p>1.5 DMA (Direct Memory Access)：直接内存访问，是一种完全由硬件执行I/O数据交换的工作方式。</p><p>1.6 通道：通道是一个特殊功能的处理器，它有自己的指令和程序，可以实现对外部设备的统一管理和外部设备与内存之间的数据传送。</p><p>1.7 SPOOLING (Simultaneous Peripheral Operations On-Line)：外部设备联机并行操作(虚拟设备技术)。它是关于慢速字符设备如何与计算机主机交换信息一种技术，通常称为“假脱机技术”。是多道程序设计系统中处理独占I/O设备的一种方法，能将独占设备转变为共享设备，可以提高设备利用率并缩短单个程序的响应时间。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>2.1 计算机系统的资源包括两大类：硬件资源和软件资源。</p><p>2.2 操作系统的两大发展方向：宏观应用、微观应用。</p><p>2.3 操作系统启动的引导方式：BIOS引导，UEFI引导。</p><p>2.4 操作系统的启动过程：BIOS自检、系统引导、启动内核、初始化系统。</p><p>2.5 操作系统管理程序运行的状态称为<font color="purple">管态</font>。<br>系统启动时，处理器的初始状态为管态。<br>当处理器处于管态时，可以执行全部指令。<br>当用户程序占用处理器时，应让处理器在<font color="purple">目态</font>下工作。</p><p>2.6 处理器的状态字（PSW）通常包含以下状态代码：(1)CPU的工作状态代码；(2)条件码；(3)中断屏蔽码。</p><p>2.7 所有的子系统都可以包括在<font color="purple">硬件（子）系统</font>和<font color="purple">软件（子）系统</font>。</p><p>2.8 系统软件包括：操作系统、编译系统、数据库。</p><p>2.9 硬件系统：中央处理器、存储系统、中断机制、I/O技术、时钟。</p><p>2.10 内存空间的最小分配单位为<font color="purple">块</font>，这样的块有时被称为一个物理页(Page)。</p><p>2.11 时钟中断处理程序的主要内容：(1)维护软件时钟；(2)处理器调度；(3)控制系统定时任务；(4)实时处理。</p><p>2.12 允许优先级较高的中断打断优先级较低的中断处理过程称为<font color="purple">中断嵌套</font>。</p><p>2.13 时钟分为<font color="purple">硬件时钟</font>和<font color="purple">软件时钟</font>。</p><p>2.14 <font color="purple">系统调用</font>是操作系统提供给编程人员的唯一接口。</p><p>2.15 进程从运行状态进入就绪状态的原因可能是：时间片用完。</p><p>2.16 七状态模型和五状态模型相比，增加了<font color="purple">就绪挂起</font>和<font color="purple">阻塞挂起</font>两个状态。</p><p>2.17 操作系统把所有的PCB用适当方式组织起来。一般的组织方式：线性方式、索引方式、链接方式。</p><p>2.18 同一个进程中的各个线程共享该进程的内存地址空间。</p><p>2.19 对进程在整个生命周期中各种状态之间的转换进行有效的控制通过<font color="purple">进程控制原语</font>来实现。</p><p>2.20 <font color="purple">线程</font>作为调度和分派的基本单位，<font color="purple">进程</font>作为资源拥有的基本单位。</p><p>2.21 线程的实现机制：用户级线程、内核级线程、混合方式。</p><p>2.22 CPU主要的两级调度：进程调度、作业调度。</p><p>2.23 <font color="purple">时间片轮转法</font>主要用于分时系统中的进程调度。</p><p>2.24 <font color="purple">保证调度算法</font>的目标是保证每个进程享用CPU的时间完全一样，即如果系统里一共有n个进程，则每个进程占用CPU的时间为<font color="purple">1/n</font>。</p><p>2.25 <font color="purple">彩票调度算法</font>是一种概率调度算法。</p><p>2.26 基于进程组的调度决策是非常有吸引力的，该方法通常称作<font color="purple">公平共享调度</font>。</p><p>2.27 BSD UNIX系统主要用于<font color="purple">分时交互</font>环境中。</p><p>2.28 Linux系统的调度方式基本上采用<font color="purple">抢占式优先级</font>方式。</p><p>2.29 Windows中的优先级被组织成两段：<font color="purple">实时</font>和<font color="purple">可变</font>。</p><p>2.30 任何情况下，都可以把系统看作是<font color="purple">多服务器排队</font>结构。</p><p>2.31 线程调度常用方法有：加载共享、组调度、专用处理器分配、动态调度。</p><p>2.32 为周期性任务解决多任务调度冲突的一个非常好的方法是<font color="purple">速率单调调度RMS</font>。</p><p>2.33 <font color="purple">优先级逆转</font>是在任何基于优先级的可抢占的调度方案中都能发生的一种现象，但是它与实时调度的上下文关联特别大。</p><p>2.34 <font color="purple">优先级继承协议</font>的基本思想是优先级较低的任务继承任何与它共享同一个资源的优先级较高的任务的优先级。</p><p>2.35 采用动态重定位的系统支持“程序浮动”。</p><p>2.36 存储管理的主要任务包括：内存的分配与回收、内存扩充、存储共享、存储保护。</p><p>2.37 在存储管理中，将绝对地址对应的存储空间称为<font color="purple">物理地址空间</font>，将逻辑地址对应的存储空间称为<font color="purple">逻辑地址空间</font>。</p><p>2.38 通过分区管理，内存真正成为了共享资源，提高了系统得到吞吐量和缩短了周转时间。</p><p>2.39 在可变区分存储管理方案中，解决碎片问题的一个有效办法是采用<font color="purple">紧缩技术</font>，通过移动内存中程序，把<font color="purple">所有空闲碎片</font>的合并成一个连续的大空闲区，置于内存的一端，把<font color="purple">所有程序占用区</font>的放在内存的另一端。</p><p>2.40 采用页式存储管理的主要目的是：提高内存的利用率。</p><p>2.41 大多数操作系统采用的进程页表是二级页表：即由页表页和页目录一起构成进程页表。</p><p>2.42 分页后，逻辑地址由两部分组成：虚拟页号，页内地址。</p><p>2.43 流式文件是有序字符的集合。</p><p>2.44 常用的文件物理结构：索引结构、链接结构、顺序结构。</p><p>2.45 文件按组织形式进行分类：普通文件、目录文件、特殊文件。<br>文件按文件用途进行分类：库函数文件、用户文件。</p><p>2.46 文件常用的存取方法：顺序存取、随机存取。</p><p>2.47 链式结构，有利于文件动态扩充，解决了存储的碎片问题，但不适合随机存取。</p><p>2.48 磁盘空间的分配与回收算法：位示图、空闲块表、空闲块链表。</p><p>2.49 把若干个逻辑记录合成一组，存入一个物理块的工作称为<font color="purple">记录的成组</font>。</p><p>2.50 记录的成组和分解技术是磁盘高速缓存的一种应用，虽然需要代价，但是具有提高<font color="purple">存储空间利用率</font>和减少<font color="purple">启动设备次数</font>的优点。</p><p>2.51 用来解决磁盘速度慢、出现故障的技术是<font color="purple">RAID技术</font>。</p><p>2.52 RAID2和RAID3以<font color="purple">位</font>或<font color="purple">字节</font>作为并行单位。</p><p>2.53 规定用户使用文件的权限的方法：<font color="purple">树形目录结构</font>、<font color="purple">存取控制表</font>。</p><p>2.54 UNIX的文件使用权限管理方案中，对文件存取权限的设置方法：<font color="purple">存取控制矩阵</font>和<font color="purple">二级存取控制</font>。</p><p>2.55 按设备的使用特性分类：（1）输入设备；（2）输出设备；（3）交互式设备；（4）存储设备。</p><p>2.56 设备驱动程序是操作系统底层中唯一知道各种输入输出设备的控制器细节以及其用途的部分。</p><p>2.57 设计I/O软件的一个最关键目标是设备独立性。</p><p>2.58 键盘、终端、打印机等以<font color="purple">字符</font>为单位组织好处理信息的设备。</p><p>2.59 I/O硬件由<font color="purple">物理设备</font>和<font color="purple">电子部件</font>两部分组成。</p><p>2.60 在典型的计算机系统硬件结构中，CPU与内存在最里层，通过总线与第二层的<font color="purple">适配器（接口）</font>部件相连，第三层是<font color="purple">各种外围设备控制器</font>，最外层是外围设备。</p><p>2.61 从功能上看，<font color="purple">设备独立层</font>是I/O软件的主要部分；<br>从代码量上看，<font color="purple">设备驱动层</font>是I/O软件的主要部分。</p><p>2.62 I/O设备管理中，可按照两种方式进行设备分配：<font color="purple">静态分配</font>和<font color="purple">动态分配</font>。</p><p>2.63 两种常用设备分配策略：先来先服务、高优先级优先。</p><p>2.64 设备分配表由<font color="purple">设备类表</font>和<font color="purple">设备表</font>组成。</p><p>2.65 常用的磁盘移臂调度算法：先来先服务调度算法、最短寻找时间优先调度算法、电梯调度算法、单向扫描调度算法。</p><p>2.66 缓冲出把多个缓冲区连接起来统一管理。</p><p>2.67 SPOOLING系统主要包括：输入程序模块、输出程序模块、作业调度程序。</p><p>2.68 Dijkstra把同步问题抽象成一种<font color="purple">生产者-消费者关系</font>。</p><p>2.69 对信号量的PV操作在程序流程上必定是成对出现，不能缺少，缺少了会<font color="purple">死锁</font>。</p><p>2.70 剥夺资源的常用方法：（1）还原算法，即恢复计算结果和状态；（2）建立检查点，用来恢复分配前的状态。</p><p>2.71 死锁产生的必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。</p><p>2.72 <font color="purple">哲学家就餐问题</font>是操作系统中关于进程同步与互斥的经典问题，也是涉及到<font color="purple">死锁</font>的关键问题。<br>在哲学家就餐问题中，为每只筷子设置一个信号量，一个哲学家通过在信号量上执行操作<font color="purple">P</font>抓起一只筷子，通过执行<font color="purple">V</font>操作放下一只筷子。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>3.1 操作系统的特性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 并发：在计算机系统中同时存在多个程序，宏观上，这些程序是在同时执行的；微观上，任何时刻只有一个程序在执行，即微观上这些程序在CPU上轮流执行。</span><br><span class="line">2. 共享：操作系统与多个用户的程序共同使用计算机系统中的资源。</span><br><span class="line">3. 虚拟性：虚拟性是一种管理技术，该技术把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物。</span><br><span class="line">4. 异步性：操作系统必须随时对不可预测的次序发生的事件进行响应。</span><br></pre></td></tr></table></figure></p><p>3.2 操作系统的主要功能：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理机管理功能：进程控制，进程同步，进程通信，调度。</span><br><span class="line">2. 存储器管理功能：内存分配，内存保护，地址映射，内存扩充。</span><br><span class="line">3. 设备管理功能：缓冲管理，设备分配，设备处理。</span><br><span class="line">4. 文件管理功能：文件存储空间的管理，目录管理，文件的读写管理和保护。</span><br><span class="line">5. 用户接口：命令接口，程序接口，图形接口。</span><br></pre></td></tr></table></figure></p><p>3.3 微内核结构及其基本原理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 微内核OS结构：能实现OS核心功能的小型内核。并非一个完整的OS，与OS的服务进程（如文件服务器、作业服务器等）共同构成OS。</span><br><span class="line">2. 基本原理：只有最基本的操作系统功能才能放在内核中。不是最基本的服务和应用程序在微内核之上构造，并在用户模式下执行。</span><br><span class="line">3. 微内核通常提供最小的进程和内存管理以及通信功能。微内核的主要功能是提供客户程序和运行在用户空间的各种服务之间进行通信的能力。通信以消息传递形式提供，一般采用客户/服务器模式。</span><br></pre></td></tr></table></figure></p><p>3.4 最常见的控制和状态寄存器：（了解）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 程序计数器（PC:Program Counter）：记录了将要取出的指令的地址。</span><br><span class="line">2. 指令寄存器（IR:Instruction Register）：包含了最近取出的指令。</span><br><span class="line">3. 程序状态字（PSW:Program Status Word）：记录了处理器的运行模式信息等。</span><br></pre></td></tr></table></figure></p><p>3.5 系统软件包括哪些软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统软件包括：系统软件、支撑软件、应用软件。</span><br><span class="line">系统软件：操作系统、编译系统。</span><br><span class="line">支撑软件：数据库、各种接口软件、软件开发工具等。</span><br><span class="line">应用软件：财务管理、人口普查等专用程序。</span><br></pre></td></tr></table></figure></p><p>3.6 简述指令的执行过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 每个取值周期先从存储器中读取一条指令。</span><br><span class="line">2. 在取指令完成后，根据指令类别将程序计数器的值变成下一条指令的地址，通常是自增1。</span><br><span class="line">3. 取到的指令被放在处理器的指令寄存器中。</span><br><span class="line">4. 处理器解释并执行命令。</span><br></pre></td></tr></table></figure></p><p>3.7 简述指令的分类<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 访问存储器指令：负责处理器和存储器之间的数据传送。</span><br><span class="line">2. I/O指令：负责处理器和I/O模块之间的数据传送和命令发送。</span><br><span class="line">3. 算术逻辑指令（数据处理指令）：用以执行有关数据的算术和逻辑操作。</span><br><span class="line">4. 控制转移指令：这种指令可以指定一个新的指令的执行起点。</span><br><span class="line">5. 处理器控制指令：这种指令用于修改处理器状态，改变处理器工作方式。</span><br></pre></td></tr></table></figure></p><p>3.8 现代计算机采用的多级存储体系包括哪几部分？简述各部分功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多级存储体系包括寄存器、主存储器、高速缓冲存储器、辅助存储器。</span><br><span class="line">2. 寄存器用来存放处理器的工作信息。</span><br><span class="line">3. 主存储器用来存放当前要执行的程序和数据。</span><br><span class="line">4. 高速缓冲存储器用来存放当前经常要使用的信息。</span><br><span class="line">5. 辅助存储器作为主存储器的扩展，用来存放大量的程序和数据。</span><br></pre></td></tr></table></figure></p><p>3.9 中断响应是什么？中断处理程序主要工作有哪些方面？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器每执行完一条指令后，中断装置立即检查有无中断事件发生。</span><br><span class="line">2. 若有中断事件发生，则暂停现行进程的执行，而让操作系统的中断处理程序占用处理器。中断处理程序主要工作如下：</span><br><span class="line">(1) 保护被中断进程的现场信息；(2)分析中断原因；(3)处理发生的中断事件。</span><br></pre></td></tr></table></figure></p><p>3.10 简述通道的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 当处理器执行到一条“启动外设”指令时，就按指令中给定的参数启动指定的设备。</span><br><span class="line">2. 设备启动后，对该外部设备的控制权转移到通道。</span><br><span class="line">3. 该外部设备与主存储器之间发生的信息传送，由通道控制。</span><br><span class="line">4. 该外部设备工作结束后，会产生形成一个“输入输出操作结束”的I/O中断事件。</span><br></pre></td></tr></table></figure></p><p>3.11 简述时钟的工作原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 硬件时钟的工作原理：电路中的晶体振荡器，每隔一定间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加1的工作。</span><br><span class="line">2. 软件时钟的工作原理：利用内存单元模拟时钟寄存器，采用一段程序来计算响应的脉冲数，对内存时钟寄存器进行加1或减1的工作。</span><br></pre></td></tr></table></figure></p><p>3.12 简述时钟的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在多道程序运行，时钟可以发现死循环，防止机时的浪费。</span><br><span class="line">2. 在分时系统中，用时钟实现时间片轮转运行。</span><br><span class="line">3. 在实时系统中，按要求的时间间隔输出信号控制设备。</span><br><span class="line">4. 定时唤醒外部事件。</span><br><span class="line">5. 记录用户和系统所需要的绝对事件，即年、月、日。</span><br></pre></td></tr></table></figure></p><p>3.13 简述系统调用的分离<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个操作系统的功能分为两大部分：一部分是系统自身所需要的，另一部分功能是作为服务提供给用户的，有关这部分功能可以从操作系统所提供的系统调用上体现出来。</span><br><span class="line">1. 进程控制类系统调用。</span><br><span class="line">2. 文件操作类系统调用。</span><br><span class="line">3. 进程通信类系统调用。</span><br><span class="line">4. 设备管理类系统调用。</span><br><span class="line">5. 信息维护类系统调用。</span><br></pre></td></tr></table></figure></p><p>3.14 在七状态模型中，什么是阻塞状态？什么是阻塞挂起状态？两个状态之间如何转换<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 阻塞状态：进程在内存并等待某事件的出现。</span><br><span class="line">2. 阻塞挂起状态：进程在外存并等待某事件的出现。</span><br><span class="line">3. 没有进程处于就绪状态或就绪进程要求更多内存资源时，就会把阻塞状态编程阻塞挂起状态。</span><br><span class="line">4. 当一个进程释放足够内存时，系统会把一个高优先级阻塞挂起进程激活，由阻塞挂起状态变成阻塞状态。</span><br></pre></td></tr></table></figure></p><p>3.15 进程具有哪些特性<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 并发性：一个进程可以同其他进程一道向前推进。</span><br><span class="line">2. 动态性：进程有其生命周期，且进程的状态是不断变化的。</span><br><span class="line">3. 独立性：一个进程是一个相对完整的资源分配单位。</span><br><span class="line">4. 交往性：一个进程在运行过程中可能会与其他进程发生直接的或间接的相互作用。</span><br><span class="line">5. 异步性：每个进程按照各自独立的、不可预知的速度向前推进。</span><br><span class="line">6. 结构性：一个进程由程序、数据和进程控制块三部分组成。</span><br></pre></td></tr></table></figure></p><p>3.16 线程与进程的关系<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 线程是进程中可独立执行的子任务。</span><br><span class="line">2. 一个进程中可以有一个活多个线程。</span><br><span class="line">3. 同一进程中的各线程共享分配给进程的主存空间。</span><br><span class="line">4. 进程是资源分配单位，线程是调度和执行单位。</span><br><span class="line">5. 一个进程内的线程共享分配给该进程的资源。</span><br></pre></td></tr></table></figure></p><p>3.17 进程调度的主要功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 保存现场：记录系统中所有进程得到执行状况。</span><br><span class="line">2. 挑选进程：根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它。</span><br><span class="line">3. 恢复现场：为选中的进程恢复现场信息。</span><br></pre></td></tr></table></figure></p><p>3.18 在选择调度策略时应该考虑什么因素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 设计目标</span><br><span class="line">2. 公平性</span><br><span class="line">3. 均衡性</span><br><span class="line">4. 统筹兼顾</span><br><span class="line">5. 优先级</span><br><span class="line">6. 开销</span><br></pre></td></tr></table></figure></p><p>3.19 进程最短剩余时间优先调度算法的基本思路和实现方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最短进程优先算法的抢占版本是最短剩余时间优先(SRTN)算法。</span><br><span class="line">使用这个算法，调度程序总是选择其剩余运行时间最短的那个进程运行。</span><br><span class="line">当一个新的进程到达时，其整个时间同当前进程的剩余时间作比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短进程获得良好的服务。</span><br></pre></td></tr></table></figure></p><p>3.20☆ 某单CPU系统有如下一批处于就绪状态的进程。<br>(1) 给出<font color="purple">FCFS(先来先服务)</font>和<font color="purple">SJF(最短作业优先)</font>算法个进程的开始事件、完成时间、周转时间。<br>(2) 计算在各算法下的平均周转时间</p><p><table>    <th rowspan="2">进程进入就绪队列的先后顺序</th> <th rowspan="2">运行时间</th> <th colspan="3">FCFS</th> <th colspan="3">SJF</th>    <tr>        <td>开始时间</td> <td>完成时间</td> <td>周转时间</td> <td>开始时间</td> <td>完成时间</td> <td>周转时间</td>    </tr>    <tr>        <td>1</td> <td>10</td> <td class="td3_20">0</td> <td class="td3_20">10</td> <td class="td3_20">10</td> <td class="td3_20">9</td> <td class="td3_20">10</td> <td class="td3_20">19</td>    </tr>    <tr>        <td>2</td> <td>1</td> <td class="td3_20">10</td> <td class="td3_20">1</td> <td class="td3_20">11</td> <td class="td3_20">0</td> <td class="td3_20">1</td> <td class="td3_20">1</td>    </tr>    <tr>        <td>3</td> <td>2</td> <td class="td3_20">11</td> <td class="td3_20">2</td> <td class="td3_20">13</td> <td class="td3_20">2</td> <td class="td3_20">2</td> <td class="td3_20">4</td>    </tr>    <tr>        <td>4</td> <td>1</td> <td class="td3_20">13</td> <td class="td3_20">1</td> <td class="td3_20">14</td> <td class="td3_20">1</td> <td class="td3_20">1</td> <td class="td3_20">2</td>    </tr>    <tr>        <td>5</td> <td>5</td> <td class="td3_20">14</td> <td class="td3_20">5</td> <td class="td3_20">19</td> <td class="td3_20">4</td> <td class="td3_20">5</td> <td class="td3_20">9</td>    </tr></table><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平均周转时间：</span><br><span class="line">FCFS：(10+11+13+14+19)/5=13.4</span><br><span class="line">SJF：(19+1+4+2+9)/5=7</span><br></pre></td></tr></table></figure></p><p>3.21 加载共享的缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中心队列占据了必须互斥访问的存储器区域，被抢占的线程可能不在同一个处理器上恢复执行。如果一个程序的线程间需要高度的合作，所涉及的进程切换就会严重影响性能。</span><br></pre></td></tr></table></figure></p><p>3.22 存储管理中交换技术的实现原理及主要作用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交换技术又称对换技术。</span><br><span class="line">进程从内存移到磁盘，并再移回内存称为交换。</span><br><span class="line">交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。交换技术的目的是尽可能达到“足够快地交换进程，以使当处理器调度程序想重新调度处理器时，总有进程在内存中处于就绪（准备执行）状态”的理想状态，从而提高内存利用率。</span><br></pre></td></tr></table></figure></p><p>3.23 虚拟页式存储管理的优缺点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：由于它不要求进程的程序段和数据在内存中连续存放，从而有效地解决了碎片问题。这既提高了内存的利用率，又有利于组织多道程序执行。</span><br><span class="line">缺点：存在页面空间的浪费问题。这是由于各种程序代码的长度是各不相同的，但页面的大小是固定的，所以在每个程序的最后一页内总有一部分空间得不到利用。如果页面较大，则由此引起的存储空间的损失仍然较大。</span><br></pre></td></tr></table></figure></p><p>3.24 文件系统的功能<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 统一管理文件的存储空间，实施存储空间的分配与回收。</span><br><span class="line">2. 实现文件从名字到外存地址空间的映射，即实现文件的按名存取。</span><br><span class="line">3. 实现文件信息的共享，并提供文件的保护措施。</span><br><span class="line">4. 向用户提供一个方便使用的接口。</span><br><span class="line">5. 系统维护及向用户提供有关信息。</span><br><span class="line">6. 保持文件系统的执行效率，文件系统在操作系统中占的比例最大。</span><br><span class="line">7. 提供I/O的统一接口。</span><br></pre></td></tr></table></figure></p><p>3.25 什么是逻辑文件？什么是物理文件？简述逻辑文件的几种形式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 用户组织的文件称为逻辑文件，存放在存储介质上的文件称为物理文件。</span><br><span class="line">2. 流式文件是由一串顺序的字符流组成的，记录式文件是由若干逻辑记录组成的。</span><br></pre></td></tr></table></figure></p><p>3.26☆ 某UNIX操作系统采用i结点管理文件的存储空间，假设磁盘大小为2048字节，每个地址占64位（8个字节），i结点包括13个地址项，其中10个地址用来存直接地址，一个地址项存一次间接地址，一个地址项存二次间接地址，一个地址项存三次间接地址。问系统能管理的单个文件最大长度是多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">磁盘块大小=2048字节=2×1024字节=2×1KB=2KB</span><br><span class="line">10个直接地址表示的文件大小=10×2KB=20KB                  直接地址指向磁盘块</span><br><span class="line">每个地址占8字节</span><br><span class="line">每个盘块中存放2^8=256个盘块号</span><br><span class="line">1个一次间接地址存放文件大小=1×256×2KB=512KB             间接地址指向直接地址</span><br><span class="line">1个二次间接地址存放文件大小=1×256×256×2KB=128MB         二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">1个三次间接地址存放文件大小=1×256×256×256×2KB=32GB      三级间接-&gt;二级间接-&gt;一级间接-&gt;磁盘块</span><br><span class="line">所以一个文件的最大长度=20KB+512KB+128MB+32GB</span><br></pre></td></tr></table></figure></p><p>3.27☆ 假定某系统中，磁带的记录密度为每英寸1200个字符，每个逻辑记录长为200个字符，块与块之间的间隙为0.5英寸。问，为了使磁带空间利用率达到70%，采用记录成组操作时的块因子应为多少？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设块因子为x。</span><br><span class="line">每条记录所占磁带空间=200/1200=1/6英寸</span><br><span class="line">(x*1/6)/(x*1/6+0.5)=0.7</span><br><span class="line">解得：x=7</span><br><span class="line">成组操作时块因子是7。</span><br></pre></td></tr></table></figure></p><p>3.28 简述UNIX的目录文件的存取权限及其含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读：允许读该目录。</span><br><span class="line">写：允许修改目录内容。</span><br><span class="line">执行：允许搜索该目录。</span><br></pre></td></tr></table></figure></p><p>3.29 通道有哪三种类型？简述三种通道的优缺点。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 选择通道</span><br><span class="line">优点：以数据块为单位进行传输，传输效率高。</span><br><span class="line">缺点：通道利用率低。</span><br><span class="line">2. 数组多路通道</span><br><span class="line">优点：以数据块为单位进行传输，传输率高；又具有多路并行操作的能力，通道利用率高。</span><br><span class="line">缺点：控制复杂。</span><br><span class="line">3. 字节多路通道</span><br><span class="line">优点：多路并行操作能力与数组多路通道相同。</span><br><span class="line">缺点：以字节为单位交替进行的，个设备轮流占用一个很短的时间片，效率低。</span><br></pre></td></tr></table></figure></p><p>3.30☆ 假设对磁盘的请求为柱面号95、180、35、120、10、122、64、68，磁头的初始位置为30，求在下列移臂调度算法下的服务顺序和移动臂需要移动的距离。<br>（1）最短寻找时间优先调度算法。<br>（2）移动臂由外向里移动（向柱面号增大的方向）的电梯调度算法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 最短寻找时间优先调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;10-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180</span><br><span class="line">移动臂需要移动的距离=(35-30)+(35-10)+(64-10)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)=200(柱面)</span><br><span class="line">(2) 移动臂由外向里移动的电梯调度算法</span><br><span class="line">服务顺序：30-&gt;35-&gt;64-&gt;68-&gt;95-&gt;120-&gt;122-&gt;180-&gt;10</span><br><span class="line">移动臂需要移动的距离=(35-30)+(64-35)+(68-64)+(95-68)+(120-95)+(122-120)+(180-122)+(180-10)=320(柱面)</span><br></pre></td></tr></table></figure><br>3.31 磁盘驱动调度包括什么调度？各涉及什么时间？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">磁盘驱动调度包括移臂调度和旋转调度。</span><br><span class="line">分别涉及寻找时间和延迟时间。</span><br></pre></td></tr></table></figure></p><p>3.32 简述关于磁盘的电梯调度算法与单向扫描调度算法的含义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 电梯调度算法是从移动臂当前位置开始沿移动方向去选择最近的柱面请求，当移臂方向向上无请求时，就改变移臂的移动方向再做类似处理。</span><br><span class="line">2. 单向扫描调度算法总是从0号柱面开始向里扫描，为请求的柱面提供服务，到达最后一个柱面再把读写头快速返回0号柱面（返回过程不做服务），返回后可再进行扫描和服务。</span><br></pre></td></tr></table></figure></p><p>3.33 磁盘驱动调度和调度原理<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘执行一次输入输出所需时间是：寻找时间、延迟时间、传送时间。</span><br><span class="line">采用一定得到调度策略以决定各等待访问者的执行次序，称为驱动调度。</span><br><span class="line">磁盘驱动调度就需要优化寻找时间和延迟时间，就是移臂调度和旋转调度。</span><br></pre></td></tr></table></figure></p><p>3.34 什么是死锁？产生死锁的额两个主要原因？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">死锁是指在多道程序系统中的一种现象，一组进程中的每个进程均无限期地等待被该进程中的另一个进程所占用且永远不会释放的资源。</span><br><span class="line">产生死锁的原因：</span><br><span class="line">（1）竞争资源，系统资源在分配时出现失误，进程间对资源的相互争夺而造成僵局。</span><br><span class="line">（2）多道程序运行时，进程推进顺序不合理。</span><br></pre></td></tr></table></figure></p><style>    .td3_20{        color:midnightblue;    }</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/OS/">OS</category>
      
      
      <comments>https://pearlchocolatezy.com/2024/09/26/LearnOS/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
