<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Mon, 02 Jun 2025 12:53:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>04747-Java（三）——流程控制语句</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-03/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-03/</guid>
      <pubDate>Mon, 02 Jun 2025 06:53:08 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;简述Java中异常的分类及其概念：&lt;br&gt;Java中异常可分为三类,分别为：受检异常、运行时异常、错误。&lt;br&gt;受检异常是程序执行期间发生的严重事件的后果。&lt;br&gt;运行时异常通常是程序中逻辑错误的结果。&lt;br&gt;错误是指发生了不正确的情况,这些情况都比较严重,一般</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>简述Java中异常的分类及其概念：<br>Java中异常可分为三类,分别为：受检异常、运行时异常、错误。<br>受检异常是程序执行期间发生的严重事件的后果。<br>运行时异常通常是程序中逻辑错误的结果。<br>错误是指发生了不正确的情况,这些情况都比较严重,一般程序很难处理。</li><li>如果程序中有package语句，那么该语句一定是源文件中的<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">第一条非注释语句</i>。</li><li>Java中，通常用<i id="answer3_1" class="answer" onclick="showOrHide('3_1')"> classpath （环境变量）</i>指定搜寻包的路径。</li><li>简述package语句和import语句的区别：<br>(1)package语句为包语句,每个文件最多只有一个,且必须放在文件开始的地方(2分)。<br>(2)import语句为引入语句,可以没有,也可以有多个,如果有,必须放在所有类定义的前面(2分)</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（二）——数据和表达式</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-02/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-02/</guid>
      <pubDate>Mon, 02 Jun 2025 06:52:59 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;包的命名要求：层次关系以点分割；通常用小写字母。&lt;/li&gt;
&lt;li&gt;Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）&lt;/li&gt;
&lt;li&gt;关键字的作用：&lt;br&gt;f</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>包的命名要求：层次关系以点分割；通常用小写字母。</li><li>Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）</li><li>关键字的作用：<br>final：用于声明常量变量。<br>static：用于声明静态变量或方法，表明该成员属于类本身不属于实例；不能用于声明常量变量，但<code>static final</code>结合使用可以定义常量变量。<br>protected：一种访问修饰符，用于控制类成员的访问权限，允许同一个包内或通过继承的子类访问该成员。<br>super：用于引用父类的成员。<br>class：用于定义类。<br>long：用于声明长整型变量。<br>new：用于创建新对象。</li><li>Java中的保留关键字：<br> 基本类型关键字<pre><code> byte short int long float double boolean char</code></pre> 控制语句关键字<pre><code> if else switch case default while do for break continue return</code></pre> 类、对象和接口定义关键字<pre><code> class interface extends implements this super new instanceof</code></pre> 包和导入关键字<pre><code> package import</code></pre> 访问控制关键字<pre><code> public protected private</code></pre> 异常处理关键字<pre><code> try catch finally throw throws</code></pre> 其他关键字<pre><code> static final abstract synchronized volatile transient native strictfp assert</code></pre> <a href="https://blog.csdn.net/weixin_48958956/article/details/140869156">Java关键字简介</a></li><li>简述包的概念及其命名要求：<br>（1）概念：包是类的容器,包的设计人员利用包来划分名字空间,以避免类名冲突。<br>（2）命名要求：包的名字有层次关系,各层之间以点分隔。包层次必须与Java开发系统的文件系统结构相同。通常包名中全部用小写字母。</li><li>Java程序的结构可以包含哪些内容：<br>一个Java程序的结构可以包含以下5方面的内容:<br>（1）package语句:包语句,每个文件最多只有一个,且必须放在文件开始的地方。<br>（2）import语句:引入语句,可以没有,也可以有多个,如果有 import语句,必须放在所有类定义的前面。<br>（3）具有 public权限的类定义:每个文件中最多有一个。<br>（4）类定义:每个文件中包含的非 public权限的类定义的个数没有限制。<br>（5）接口定义:每个文件中包含的接口定义个数没有限制。</li><li>变量取值范围<br>byte：-128~127<br>int：-2,147,483,648到2,147,483,647（$-2^(31)$~$2^(31)-1$）<br>long：-9,223,372,036,854,775,808（$-2^(63)$）到9,223,372,036,854,775,807（$2^(63)-1$）（‌字面量表示‌：若数值超出int范围（如大于2147483647），需在末尾添加L或l后缀（推荐大写L以避免与数字1混淆），例：long a=9876543210编译错误）</li><li>变量占用内存<br>byte：8位<br>short：16位<br>int：32位<br>long：64位</li><li>运算符优先级：括号 &gt; 基本运算 &gt; 移位 &gt; 大小对比 &gt; 逻辑&amp;&amp; &gt; 逻辑|| &gt; 三元运算</li><li><code>&gt;&gt;</code>是算术右移操作符，用于将二进制值向右移动指定位数，同时保留符号位。<br>例：求解<code>85&gt;&gt;1</code>：85转为二进制为（短除法）01010101，右移一位为00101010，再转为十进制（乘法）为42。<br>简单计算：右移一位相当于除以2，且向下取整。</li><li>表达式由<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">运算符</i>和<i id="answer11_2" class="answer" onclick="showOrHide('11_2')">操作数</i>组成。</li><li>Java可以声明变量的地方及其区别：<br>声明变量的地方有两处,一处是在方法内,另一处是在类定义内。方法内定义的变量称为自动变量,也称为局部变量、临时变量或栈变量。类中定义的变量就是类的成员变量。</li><li><i id="answer13_1" class="answer" onclick="showOrHide('13_1')">null</i>表示引用不指向任何对象。</li><li>Java中数据类型转换的分类及其适用情况：<br>Java中的数据类型转换分为自动转换和强制转换两类。转换的一般原则是位数少的类型转换为位数多的类型,这称为自动类型转换。当位数多的类型向位数少的类型进行转换时,需要在程序中明确指明,这种转换称为强制类型转换。</li><li>基本数据类型什么时候有自己的内存空间：<br>基本数据类型的变量在声明之后,系统会自动在内存中分配相应的存储空间,即声明后即有自己的内存空间。</li><li>简述二元逻辑论中“短路”操作功能：<br>进行二元逻辑运算时,先计算运算符左侧表达式的值(2分)<br>如果使用该值能得到整个表达式的值,则跳过运算符右侧表达式的计算(1分),<br>否则计算运算符右侧表达式,并得到整个表达式的值(1分)。</li><li>Java中的基本数据类型byte、char、float、long和short在参与表达式计算时，能够进行自动类型变换的类型顺序依次是什么：依次是byte、short、char、long、float。</li><li><code>&amp;</code>按位与运算的结果是按位“皆1则1”。</li><li>Java逻辑与和逻辑或运算符有一个特殊的功能，当左侧操作数能决定表达式的值时，则跳过右侧操作数的运算。这个功能是<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">短路操作</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（三）——结构化方法</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-3/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-3/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[结构化方法] --&gt; A1[结构化需求分析]
    A --&gt; A2[结构化设计]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[结构化方法] --> A1[结构化需求分析]    A --> A2[结构化设计]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><h3 id="3-1-结构化需求分析"><a href="#3-1-结构化需求分析" class="headerlink" title="3.1 结构化需求分析"></a>3.1 结构化需求分析</h3><ol><li>可以用于描述加工的是：<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">结构化自然语言</i>。</li><li>可以用于表示数据的静态结构的是：<i id="answer3_2" class="answer" onclick="showOrHide('3_2')">数据存储</i>。</li><li>结构化分析方法用于表达功能模型的工具：<i id="answer3_3_1" class="answer" onclick="showOrHide('3_3_1')">DFD图（数据流图、数据流程图）</i>。一般包含<i id="answer3_3_2" class="answer" onclick="showOrHide('3_3_2')">数据流</i>、<i id="answer3_3_3" class="answer" onclick="showOrHide('3_3_3')">数据存储</i>、<i id="answer3_3_4" class="answer" onclick="showOrHide('3_3_4')">加工</i>、<i id="answer3_3_5" class="answer" onclick="showOrHide('3_3_5')">数据源</i>、<i id="answer3_3_6" class="answer" onclick="showOrHide('3_3_6')">数据潭</i>等。</li><li>数据字典中定于数据结构的符号：m…n表示<i id="answer3_4_1" class="answer" onclick="showOrHide('3_4_1')">子界</i>，<code>&#123;&#125;</code>表示<i id="answer3_4_2" class="answer" onclick="showOrHide('3_4_2')">重复</i>。</li><li>结构化分析方法建模步骤：建立系统 -&gt; 建立层次 -&gt; 定义字典 -&gt; 加工。<br>（1）建立系统环境图,确定系统语境；（1分）<br>（2）自顶向下，逐步求精，建立系统的层次数据流图；（2分）<br>（3）定义数据字典；（1分）<br>（4）描述加工。（1分）</li><li>数据流图中，椭圆表示加工，双横线表示数据存储，方框表示数据源。</li><li>在结构化分析方法中，可采用<i id="answer3_7_1" class="answer" onclick="showOrHide('3_7_1')">结构化自然语言</i>、<i id="answer3_7_2" class="answer" onclick="showOrHide('3_7_2')">判定表</i>、<i id="answer3_7_3" class="answer" onclick="showOrHide('3_7_3')">判定树</i>描述加工。</li><li>结构化分析方法中，数据的变换单位是<i id="answer3_8" class="answer" onclick="showOrHide('3_8')">加工</i>。</li><li>事务流程图中，一个事务可以被另一个事务吸食，称为<i id="answer3_9" class="answer" onclick="showOrHide('3_9')">事务吸收</i>。</li><li>数据字典中，所有客体均可用<i id="answer3_10_1" class="answer" onclick="showOrHide('3_10_1')">顺序结构</i>、<i id="answer3_10_2" class="answer" onclick="showOrHide('3_10_2')">选择结构</i>、<i id="answer3_10_3" class="answer" onclick="showOrHide('3_10_3')">重复结构</i>三种基本结构表示。</li><li>结构化方法中，软件中具有特定标识的独立成分是<i id="answer3_11" class="answer" onclick="showOrHide('3_11')">模块</i>。</li><li>结构化方法包括：<i id="answer3_12_1" class="answer" onclick="showOrHide('3_12_1')">结构化分析方法</i>、<i id="answer3_12_2" class="answer" onclick="showOrHide('3_12_2')">结构化设计方法</i>、<i id="answer3_12_3" class="answer" onclick="showOrHide('3_12_3')">结构化程序设计方法</i>。</li></ol><h3 id="3-2-结构化设计"><a href="#3-2-结构化设计" class="headerlink" title="3.2 结构化设计"></a>3.2 结构化设计</h3><ol><li>耦合：不同模块间相互依赖程度。<br>耦合程度：内容耦合 &gt; 公共耦合 &gt; 控制耦合 &gt; 数据耦合<br>数据耦合：通过传递参数调用模块。<br>控制耦合：通过传递开关量（只有两种状态的离散信号）调用模块。<br>公共耦合：一组模块共同引用一个全局数据项。<br>内容耦合：一个模块直接操作另一个模块的数据，或一个模块不通过正常入口转入另一个模块。</li><li>内聚：一个模块内部各成分之间相互关联程度。<br>常见内聚类型：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。<br>内聚程度：功能内聚 &gt; 过程内聚 &gt; 逻辑内聚<br>通信内聚：一个模块内所有成分都生成或操作同一数据集。<br>偶然内聚：一个模块的各成分之间基本不存在任何关系。</li><li>提高模块独立性的原则：高内聚低耦合</li><li>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/06/01/02333-3/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程度高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </li><li>宽度：同一层次上模块总数的最大值。</li><li>深度：粗略标志一个系统的规模和复杂程度。</li><li>作用域：模块内受一个判定所“影响”的所有模块的集合。（背）</li><li>控制域：模块本身或所有直接或间接“从属”于它的模块的集合。（背）</li><li>作用域和控制域的启发式原则：尽力使模块的作用域在其控制域之内。</li><li>逐步求精：每一步是对上一步结果的细化。（使用N-S盒图）</li><li>详细设计工具：PFD图（程序流程图/框图）、N-S图（盒图）、PAD图（问题分析图）、PDL（类程序设计语言）。<br>N-S图：盒图，支持自顶向下逐步求精，严格控制一个处理到另一个处理的转移。<br>PAD图：问题分析图，用二维树结构表示程序控制流，面向高级语言。<br><strong>简述PDL特点：</strong><br>（1）PDL也称为伪码,它是一种用正文形式表示数据和处理过程的设计工具。<br>（2）PDL借用某种结构化程序设计语言(如Pascal或)的关键字作为语法框架,用于定义控制结构和数据结构。<br>（3）PDL通常使用某种自然语言(如汉语或英语)的词汇,灵活自由地表示实际的操作和判定条件。<br>（4）PDL可以作为注释工具直接插在源程序中间。</li><li>程序流程图优缺点<br>（1）优点：对控制流程描绘很直观，便于初学者掌握。<br>（2）缺点：不是一种逐步求精的工具；控制流不受约束，可能破坏好的系统结构；不易表示数据结构。</li><li>结构化程序设计：顺序结构、选择结构、循环结构。<br>选择结构的表达式：IF-THEN-ELSE。</li><li>针对具有变换型流图和事务型DFD的总体设计步骤：<br>（1）在软件总体设计中，通常以变换设计为主，事务设计为辅进行结构设计；（1分）<br>（2）首先利用变换设计，把软件系统分为输入，中心变换和输出3个部分，设计上层模块；（1分）<br>（3）然后根据各部分数据流图的结构特点，适当地利用变换设计和事务设计进行细化，得到初始的模块结构图；（1分）<br>（4）再按照“高内聚低耦合”的原则，对初始的模块结构图进行精化，得到最终的模块结构图。（2分）</li><li>变换设计的基本步骤：<br>（1）设计准备，复审并精化系统模块；（1分）<br>（2）确定输入、变换、输出这三部分之间的边界；（1分）<br>（3）设计系统模块结构图的顶层和第一层；（1分）<br>（4）自顶向下，逐步求精。（2分）</li><li>结构化方法的不同阶段：可行性研究阶段、需求分析阶段、总体设计阶段、详细设计阶段、编码实现阶段、测试阶段、维护阶段。<br>总体设计阶段使用HIPO图，由IPO图和H图（层次图）组成。<br>层次图：适合自顶向下的软件设计过程。<br><strong>总体设计阶段内的三个阶段：</strong> <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</li><li>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。（1分）<br>（2）功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。（1分）<br>（3）接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。（1分）<br>（4）数据库设计：设计核心数据的逻辑结构。（1分）<br>（5）测试需求等。（1分）</li><li>待建系统的数据流图两种类型：变换型数据流图、事务型数据流图。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（二）——软件需求与软件需求规约</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-2/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-2/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[软件需求] --&gt; A1[需求概念]
    A --&gt; A2[需求获取]
    A --&gt; A3[需求规约]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[软件需求] --> A1[需求概念]    A --> A2[需求获取]    A --> A3[需求规约]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><ol><li>软件需求分为：功能需求（主体），非功能需求。</li><li>接口需求的分类：用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求。</li><li>单个需求必须具有的基本性质：必要的、无歧义的、可测的、可测量的。</li><li>需求分析的三大挑战：问题空间理解，人与人之间的通信，需求的变化性。</li><li>初始发现需求的常用技术：自悟，交谈（提问/回答），观察（可能引起抵触），小组会，提炼（已有文档）。</li><li>验证需求是否正确的技术：自悟、提炼。</li><li>需求规约的定义：需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，它表达了一个软件产品/系统的概念模型。</li><li>软件需求规约的性质：重要性，稳定性，可修改性，完整性（基本），一致性。</li><li>需求规约的三种形式：<br>（1）非形式化的需求规约：基于自然语言来编制需求规约。<br>（2）半形式化的需求规约：以半形式化符号体系（术语表）等表达需求规约。<br>（3）形式化规约：基于良构数学概念符号体系来编制需求规约。</li><li>需求规约在项目开发中的基本作用：<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现；（1分）<br>（2）对于项目的其余大多数工作，需求规约是一个管理控制点；（1分）<br>（3）对于产品/系统的设计，需求规约是一个正式的、受控的起始点；（1分）<br>（4）是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档：初始测试计划和用户系统操作描述。（2分）</li><li>需求规约与项目需求有哪些不同？<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，即关注产品需求，（1分）回答“交付给客户的产品/系统是什么了（1分）。<br>（2）项目需求是客户和开发者之间有关技术合同-产品/ 系统需求的理解。（1分）应记录在工作陈述中或其他某一项目文档中,即关注项目工作于管理，（1分）回答“开发组要做的是什么事。（1分）</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>回杭的日子5</title>
      <link>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/</link>
      <guid>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/</guid>
      <pubDate>Thu, 29 May 2025 14:43:27 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;</description>
        
      
      
      
      <content:encoded><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1818978932&auto=1&height=66"></iframe><br></p><p>没有抢到CP31的票，急匆匆制定的PlanB就成了治愈系的绿色漫游。<br>尽管和很多年轻人一样调侃着抢票的难度，也从容地享受着失败者的自嗨，遗憾的心情确实是伴随着全程的，好在杭州的每一株草木都带给我治愈的力量。</p><p>微雨阴晴，早上被布谷鸟的叫声唤醒，走进林木深处就没有了初夏燥热的阳光，正是游玩西湖风景区最好的时候。<br>第一站是虎跑公园，入口的屋檐上长满了垂直向上的枝草，似乎能想象出有如宫崎骏动画中、植物从角角落落不起眼的地方生长出来的样子，没有为了干净的屋檐而破坏，我被生命之美所感动，也被保护着这片风景的人所感动。进门所见的水池、水中木、浮萍、鲤鱼仿佛构成了一幅精心设计的写意画，肆意生长的杂草也争当画中的主角，鱼儿在浮萍之间悠游，好一副动态景观。沿着溪水前行，没有着急看到下一幅画的迫切，每一眼都希望可以再久一点。</p><p>这里是我的灵魂故乡。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E6%97%A5%E8%AE%B0/">日记</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/%E6%9D%AD%E5%B7%9E/">杭州</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/29/BackToHangzhou5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（一）——概述</title>
      <link>https://pearlchocolatezy.com/2025/05/29/04747-01/</link>
      <guid>https://pearlchocolatezy.com/2025/05/29/04747-01/</guid>
      <pubDate>Thu, 29 May 2025 14:31:39 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;简述Java与平台无关原理：&lt;br&gt;java与平台无关的关键是JVM,JVM是一台虚拟计算机,不同的操作系统有不同的虚拟机,它类似于一个小巧而高效的CPU。Java编译器将Java程序编译成JVM(虚拟机)能够识别的二进制代码,这种代码称为字节码,字节码就是虚拟</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>简述Java与平台无关原理：<br>java与平台无关的关键是JVM,JVM是一台虚拟计算机,不同的操作系统有不同的虚拟机,它类似于一个小巧而高效的CPU。Java编译器将Java程序编译成JVM(虚拟机)能够识别的二进制代码,这种代码称为字节码,字节码就是虚拟机的机器指令,它与平台无关,有统一的格式,不依赖于具体的硬件环境,只运行在JVM上。在任何安装Java运行时环境的系统上,都可以执行这些代码。</li><li>Java程序分为：Java应用程序，Java小程序。</li><li>Java实行<>语言定义阶段</>、<>字节码检查阶段</>、<>程序执行阶段</>三级代码安全检查机制。</li><li>Windows操作系统霞安装JDK并设置缓解变量后，测试命令：<>javac</>。该命令还能将java程序编译成字节码。</li><li>JDK的常用工具<br>bin目录下主要的开发工具：javac, java, jdb, javadoc。<br>javac.exe是java的编译器。<br>java.exe是java的解释器。<br>JDK是java开发工具集。<br>JRE是java运行时环境。<br>JVM是java虚拟机。</li><li>Java集成环境（IDE）工具：编辑器，编译器，图形用户界面。</li><li>Java程序编译过程中，源代码文件（.java）被编译器编译后，会生成字节码文件（类文件.class）。字节码可以被Java虚拟机（JVM）解释执行。（两个阶段：编译，解释执行）<br>Java程序生成的字节码文件与平台无关。<br>Java解释执行Java字节码。（不是源程序）<br>Java没有指针。</li><li>Java运行的是<>与机器无关</>的二进制格式的类文件。</li><li>Java源文件中最多只能有一个public类，其他类的个数不限。</li><li>面向对象的方法学：面向对象的分析，面向对象的设计，面向对象的程序设计（OOP）。</li><li>Java语言的特性：无用内存自动回收机制，面向对象，多线程，JVM。<br>C语言的特性：全局变量，指针，预处理器，结构和类型定义。</li><li>编译java文件的命令：javac Test.java</li><li>面向对象语言机制：封装，继承，多态。<br>面向过程语言机制：方法调用，模块，结构化。</li><li>英文名词：<br>API：应用程序编程接口<br>OOP：面向对象程序设计<br>constructor：JDK文档中的构造方法</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/29/04747-01/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：91-100解析</title>
      <link>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/</link>
      <guid>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/</guid>
      <pubDate>Fri, 23 May 2025 14:09:28 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;91-不同路径（多维动态规划-不同路径）&quot;&gt;&lt;a href=&quot;#91-不同路径（多维动态规划-不同路径）&quot; class=&quot;headerlink&quot; title=&quot;91. 不同路径（多维动态规划/不同路径）&quot;&gt;&lt;/a&gt;91. 不同路径（多维动态规划/不同路径）&lt;/h3</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="91-不同路径（多维动态规划-不同路径）"><a href="#91-不同路径（多维动态规划-不同路径）" class="headerlink" title="91. 不同路径（多维动态规划/不同路径）"></a>91. 不同路径（多维动态规划/不同路径）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<br>假设：1 &lt;= m, n &lt;= 100；题目数据保证答案小于等于 2 * $(10)^9$。<br>示例：输入：m = 3, n = 7；输出：28。</p><blockquote><p>【分析】</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">UniquePaths</span>(<span class="params"><span class="built_in">int</span> m, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/23/LeetCode100-91-100/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：81-90解析</title>
      <link>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/</link>
      <guid>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/</guid>
      <pubDate>Fri, 23 May 2025 14:08:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;81-爬楼梯（动态规划-70）&quot;&gt;&lt;a href=&quot;#81-爬楼梯（动态规划-70）&quot; class=&quot;headerlink&quot; title=&quot;81. 爬楼梯（动态规划/70）&quot;&gt;&lt;/a&gt;81. 爬楼梯（动态规划/70）&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="81-爬楼梯（动态规划-70）"><a href="#81-爬楼梯（动态规划-70）" class="headerlink" title="81. 爬楼梯（动态规划/70）"></a>81. 爬楼梯（动态规划/70）</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>假设：1 &lt;= n &lt;= 45。<br>示例：输入：n = 3；输出：3。(1,1,1; 1,2; 2,1)</p><blockquote><p>【分析】<br>到达第n阶的方法数等于达到第n-1阶和到达第n-2阶的方法数之和。<br>要到达第 n 阶，你可以选择从第 n−1 阶走一步上来，或者从第 n−2 阶走两步上来（从n-2阶走一步再走一步的情况，走一步时和第一种方法重了）。因此，到达第 n 阶的总方法数是到达第 n−1 阶和第 n−2 阶的方法数之和。<br>这种方法确保了每个子问题只被解决一次，并且其解被存储起来供后续使用，从而提高了算法的效率。<br>res[n]=res[n-1]+res[n-2]</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ClimbStairs</span>(<span class="params"><span class="built_in">int</span> n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个变量的值随着n的变大动态地变大</span></span><br><span class="line"><span class="built_in">int</span> resN_2=<span class="number">1</span>;<span class="comment">//初始化可指代n=1时的result</span></span><br><span class="line"><span class="built_in">int</span> resN_1=<span class="number">2</span>;<span class="comment">//初始化可指代n=2时的result</span></span><br><span class="line"><span class="built_in">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">result=resN_1+resN_2;<span class="comment">//当下的i的result是由n-1时的result和n-2时的result组成</span></span><br><span class="line">resN_2=resN_1;<span class="comment">//res[n-1]对于下一轮就是res[n-2]</span></span><br><span class="line">resN_1=result;<span class="comment">//当前res对于下一轮就是res[n-1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/23/LeetCode100-81-90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（一）——绪论</title>
      <link>https://pearlchocolatezy.com/2025/05/20/02333-1/</link>
      <guid>https://pearlchocolatezy.com/2025/05/20/02333-1/</guid>
      <pubDate>Tue, 20 May 2025 13:59:22 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[绪论] --&gt; A1[软件工程的提出与发展]
    A --&gt; A2[软件开发的本质]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-s</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[绪论] --> A1[软件工程的提出与发展]    A --> A2[软件开发的本质]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><ol><li>目的：解决软件危机。</li><li>成果：<br>20世纪60年代-80年代初：瀑布模型，C语言，Pascal语言，Jackson方法，结构化方法，支持工具。<br>20世纪80年代-：软件生存周期过程，辅助工程CASE，面向对象。</li><li>软件危机的表现：生产效率低、质量低，缺乏原理、原则、方法、管理，超预算，时间拖延，无法满足需求，可维护性查，可靠性差。（背）</li><li>计算机软件的概念：（1）计算机软件一般是指计算机系统中的<i id="answer1_4_1" class="answer" onclick="showOrHide('1_4_1')">程序</i>及其<i id="answer1_4_2" class="answer" onclick="showOrHide('1_4_2')">文档</i>；（2）程序是计算机任务的处理对象和处理规则的描述；（3）文档是为了理解程序所需的阐述性资料。（4）软件是一个特定问题域的抽象，是一种逻辑实体。（背）</li><li>提出软件工程的目的：倡导以工程的原理、原则、方法进行软件开发，以期解决“软件危机”。（背）</li><li>软件危机的概念：软件生产率、软件质量远远满足不了社会发展的需求，成为社会、经济发展的制约因素。</li><li>软件工程的两个时期：前期研究系统实现技术，后期关注<i id="answer1_7_1" class="answer" onclick="showOrHide('1_7_1')">软件质量</i>和<i id="answer1_7_2" class="answer" onclick="showOrHide('1_7_2')">软件工程管理</i>。</li><li>软件系统模型大体分两类：软件模型，概念模型。</li><li>软件模型进一步分为：设计模型，实现模型，部署模型。</li><li>系统模型：系统模型是代建系统的任意抽象，其中包括所有的基本能力、特性或其他方面，没有任何冗余的细节。（背）</li><li>软件开发的本质：实现<i id="answer1_11_1" class="answer" onclick="showOrHide('1_11_1')">问题空间</i>的概念和处理逻辑到<i id="answer1_11_2" class="answer" onclick="showOrHide('1_11_2')">解空间</i>的概念和处理逻辑之间的<i id="answer1_11_3" class="answer" onclick="showOrHide('1_11_3')">映射</i>。实现这一映射的基本途径可采用<i id="answer1_11_4" class="answer" onclick="showOrHide('1_11_4')">系统建模</i>。（背）</li><li>软件开发的本质所涉及的问题：（1）技术层面如何实现这样的映射。涉及两方面：过程方向，即求解软件的开发逻辑；过程途径，即求解软件的开发手段。（2）管理层面如何管理这样的映射，以保障映射的有效性和正确性，主要功能包括：软件项目的规划、组织、人员安排、控制、领导。（背）</li><li>系统建模：运用所掌握的知识，通过抽象，给出该系统的一个结构——系统模型。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/20/02333-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LeetCode热题100：71-80解析</title>
      <link>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/</link>
      <guid>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/</guid>
      <pubDate>Mon, 19 May 2025 15:23:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;74-数组中的第K个最大元素（堆-215）&quot;&gt;&lt;a href=&quot;#74-数组中的第K个最大元素（堆-215）&quot; class=&quot;headerlink&quot; title=&quot;74. 数组中的第K个最大元素（堆/215）&quot;&gt;&lt;/a&gt;74. 数组中的第K个最大元素（堆/215）</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="74-数组中的第K个最大元素（堆-215）"><a href="#74-数组中的第K个最大元素（堆-215）" class="headerlink" title="74. 数组中的第K个最大元素（堆/215）"></a>74. 数组中的第K个最大元素（堆/215）</h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<br>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。<br>假设：<br>    1 &lt;= k &lt;= nums.length &lt;= $(10)^5$；<br>    $(-10)^4$ &lt;= nums[i] &lt;= $(10)^4$。<br>示例：输入: [3,2,1,5,6,4], k = 2；输出: 5。</p><blockquote><p>【分析】<br>解法1：使用堆，空间换时间，时间复杂度O(nlogk)。<br>堆（heap,数据结构）：堆是一种特殊的完全二叉树。C#中没有具体的接口或类可用于堆，可以自己建一个，使用数组来存储，为堆结构写一个上浮和下沉的方法使堆可以排序为大顶堆或小顶堆。<br>最大堆（大顶堆）：每个节点的值都大于或等于其子节点的值。<br>最小堆（小顶堆）：每个节点的值都小于或等于其子节点的值。<br>解法2：快速选择算法，时间复杂度O(n)。<br>快速选择算法是快速排序的一个变种，它用于在未排序的数组中找到第 k 大（或第 k 小）的元素。<br>分区函数式为了找到枢纽元素在数组中的最终位置，也是快排的核心算法。<br>每次调整后只取随机枢纽元素的一侧进行递归再排序。<br>就取第K个最大元素这个需求而言，不需要把整个数组排序，只要找到第K个最大元素的正确位置即可。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="comment">//1. 使用堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindKthLargest1</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 快速选择算法（快速排序）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindKthLargest2</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line">QuickSort(nums,<span class="number">0</span>,nums.Length<span class="number">-1</span>,k);</span><br><span class="line"><span class="keyword">return</span> nums[nums.Length-k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QuickSort</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span> k</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="built_in">int</span> pviot=Partition(nums,left,right);</span><br><span class="line"><span class="comment">//快排提前终止（不需要无限递归到数组结束）</span></span><br><span class="line"><span class="keyword">if</span>(pviot==nums.Length-k)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快排分区优化</span></span><br><span class="line"><span class="keyword">if</span>(pviot&gt;nums.Length-k)&#123;</span><br><span class="line">QickSort(nums,left,pviot<span class="number">-1</span>,k);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">QickSort(nums,pviot+<span class="number">1</span>,right,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Partition</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right</span>)</span>&#123;</span><br><span class="line">Swap(nums,left,(left+right)/<span class="number">2</span>);<span class="comment">//随机数和中位数的意义差不多</span></span><br><span class="line"><span class="built_in">int</span> pviotNum=nums[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]&gt;=pviotNum)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=nums[right];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;=pviotNum)&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">nums[right]=nums[left];</span><br><span class="line">&#125;</span><br><span class="line">nums[left]=pviotNum;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[a]!=nums[b])&#123;</span><br><span class="line"><span class="built_in">int</span> temp=nums[a];</span><br><span class="line">nums[a]=nums[b];</span><br><span class="line">nums[b]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="77-买股票的最佳时机（贪心算法-121）"><a href="#77-买股票的最佳时机（贪心算法-121）" class="headerlink" title="77. 买股票的最佳时机（贪心算法/121）"></a>77. 买股票的最佳时机（贪心算法/121）</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>假设：<br>    1 &lt;= prices.length &lt;= $(10)^5$；<br>    0 &lt;= prices[i] &lt;= $(10)^4$。<br>示例：输入：[7,1,5,3,6,4]；输出：5。</p><blockquote><p>【分析】<br>找到整数数组中的两个元素，使得后一元素减去前一元素的差最大。<br>时间复杂度O(n)，空间复杂度O(1)。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MaxProfit</span>(<span class="params"><span class="built_in">int</span>[] prices</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> minPrice=prices[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> price <span class="keyword">in</span> prices)&#123;</span><br><span class="line">minPrice=Math.Min(minPrice,price);</span><br><span class="line">maxProfit=Math.Max(maxProfit,price-minPrice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      <category domain="https://pearlchocolatezy.com/tags/C/">C#</category>
      
      <category domain="https://pearlchocolatezy.com/tags/LeetCode/">LeetCode</category>
      
      <category domain="https://pearlchocolatezy.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/05/19/LeetCode100-71-80/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
