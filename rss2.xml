<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Wed, 12 Mar 2025 14:02:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>13017 计算机网络与信息安全</title>
      <link>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/</link>
      <guid>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/</guid>
      <pubDate>Tue, 25 Feb 2025 14:03:59 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;共十一章&lt;/p&gt;
&lt;h2 id=&quot;一、计算机网络与信息安全概述&quot;&gt;&lt;a href=&quot;#一、计算机网络与信息安全概述&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络与信息安全概述&quot;&gt;&lt;/a&gt;一、计算机网络与信息安全概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;大纲</description>
        
      
      
      
      <content:encoded><![CDATA[<p>共十一章</p><h2 id="一、计算机网络与信息安全概述"><a href="#一、计算机网络与信息安全概述" class="headerlink" title="一、计算机网络与信息安全概述"></a>一、计算机网络与信息安全概述</h2><p><strong>大纲知识点</strong></p><ol><li><p>什么是计算机网络？</p><blockquote><p>计算机网络是计算机技术与通信技术相互融合的产物。<br>计算机网络是利用通信设备与通信链路或者通信网络，互连位置不同、功能自治的计算机系统，并遵循一定的规则实现计算机系统之间信息交换的系统。<br>计算机网络是互连的、自治的计算机的集合。<br>目前最大的、应用最广泛的计算机网络就是Internet（因特网）。</p></blockquote></li><li><p>网络协议的三要素是什么？每个要素的含义分别是什么</p><blockquote><p>语 法 （syntax）、语 义 （semantics） 和 时 序 （timing）。<br>语法定义实体之间交换信息的格式与结构。<br>语义定义实体之间交换的信息中需要发送哪些控制信息及其具体含义、接收端如何响应、差错处理机制。<br>时序也称为同步，定义实体之间交换信息的顺序以及如何匹配或适应彼此的速度。</p></blockquote></li><li><p>按网络覆盖范围划分，主要有哪几类计算机网络？它们各有什么特点？</p><blockquote><p>按网络覆盖范围分类，计算机网络可以分为以下4 类：<br>( 1 ) 个域网：通常是由个人设备通过无线通信技术构成小范围的网络，实现个人设备间的数据传输，比如蓝牙。覆盖范围为1~10 m。<br>( 2 ) 局域网：通常部署在办公楼、校园等局部区域内，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。通常覆盖范围为10 m~1km。<br>( 3 ) 城域网：指覆盖一个城市范围的网络，覆盖范围通常为5~50km 。<br>( 4 ) 广域网：可以实现异地城域网或局域网的互连，覆盖范围在几十到几千公里。</p></blockquote></li><li><p>按网络拓扑划分，主要有哪几类计算机网络？它们各有什么特点？</p><blockquote><p>按照拓扑分类，计算机网络可以分为星形拓扑、总线型拓扑、环形拓扑、网状拓扑、树形拓扑和混合拓扑等。<br>( 1 ) 星形拓扑：包括一个中央结点，网络中的主机通过点对点通信链路与中央结点连接。<br>( 2 ) 总线型拓扑：采用一条广播信道作为总线，所有结点均与总线连接，通过总线进行结点间的通信。<br>( 3 ) 环形拓扑：利用通信链路将所有结点连接成一个闭合的环，每个结点与环互通数据。<br>( 4 ) 网状拓扑：每个结点通过多条链路与不同的结点直接连接。<br>( 5 ) 树形拓扑：可以看作总线型拓扑或星形拓扑的扩展。常见通过级联星形拓扑网络中的中央结点构建树形拓扑网络。<br>( 6 ) 混合拓扑：由两种以上简单拓扑网络混合连接而成的网络。</p></blockquote></li><li><p>计算机网络结构主要包括哪几部分？每部分的主要功能分别是什么？</p><blockquote><p>现代计算机网络的结构包括网络边缘(networkedge)、接入网络(accessnetwork)与网络核心(networkcore)三部分。</p></blockquote></li></ol><h2 id="三、传输层服务与物议"><a href="#三、传输层服务与物议" class="headerlink" title="三、传输层服务与物议"></a>三、传输层服务与物议</h2><p><strong>大纲知识点</strong></p><ol><li><p>实现可靠数据传输的主要措施有哪些？这些措施主要用于解决哪些问题？</p><blockquote><p>实现可靠数据传输的主要措施包括差错检测、确认、重传、序号以及计时器等。<br>（1）差错检测：检测和纠正数据在传输过程中的比特错误差错。<br>（2）确认：解决数据丢失或传输错误的问题。<br>（3）重传：确保数据能够完整、准确地到达接收方。<br>（4）序号：解决数据包在传输过程中可能出现的乱序问题，确保数据按正确的顺序重组。<br>（5）计时器：防止数据丢失或确认信息延迟导致的传输失败。</p></blockquote></li><li><p>UDP与TCP是分别如何实现复用与分解的？</p><blockquote><p>（1）UDP的复用与分解<br>①复用：在发送端，UDP从多个进程收集数据报，并为每个数据报添加源端口号和目标端口号，然后将这些数据报发送到网络层。<br>②分解：在接收端，UDP根据报文段中的目标端口号将数据报分发到对应的套接字。UDP套接字由二元组（目标IP地址、目标端口号）标识。<br>③特点：UDP是无连接的，不维护连接状态，因此只通过端口号进行分解。如果多个数据报具有相同的目标端口号，它们会被分发到同一个套接字。<br>（2）TCP的复用与分解<br>①复用：在发送端，TCP从多个进程收集数据流，并为每个数据流添加源IP地址、源端口号、目标IP地址和目标端口号，然后将这些数据流发送到网络层。<br>②分解：在接收端，TCP根据报文段中的四元组（源IP地址、源端口号、目标IP地址、目标端口号）将数据流分发到对应的套接字。每个TCP连接都有一个唯一的套接字。<br>③特点：TCP是面向连接的，每个连接都有一个独立的套接字，即使多个连接使用相同的端口号，也可以通过源IP和源端口号区分。</p></blockquote></li><li><p>请画出TCP报文段结构，并简要说明各个字段的主要作用。<br><img src="/2025/02/25/LearnNet13017/1.png" width="70%"></p><blockquote><p>（1）源端口号标识发送该报文段的源端口；目的端口号标识发送该报文段的目的端口。<br>（2）序号是对每个应用层数据的每个字节的编号；确认序号是期望从对方接收数据的字节序号。<br>（3）首部长度指出TCP报文段的首部长度；保留字段留给今后使用；URG=1时，说明报文中有紧急数据；ACK=1时，确认序号字段有效；PSH=1时，会尽快将报文段中数据交付进程，而不再等缓存填满后再上交；RST=1时，表明TCP连接中出现严重差错，必须释放重连；SYN=1时，表明该TCP报文段是一个建立新连接请求控制段或同意建立新连接的确认段；FIN=1时，表明该TCP报文段的发送端数据已发送完毕，请求释放TCP连接；接收窗口字段表示愿意接收的应用层数据字节数量。<br>（4）校验和字段检验TCP伪首部、TCP报文段首部、数据；紧急指针只在URG=1时有效，指出在本TCP报文段中紧急数据共多少字节。<br>（5）选项字段放入最大报文长度等信息；填充字段取值全0，使首部长度是4B的整数倍。<br>（6）数据部分存放报文段的主要数据。</p></blockquote></li><li><p>TCP为何采用三次握手来建立连接？采用二次握手可以吗？为什么？<br>&gt;</p></li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/25/LearnNet13017/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL逐行累加——实现账目余额报表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</guid>
      <pubDate>Thu, 20 Feb 2025 14:52:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;惊艳了同事的sum over语法~(✧◡✧)&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </description>
        
      
      
      
      <content:encoded><![CDATA[<p>惊艳了同事的sum over语法~(✧◡✧)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(colA) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> colB <span class="keyword">order</span> <span class="keyword">by</span> colC) <span class="keyword">from</span> temp</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL递归语法——读取树形结构表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</guid>
      <pubDate>Thu, 20 Feb 2025 14:44:48 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--recursive + inner join</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> temp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> class_id,mother_id,class_id::text <span class="keyword">as</span> path, class_name <span class="keyword">from</span> item_class <span class="comment">--and class_id=123</span></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> iic.class_id,iic.mother_id,iic.class_id::text<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.path <span class="keyword">as</span> path, iic.class_name<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.class_name <span class="keyword">as</span> class_name <span class="keyword">from</span> item_class iic <span class="keyword">inner</span> <span class="keyword">join</span> temp <span class="keyword">on</span> temp.mother_id<span class="operator">=</span>iic.class_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;/&#x27;</span>,path,<span class="string">&#x27;/&#x27;</span>) <span class="keyword">as</span> path, class_name,split_part(path,<span class="string">&#x27;/&#x27;</span>,LENGTH(path) <span class="operator">-</span> LENGTH(REPLACE(path, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>))<span class="operator">+</span><span class="number">1</span>) <span class="keyword">as</span>  class_id <span class="keyword">from</span> temp <span class="keyword">where</span> mother_id<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> <span class="built_in">position</span>(<span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> path)<span class="operator">&gt;</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13015 计算机系统原理</title>
      <link>https://pearlchocolatezy.com/2025/02/15/LearnCO/</link>
      <guid>https://pearlchocolatezy.com/2025/02/15/LearnCO/</guid>
      <pubDate>Sat, 15 Feb 2025 13:02:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;1&amp;#39;*10=10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*10=20&lt;/code&gt;&lt;br&gt;名词解释：&lt;code&gt;3&amp;#39;*2=6&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;6&amp;#39;*4=24&lt;/code&gt;&lt;br&gt;综合计算题：&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>1&#39;*10=10</code><br>填空题：<code>2&#39;*10=20</code><br>名词解释：<code>3&#39;*2=6</code><br>简答题：<code>6&#39;*4=24</code><br>综合计算题：<code>10&#39;*4=40</code></p><p>共六章</p><h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h3 id="一-1-计算机基本工作原理"><a href="#一-1-计算机基本工作原理" class="headerlink" title="一/1 计算机基本工作原理"></a>一/1 计算机基本工作原理</h3><h3 id="一-2-程序的开发与运行"><a href="#一-2-程序的开发与运行" class="headerlink" title="一/2 程序的开发与运行"></a>一/2 程序的开发与运行</h3><h3 id="一-3-计算机系统的层次结构"><a href="#一-3-计算机系统的层次结构" class="headerlink" title="一/3 计算机系统的层次结构"></a>一/3 计算机系统的层次结构</h3><h3 id="一-4-计算机系统性能评价"><a href="#一-4-计算机系统性能评价" class="headerlink" title="一/4 计算机系统性能评价"></a>一/4 计算机系统性能评价</h3><p><strong>大纲知识点</strong></p><ol><li>名词解释<br>（1）中央处理器（CPU）：控制部件、运算部件和各类寄存器互连组成的电路。<br>（2）算术逻辑部件（ALU）：用来进行算术逻辑运算的部件。<br>运算器的核心部件是<i id="answer1_6" class="answer" onclick="showOrHide('1_6')">算术逻辑运算单元</i>。 <mark class="hl-label default">（2024-10TK 1'）</mark> <br>（3）通用寄存器：用于临时存放从主存取来的数据或运算的结果。<br>（4）程序计数器（PC）：CPU 为了自动按序读取主存中的指令，需要程序计数器 , 在执行当前指令的过程中，自动计算出下一条指令的地址并送到PC中保存。<br>（5）指令寄存器（IR）：用于临时保存从主存取来的指令。<br>（6）控制器：用于自动逐条取出指令并进行译码的部件。<br>（7）主存储器：用来存放指令和数据的部件。<br>（8）总线：连接不同部件进行信息传输的介质。<br>（9）主存地址寄存器（MAR）：CPU送到地址线的主存地址先存放的位置。<br>（10）主存数据寄存器（MDR）：发送到或从数据线取来的信息存放的位置。<br>（11）机器指令：计算机能理解和执行的，用0和1表示的一串0/1序列。<br>（12）指令操作码：计算机指令中用于指示CPU执行特定操作的部分。<br>（13）高级程序设计语言：是指面向算法设计的、较接近于日常英语书面语言的程序设计语言，如C、Java等。<br>（14）汇编语言：通过用简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序。<br>（15）机器语言：使用特定计算机规定的指令格式而形成的0/1序列。<br>（16）机器级语言：是计算机硬件能够直接理解和执行的低级语言，它是计算机指令的最底层表示形式，由一系列二进制代码组成，这些代码直接对应计算机硬件的操作指令。<br>（17）源程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，被翻译的程序为源程序。<br>（18）目标程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，翻译生成的程序为目标程序。<br>（19）编译程序：也称编译器。用于将高级语言源程序翻译成汇编语言或机器语言目标程序。<br>（20）解释程序：也称解释器。用于将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行。<br>（21）汇编程序：也称汇编器。用于将汇编语言源程序翻译成机器语言目标程序。<br>（22）语言处理系统：提供程序编辑器和各类翻译转换软件的工具包。<br>（23）设备控制器：I/0控制器或I/0适配器统称为设备控制器，用于连接外设到主机。<br>（24）最终用户：使用应用软件完成特定任务的计算机用户。<br>（25）系统管理员：是指利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护，以建立高效合理的系统环境供计算机用户使用的操作人员。<br>（26）应用程序员：是指使用高级编程语言编制应用软件的程序员。<br>（27）系统程序员：指设计和开发系统软件的程序员。<br>（28）指令集体系结构（ISA）：是软件和硬件之间接口的一个完整定义。<br>（29）微体系结构：实现ISA的电路逻辑结构。<br>（30）透明：在计算机技术中，一个存在的事物或概念从某个角度看似乎不存在，即对实际存在的事物或概念感觉不到。<br>（31）响应时间：指从作业提交开始到作业完成所用的时间。<br>（32）吞吐率：在单位时间内所完成的工作量。<br>（33）用户CPU时间：指真正用于运行用户程序代码的时间。<br>（34）时钟周期：CPU主脉冲信号（计算机产生的同步的时钟定时信号）的宽度。<br>（35）主频：CPU主脉冲信号的时钟频率，是CPU时钟周期的倒数。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> <br>（36）CPI：执行一条指令所需的时钟周期数。<br>（37）基准程序：是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。<br>（38）MIPS：指令速度所用的计量单位，含义是平均每秒钟执行多少百万条指令。<br>（39）峰值MIPS：选取一组指令组合，使 得 得 到 的 平 均 C P I最小，由此得到的MIPS是峰值MIPS。<br>（40）相对MIPS：根据某个公认的参考机型来定义的相应MIPS值，是被测机型相对于参考机型MIPS的倍数。<br>（41）MFLOPS：每秒所执行的浮点运算有多少百万次。<br>（42）GFLOPS：每秒所执行的浮点运算有多少$10^9$次。<br>（43）TFLOPS：每秒所执行的浮点运算有多少$10^{12}$次。<br>（44）PFLOPS：每秒所执行的浮点运算有多少$10^{15}$次。<br>（44）EFLOPS：每秒所执行的浮点运算有多少$10^{18}$次。</li><li>简答<br>（1）冯・ 诺依曼计算机由哪几部分组成？各部分的功能是什么？<blockquote><p>计算机由运算器、控制器、存储器、输入设备和输出设备五大基本部件组成。<br>运算器能进行基本算术和逻辑运算。<br>控制器应能自动执行指令。<br>存储器能存放数据和指令。<br>操作人员可以通过输入输出设备使用计算机。</p></blockquote></li></ol><p>（2）什么 是 “存储程序”工作方式？</p><blockquote><p>必须将事先编好的程序和原始数据送入主存后才能执行程序，一旦程序被启动执行，计算机不需要操作人员干预就能自动完成逐条指令取出和执行的任务。</p></blockquote><p>（3）一条指令的执行过程包含哪几个阶段？</p><blockquote><p>从主存取指令→对指令进行译码→PC增量→取操作数并执行→将结果送至主存或寄存器保存。</p></blockquote><p>（4）计算机系统的层次结构如何划分？</p><blockquote><p>计算机系统由硬件和软件两大部分所构成。<br>硬件是物理装置的总称。<br>软件包括操作系统、编程语言、算法和应用。<br>指令体系结构ISA作为软件与硬件之间的桥梁，提供软件与硬件接口的完整定义。<br>计算机系统的层次结构共分为五级:<br>第1级：微程序设计级,这是一个实际存在的硬件级,由硬件直接执行微指令。<br>第2级：机器语言级,它由微程序解释机器指令系统,该级也属于硬件级。<br>第3级：操作系统级,该级采用机器语言解释执行,既涉及软件资源,也涉及硬件资源,即在操作系统的控制之下调用系统的硬件与软件资源。<br>第4级：汇编语言级,这一级用汇编程序支持和执行。<br>第5级：高级语言级,这一级由各种高级语言编译程序支持和执行,它是面向用户的,所编写的程序称之为用户程序,这一级属于软件级。</p></blockquote><p>（5）计算机系统的用户可分为哪几类？每类用户工作在哪个层次？</p><blockquote><p>按照在计算机上完成任务的不同，可以把使用计算机的用户分成以下4 类 ：最终用户、<br>系统管理员、应用程序员和系统程序员。<br>① 最终用户：使用应用软件完成特定任务。<br>② 系统管理员：利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护。<br>③ 应用程序员：使用高级编程语言编制应用软件的程序员。<br>④ 系统程序员：设计和开发系统软件的程序员，工作在机器语言级。</p></blockquote><p>（6）程序的CPI与哪些因素有关？</p><blockquote><p>CPI：表示执行一条指令所需的时钟周期数。<br>影响 CPI 的因素主要包括：硬件设计（CPU 架构、缓存机制），指令集架构（ISA），程序特性，系统软件。</p></blockquote><p>（7）为什么说性能指标MIPS不能很好地反映计算机的性能？</p><blockquote><p>MIPS：其含义是平均每秒钟执行多少百万条指令。反映了机器执行定点指令的速度。<br>① 有些制造商经常将峰值MIPS直接当作MIPS , 而实际上的性能要比标称的性能差。<br>② 不同机器的指令集不同，指令的功能也不同，因此，同样的指令条数所完成的功能可能不同。<br>③ 不同机器的 CPI 和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同。</p></blockquote><ol><li>应用题<br>（1）假定你的朋友不太懂计算机，请用简单通俗的语言给你的朋友介绍计算机系统是如何工作的。<blockquote><p>计算机系统主要由两部分组成：硬件和软件。<br>硬件：就是计算机的实体部分，如机箱、处理器。<br>软件：就是各种程序和指令，如操作系统、游戏软件。<br>计算机的工作可以简单地分为三个步骤：输入、处理和输出。<br>输入就是用键盘等输入设备把信息传递给计算机，这些信息就像是你给计算机的“指令”。<br>处理：计算机接收到输入的信息后，它会用“大脑”来处理这些信息，计算机的“大脑”主要是CPU（中央处理器）。CPU会从内存中读取需要处理的数据，按照软件的指令进行计算。<br>输出：处理完之后，计算机就会把结果输出给你，比如显示在屏幕上的文字、播放音乐。<br>软件是计算机的灵魂，它告诉硬件该做什么。<br>计算机通过硬件和软件的配合，能够快速、高效地完成各种复杂的任务。</p></blockquote></li></ol><p><strong>真题</strong></p><ol><li>冯·诺依曼计算机工作方式的基本特点：<br>（1）“存储程序”工作方式 <mark class="hl-label default">（2024-10XZ 1'）</mark> <br>（2）计算机由五大部件组成：<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">运算器</i>、<i id="answer1_2" class="answer" onclick="showOrHide('1_2')">控制器</i>、<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">存储器</i>、<i id="answer1_4" class="answer" onclick="showOrHide('1_4')">输入设备</i>、<i id="answer1_5" class="answer" onclick="showOrHide('1_5')">输出设备</i>。<br>（3）存储器能存放数据和指令；<br>控制器能自动执行指令；<br>运算器能进行基本算术和逻辑运算；<br>操作人员可以通过I/O设备使用计算机<br>（4）计算机内部以二进制形式表示指令和数据；<br>每条指令=操作码+地址码+…，操作码指出操作类型，地址码指出操作数的地址；<br>由一串指令组成程序。</li></ol><h2 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><p><strong>书本知识点</strong></p><ol><li>整数用<mark class="hl-label blue">定点数</mark> 表示，实数用<mark class="hl-label blue">浮点数</mark> 表示。<br>机器数：计算机内部编码表示的数。一定是一个0/1序列（常缩写为16进制形式）。（X）<br>真值：机器数真正的值。（$X_T$）<br>定点数有四种编码表示方法：原码、补码、反码、移码。它们都是机器数。<br>（其中移码既可以表示整数，也可以表示小数）<br>它们的值都由符号位（最高位）和数值位组成。原码、补码、反码的符号位正数由0表示，负数由1表示。</li></ol><p>（1）原码<br>符号位：最高位为符号位，0表示正数，1表示负数。<br>数值位：其余位表示数值的绝对值。<br>（2）反码<br>符号位：最高位为符号位，0表示正数，1表示负数。符号位独立于数值的绝对值，仅表示正负。<br>数值位：正数的反码与原码相同；负数的反码是原码的数值位取反。<br>缺点：0的表示不唯一；比补码少表示一个最小负数<br>（3）补码<br>符号位：最高位为符号位，0表示正数，1表示负数。<u>符号位既表示正负，也和数值位共同构成补码的值。补码的设计使得加法和减法运算更加高效，因为可以使用相同的加法电路来处理正数和负数的加法。</u><br>数值位：正数的补码与原码相同；负数的补码是反码加1。<br>补码反求真值：数值位取反加一，再加符号。<br>已知补码，求真值反向符号的补码（已知<script type="math/tex">[X^T]_{补}</script>，求<script type="math/tex">[-X^T]_{补}</script>）：符号位和数值位一起，各位取反，末位加1。（最小负数1000 0000的补码不存在，因为溢出）<br>（4）移码<br>符号位：最高位为符号位，但移码的符号位表示方式与原码、补码、反码不同。移码通过偏移量将数值映射到一个无符号数范围内，符号位的作用是区分正负。<br>数值位：移码的值等于原码的值加上偏移量 $2^{n−1}$，其中 n 是位数。<br>（数值位加上偏移量，使得首位表示符号，1为正数，0为负数；小数部分称为浮点数的尾数，整数部分称为浮点数的阶）</p><p>现代计算机中带符号整数都用补码表示。</p><ol><li>补码的运算表达什<br>加法公式：<script type="math/tex">[x+y]_补=[x]_补+[y]_补</script><br>减法公式：<script type="math/tex">[x-y]_补=[x]_补+[-y]_补</script></li></ol><p><strong>真题</strong></p><ol><li><p>简述计算机内部和外部需要进行数制转换的原因： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>计算机内部所有信息都采用二进制编码表示。(2分)<br>但在计算机外部,大都采用八、十或十六进制表示形式。(2分)<br>因此,计算机在数据输入后或输出前都必须实现这些进制数和二进制数之间的转换。(2分)</p></blockquote></li><li><p>二进制、八进制、十六进制转十进制： <mark class="hl-label default">（2024-10XZ 1'）</mark> </p><script type="math/tex; mode=display">(10010)_2=2^4+2^1=18</script><script type="math/tex; mode=display">(347)_8=3*2^2+4*2^1+7*2^0=27</script><script type="math/tex; mode=display">(28E)_{16}=2*16^2+8*16^1+14*16^0=654</script><p>十六进制：A=10，B=11，C=12，D=13，E=14，F=15</p></li><li><p>浮点运算器可以用阶码部件和尾数部件来实现。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="三、程序的转换-及-机器级表示"><a href="#三、程序的转换-及-机器级表示" class="headerlink" title="三、程序的转换 及 机器级表示"></a>三、程序的转换 及 机器级表示</h2><ol><li>指令系统中采用不同寻址方式的目的主要是：缩短指令长度，扩大寻址空间，提高编程灵活性。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </li></ol><h2 id="四、可执行文件的生成-与-加载执行"><a href="#四、可执行文件的生成-与-加载执行" class="headerlink" title="四、可执行文件的生成 与 加载执行"></a>四、可执行文件的生成 与 加载执行</h2><ol><li><p>从源程序变为可执行文件的步骤：<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">预处理</i>、<i id="answer4_2" class="answer" onclick="showOrHide('4_2')">编译</i>、<i id="answer4_3" class="answer" onclick="showOrHide('4_3')">汇编</i>、<i id="answer4_4" class="answer" onclick="showOrHide('4_4')">链接</i>。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li><li><p>在父进程中创建一个子进程，使用<i id="answer4_5" class="answer" onclick="showOrHide('4_5')">fork</i>函数。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="五、程序的存储访问"><a href="#五、程序的存储访问" class="headerlink" title="五、程序的存储访问"></a>五、程序的存储访问</h2><ol><li><p>重定位：重新确定代码和数据的地址,并更新指令中被引用符号地址的操作。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> </p></li><li><p>简述在递归深度较深时，递归调用的时间开销和空间开销都会较大的原因：  <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>每个过程包含准备阶段和结束阶段,并在栈中新增一个栈帧,(2分)<br>因而,每增加一次过程调用,就要增加许多条包含在准备阶段和结束阶段的额外指令,并增加一个栈帧的空间,(2分)<br>当递归调用深度较深时,这些额外指令的执行时间开销和栈帧的空间开销就会很大,有些情况下甚至发生栈溢出。(2分)</p></blockquote></li><li><p>简述动态链接的共享性和动态性： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>共享性是指共享库中的代码段在内存只有一个副本,当应用程序在其代码中需要引用共享库中的符号时,在引用处通过某种方式确定指向共享库中对应定义符号的地址即可;(3分)<br>动态性是指共享库只有使用它的程序被加载或执行时才加载到内存。(3 分)</p></blockquote></li><li><p>非易失性存储器：ROM，次表面存储器，光存储器。<br>易失性存储器：主存，高速缓冲存储。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="六、程序中I-O操作的实现"><a href="#六、程序中I-O操作的实现" class="headerlink" title="六、程序中I/O操作的实现"></a>六、程序中I/O操作的实现</h2><ol><li><p>简述中断控制I/0方式的基本思想： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>当需要进行I /O 操作时,首先启动外设进行第一个数据的 I /O 操作,然后阻塞请求I /O的用户进程,并调度其他进程到 CPU上执行,期间外设在设备控制器的控制下工作。(2 分)<br>外设完成 I /O 操作后,向 CPU 发送一个中断请求信号,CPU 检测到该信号后,则进行上下文切换,调出相应的中断服务程序执行。(2分)<br>中断服务程序将启动后续数据的 I /O操作,然后返回到被打断的进程继续执行。(2分)</p></blockquote></li><li><p>子系统层次结构（图） <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/15/LearnCO/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</link>
      <guid>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</guid>
      <pubDate>Wed, 12 Feb 2025 13:34:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8=40&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;共八章&lt;/p&gt;
&lt;h2 id=&quot;一、绪论&quot;&gt;&lt;a href=&quot;#一、绪</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*15=30</code><br>填空题：<code>2&#39;*15=30</code><br>简答题：<code>5&#39;*8=40</code></p><p>共八章</p><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><ol><li><p>软件开发的本质及其涉及到的问题 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）将软件开发的本质概括为：不同抽象层术语之间的“映射”，以及不同抽象层处理逻辑之间的“映射”。（2’）<br>（2）它涉及到两方面的问题：<br>①一是如何实现这样的映射，这是技术层面上的问题。（1’）<br>②二是如何管理这样的映射，以保障映射的有效性和正确性。这是管理层面上的问题。（2’）</p></blockquote></li><li><p>计算机软件=<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">程序</i>+文档</p></li></ol><h2 id="二、软件需求与规约"><a href="#二、软件需求与规约" class="headerlink" title="二、软件需求与规约"></a>二、软件需求与规约</h2><h2 id="三、结构化方法"><a href="#三、结构化方法" class="headerlink" title="三、结构化方法"></a>三、结构化方法</h2><ol><li><p>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>结构化方法总体设计的三个阶段 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</p></blockquote></li><li><p>结构精细化设计的原则：高内聚低耦合<mark class="hl-label default">（2024-04XZ 2'）</mark> ；逐步细化；清晰第一，效率第二；遵循结构化控制结构……</p></li><li><p>在结构化设计中，执行一个特殊任务的一个过程以及相关的数据结构，称之为<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">模块</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> <br>模块（Module）是结构化设计的核心概念之一，它将程序分解为可管理的、功能单一的代码单元，每个模块完成一个特定的任务，并通过明确的接口与其他模块交互。</p></li></ol><h2 id="四、面向对象方法UML"><a href="#四、面向对象方法UML" class="headerlink" title="四、面向对象方法UML"></a>四、面向对象方法UML</h2><ol><li><p>UML表达客观事物之间关系的术语及定义 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）为了表达各类客观事物之间的关系，UML给出了表达关系的基本术语：关联、泛化、细化、依赖；（1分）<br>（2）关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。（1分）泛化是一般性类目和它的较为特殊性类目之间的一种关系。（1分）细化是类目之间的语义关系，其中一个类目规约了保证另一个类目执行的契约。（1分）依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。（1分）</p></blockquote></li><li><p>为了进一步表达泛化的语义，UML给出了4个约束，分别为完整、不完整、<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">互斥、重叠</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> </p></li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段"><a href="#（一）初始阶段" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段"><a href="#（二）细化阶段" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><p>使用类图来定义分析类（边界类、实体类、控制类）<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/1.png" width="80%"></p><h3 id="（三）构建阶段"><a href="#（三）构建阶段" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段"><a href="#（四）交付阶段" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="五、面向对象方法RUP"><a href="#五、面向对象方法RUP" class="headerlink" title="五、面向对象方法RUP"></a>五、面向对象方法RUP</h2><p>定义：Rational Unified Process，统一软件开发过程。</p><ol><li>RUP中<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">部署模型</i> <mark class="hl-label default">（2024-04TK 2'）</mark>  的主要内容：节点，节点之间的通信关系，主动类到节点的映射 <mark class="hl-label default">（2024-04TK 2'）</mark> ，软件组件到节点的映射，部署配置，部署视图，部署计划</li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段-1"><a href="#（一）初始阶段-1" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段-1"><a href="#（二）细化阶段-1" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><h3 id="（三）构建阶段-1"><a href="#（三）构建阶段-1" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段-1"><a href="#（四）交付阶段-1" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="六、软件测试"><a href="#六、软件测试" class="headerlink" title="六、软件测试"></a>六、软件测试</h2><ol><li><p>描述系统或软件问题时常用的术语：<br>错误：由于开发人员的疏忽、误解或其他原因导致的不符合预期的行为或状态。错误通常发生在开发阶段，例如需求分析、设计或编码过程中。<br>故障：系统或组件的内部状态不正常。能是偶然的（如硬件故障）或系统的（如软件设计缺陷）。<br><i id="answer6_2" class="answer" onclick="showOrHide('6_2')">失效</i>：系统或组件未能按照预期执行其功能，是用户可观察到的错误行为或结果。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>人类对软件测试目的的认识经历了<i id="answer6_1" class="answer" onclick="showOrHide('6_1')"> 5 </i>个阶段 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br>（1）错误检测阶段<br>（2）验证阶段<br>（3）质量保证阶段<br>（4）风险控制阶段<br>（5）用户体验和价值交付阶段</p></li></ol><h2 id="七、软件生命周期"><a href="#七、软件生命周期" class="headerlink" title="七、软件生命周期"></a>七、软件生命周期</h2><ol><li><p>螺旋模型概念及其特点 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）螺旋模型是瀑布模型与演化模型的基础上，加入两者所忽略的风险分析所建立的一种软件开发模型。（2’）<br>（2）螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。（3’）</p></blockquote><p> <img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/3.png" width="80%"></p></li><li>瀑布模型适用于需求明确、稳定且对安全性和可靠性要求高的项目，例如企业内部管理信息系统、航空航天和医疗设备领域的软件开发。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/4.png" width="80%"></li></ol><p>五个主要阶段：</p><h3 id="（一）需求分析"><a href="#（一）需求分析" class="headerlink" title="（一）需求分析"></a>（一）需求分析</h3><h3 id="（二）设计阶段"><a href="#（二）设计阶段" class="headerlink" title="（二）设计阶段"></a>（二）设计阶段</h3><h4 id="（二-1）概要设计"><a href="#（二-1）概要设计" class="headerlink" title="（二/1）概要设计"></a>（二/1）概要设计</h4><ol><li><p>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。<br>功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。<br>接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。<br>数据库设计：设计核心数据的逻辑结构。</p></blockquote></li><li><p>概要设计规约的作用</p><blockquote><p>是系统设计阶段的重要文档，用于指导详细设计和后续的开发工作。<br>是系统架构和功能模块设计的正式文档，为开发团队提供整体设计思路。</p></blockquote></li></ol><h4 id="（二-2）详细设计"><a href="#（二-2）详细设计" class="headerlink" title="（二/2）详细设计"></a>（二/2）详细设计</h4><h3 id="（三）编码阶段"><a href="#（三）编码阶段" class="headerlink" title="（三）编码阶段"></a>（三）编码阶段</h3><h3 id="（四）测试阶段"><a href="#（四）测试阶段" class="headerlink" title="（四）测试阶段"></a>（四）测试阶段</h3><h3 id="（五）维护阶段"><a href="#（五）维护阶段" class="headerlink" title="（五）维护阶段"></a>（五）维护阶段</h3><h2 id="八、集成化能力成熟度模型CMMI"><a href="#八、集成化能力成熟度模型CMMI" class="headerlink" title="八、集成化能力成熟度模型CMMI"></a>八、集成化能力成熟度模型CMMI</h2><p>定义：是一种用于评估和改进组织在软件开发、系统集成、项目管理等方面过程能力的框架。<br>CMMI的成熟度等级：初始级，已管理级，已定义级，已量化管理级，持续优化级。共 5 个等级，每个等级要记英文，可能会考某个等级的名字；最高等级为第5级，优化级。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p><ol><li><p>能力等级和成熟度等级之间的区别和联系 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）区别：能力等级是一种过程改善路径，该路径可使组织针对单一过程域不断改善该过程域。（1分）成熟度等级也是一种过程改善路径，该路径可使组织通过关注一组过程域不断改善一组相关的过程域;（1分）<br>（2）联系：能力等级和成熟度等级都是CMMI提供的两种过程改善路径，侧重不同：它们都是按共用目标从弱到强。（1分）当某一过程域逐步完成了所有等级的“最佳实践”，它才可能满足成熟度等级对单一过程域的要求。（1分）当一组过程域及相关共用目标的一个成熟度等级完成后，软件过程才能实现高一级别的“成熟”，从而实现对软件过程有效管理的“最佳实践”。（1分）</p></blockquote></li><li><p>CMMI模型根据核心能力领域对过程域进行分类，这些能力领域包括：<br>治理：提供高级管理在过程治理中的角色指导。<br>实施基础设施：确保组织的重要过程和资产被持续使用和改进。<br>过程管理：包括组织过程焦点、过程定义等。<br>项目管理：包括项目规划、监控、风险管理等。<br>工程：涉及需求开发、技术方案、验证等。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br>支持：包括配置管理、度量分析、质量保证等。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/6.png" width="80%"></p></li><li><p>CMMI的模型部件中，实践部件的图形是菱形 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/5.png" width="80%"></p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747 Java语言程序设计 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/05/LearnJava/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/LearnJava/</guid>
      <pubDate>Wed, 05 Feb 2025 13:33:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8&lt;/code&gt;&lt;/p&gt;
&lt;!--
## 2024-10真题
### 1.1 Java语言支持的基本数据类型 及 包含的</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*10</code><br>填空题：<code>2&#39;*15</code><br>简答题：<code>5&#39;*8</code></p><!--## 2024-10真题### 1.1 Java语言支持的基本数据类型 及 包含的各类型对应的所有关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整数类型：byte, short, int, long (1&#x27;)</span><br><span class="line">浮点数类型：float, double (1&#x27;)</span><br><span class="line">字符类型：string (1&#x27;)</span><br><span class="line">布尔类型：boolean (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-2-Java的异常类型及各自特点"><a href="#1-2-Java的异常类型及各自特点" class="headerlink" title="1.2 Java的异常类型及各自特点"></a>1.2 Java的异常类型及各自特点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java的异常分为三种类型： (1&#x27;)</span><br><span class="line">（1）受检异常，必须被处理  (1&#x27;)</span><br><span class="line">（2）运行时异常，不需要处理  (1&#x27;)</span><br><span class="line">（3）错误，不需要处理  (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-3-什么是包装类"><a href="#1-3-什么是包装类" class="headerlink" title="1.3 什么是包装类"></a>1.3 什么是包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包装类是一种特殊的基本类型。 (2&#x27;)</span><br><span class="line">当想用处理对象一样的方式来处理基本数据类型的数据时，必须将基本数据类型值“包装”为一个对象。  (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-4-什么是抽象类-及其作用"><a href="#1-4-什么是抽象类-及其作用" class="headerlink" title="1.4 什么是抽象类 及其作用"></a>1.4 什么是抽象类 及其作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义了方法但没有定义具体实现的类称为抽象类，通过abstract关键字完成。 (2&#x27;)</span><br><span class="line">在程序中，需要创建某个类代表一些基本行为，并为其规范定义一些方法，但又无法或不宜在这个类实现，希望在其子类实现。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-5-描述Java的委托事件处理模型"><a href="#1-5-描述Java的委托事件处理模型" class="headerlink" title="1.5 描述Java的委托事件处理模型"></a>1.5 描述Java的委托事件处理模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每当用户在组件上进行某种操作时，事件处理系统会生成一个事件类对象。 (2&#x27;)</span><br><span class="line">事件被直接送往产生这个事件的组件，组件需要注册一个或多个侦听程序。 (1&#x27;)</span><br><span class="line">侦听程序的类中包含了事件处理程序，用来接收和处理这个事件。 (1&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**Expand**</span><br><span class="line">Java的委托事件处理模型（Delegation Event Model）是Java中用于处理事件的一种机制，它基于观察者模式（Observer Pattern），将事件源（Event Source）和事件监听器（Event Listener）分离，从而实现低耦合和高灵活性。</span><br><span class="line">1. 基本概念</span><br><span class="line">    事件源（Event Source）：是产生事件的对象，例如按钮（Button）、文本框（TextField）等。事件源可以触发一个或多个事件。</span><br><span class="line">    事件（Event）：是某个动作或状态的表示，例如鼠标点击（ActionEvent）、键盘输入（KeyEvent）等。</span><br><span class="line">    事件监听器（Event Listener）：是实现特定接口的对象，用于处理事件。监听器接口定义了事件处理方法，例如 ActionListener 接口中的 actionPerformed 方法。</span><br><span class="line">    事件处理器（Event Handler）：是事件监听器中实现的事件处理方法，用于响应事件。</span><br><span class="line">2. 工作原理</span><br><span class="line">（1）注册事件监听器，通过实现特定的接口来定义事件处理逻辑</span><br><span class="line">（2）事件触发，当用户与事件源交互时（例如点击按钮），事件源会生成一个事件对象（如 ActionEvent）。事件源将事件对象传递给所有注册的监听器。</span><br><span class="line">（3）事件处理</span><br><span class="line">3. 事件传播机制</span><br><span class="line">    捕获阶段（Capturing Phase）：事件从最顶层的容器开始向下传播，直到到达事件源。</span><br><span class="line">    冒泡阶段（Bubbling Phase）：事件从事件源开始向上传播，直到到达最顶层的容器。</span><br></pre></td></tr></table></figure><h2 id="2024-04真题"><a href="#2024-04真题" class="headerlink" title="2024-04真题"></a>2024-04真题</h2><h3 id="2-1-接口与多重继承的关系"><a href="#2-1-接口与多重继承的关系" class="headerlink" title="2.1 接口与多重继承的关系"></a>2.1 接口与多重继承的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java不支持多重继承，一个类只能从唯一的一个类继承而来。但是，这并不意味着Java不能实现多重继承的功能。 (2&#x27;)</span><br><span class="line">具体来说，Java允许一个类实现多个接口，从而具备了多重继承的能力。因为接口中声明的方法体是空的，所以不会出现多重继承中固有的混乱。 (2&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口（Interface）是一种特殊的抽象类型，它定义了一组行为规范，但不提供具体实现。当一个类实现某个接口时，它必须提供接口中声明的所有方法的具体实现。这种机制被称为契约机制。</span><br><span class="line">面向接口编程是一种重要的设计原则，它强调通过接口来定义和交互，而不是直接依赖具体的类。这种方式可以带来以下好处：解耦（实现类和使用类之间只依赖接口，而不是具体的实现），多态（通过接口引用调用方法时，可以根据实际对象的类型动态调用相应的方法）。</span><br></pre></td></tr></table></figure><h3 id="2-2-解释线程控制中方法的功能（max-4’）"><a href="#2-2-解释线程控制中方法的功能（max-4’）" class="headerlink" title="2.2 解释线程控制中方法的功能（max:4’）"></a>2.2 解释线程控制中方法的功能（max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start()：启动线程对象。 (2&#x27;)</span><br><span class="line">yield()：用于强制终止线程的执行。 (2&#x27;)</span><br><span class="line">wait()：导致当前线程等待。 (2&#x27;)</span><br><span class="line">notify()：当其它线程调用某线程的notify方法时，唤醒该线程。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"><a href="#2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号" class="headerlink" title="2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"></a>2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Font</span> <span class="variable">fn</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Courier&quot;</span>,Font.BOLD,<span class="number">20</span>);  <span class="comment">//(4&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-静态方法的特点（1’-answer，max-4’）"><a href="#2-4-静态方法的特点（1’-answer，max-4’）" class="headerlink" title="2.4 静态方法的特点（1’/answer，max:4’）"></a>2.4 静态方法的特点（1’/answer，max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）静态方法以static修饰；</span><br><span class="line">（2）静态方法属于类，不属于对象；</span><br><span class="line">（3）调用静态方法时，前缀可以使用类名；</span><br><span class="line">（4）静态方法中不能访问类对象的非静态成员，只能访问类的静态成员；</span><br><span class="line">（5）静态方法中没有this指针；</span><br><span class="line">（6）静态方法不可以被重写。</span><br></pre></td></tr></table></figure><p>—&gt;</p>-->]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/LearnJava/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>解决ssh: connect to host github.com port 22: Connection timed out</title>
      <link>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</guid>
      <pubDate>Wed, 05 Feb 2025 01:57:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;部署在github上的hexo博客，用了很久的默认22端口突然连不上了&lt;br&gt;&lt;img class=&quot;zy_img_shadow&quot; src=&quot;/2025/02/05/SolveSshError/1.png&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能原因是：&lt;/p&gt;
&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<p>部署在github上的hexo博客，用了很久的默认22端口突然连不上了<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/1.png" width="60%"></p><p>可能原因是：</p><blockquote><p>网络连接问题<br>SSH秘钥配置错误<br>22端口已占用<br>……</p></blockquote><p>排除下来22端口被占用或其他环境因素禁用的可能性比较大，可以改为443端口（HTTPS端口，通常开放）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/2.png" width="60%"><br>跟<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub官网</a>的主机密钥指纹对比确认正确后输入yes<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/3.png" width="60%"></p><p><strong>在.ssh文件夹中配置新的端口号：</strong><br>找到目录：C:\Users\&lt;你的用户名&gt;.ssh\config（Windows）<br>如果没有config文件可以在.ssh文件夹下新建一个config空文件<br>文件内容为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">  <span class="string">HostName</span> <span class="string">ssh.github.com</span></span><br><span class="line">  <span class="string">Port</span> <span class="number">443</span></span><br><span class="line">  <span class="string">User</span> <span class="string">git</span></span><br><span class="line">  <span class="string">PreferredAuthentications</span> <span class="string">publickey</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">~\.ssh\id_rsa</span></span><br></pre></td></tr></table></figure><br>尝试重新推送即可。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Git/">Git</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/SolveSshError/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（五）——链路层和局域网</title>
      <link>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</link>
      <guid>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</guid>
      <pubDate>Tue, 04 Feb 2025 08:35:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;链路层&quot;&gt;&lt;a href=&quot;#链路层&quot; class=&quot;headerlink&quot; title=&quot;链路层&quot;&gt;&lt;/a&gt;链路层&lt;/h2&gt;&lt;h3 id=&quot;目标：原理和实现&quot;&gt;&lt;a href=&quot;#目标：原理和实现&quot; class=&quot;headerlink&quot; title=&quot;目标：原理</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="目标：原理和实现"><a href="#目标：原理和实现" class="headerlink" title="目标：原理和实现"></a>目标：原理和实现</h3><p>原理：<br>检错和纠错<br>共享广播信道：多点接入<br>链路层寻址<br>LAN：以太网，VLANs<br>可靠数据传输</p><p>链路层技术的实现</p><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>广域网WAN：网络形式采用点到点链路，实现容易<br>局域网LAN：一般采用多点连接方式，实现复杂<br>链路层的主要功能：一个节点把帧通过链路传到相邻的另一个节点（点到点）。<br>链路层服务：成帧，链路介入；在相邻两个节点完成可靠数据传递；在相邻节点间进行可靠转发；流量控制；错误检测；差错纠正；半双工和全双工（可收可发）。（一个特定的链路层只提供其中一种服务）<br>链路层功能在哪里实现：每个主机上，装了网卡，网卡实现网络层和链路层的功能；路由器上有多个网卡，每个网卡实现了物理层和相应链路层的功能。即，链路层功能在网卡上实现，网卡又称网络适配器（NIC），开机自动运行，按照协议工作。</p><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p>残存错误<br>奇偶校验<br>CRC循环冗余校验码：<br>1）模2运算（按位异或，加法不进位）；<br>2）位串的两种表示（0和1；多项式表示）；<br>3）生成多项式（r次方的比特序列）；<br>4）约定：sender多项式<code>[D][EDC]</code> 使得 receiver多项式<code>[D][EDC]</code>满足 接收方r位多项式/生成多项式=整数，则数据在传输过程中没有出错<br>CRC性能分析：能够查出所有1bit的错误、双bit的错误……</p><h3 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h3><p>多路访问链路和协议：<br>两种类型的链路：点对点，广播（共享线路和媒体）<br>多路访问协议：MAC<br>理想的MAP协议：1）当一个节点要发送时，按R速率（按信道设计带宽全速）发送；2）当M个节点要发送，每个以R/M的平均速率发送；3）完全分布；4）简单。<br>MAC分类：信道划分，随机访问，依次轮流。<br>信道划分MAC协议：<br>（1）TDMA(time division multiple access)：轮流使用信道，信道的时间分为周期（时分复用）<br>（2）FDMA(frequency division multiple access)：信道的有效频率被分为一个个小的频段（频分复用）<br>（3）CDMA(code division multiple access)：码分多路访问<br>随机存取协议</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/04/LearnNet5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（四）——网络层</title>
      <link>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</link>
      <guid>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</guid>
      <pubDate>Thu, 30 Jan 2025 02:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;网络层：数据平面&quot;&gt;&lt;a href=&quot;#网络层：数据平面&quot; class=&quot;headerlink&quot; title=&quot;网络层：数据平面&quot;&gt;&lt;/a&gt;网络层：数据平面&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解网络服务的基本原理<br>网络服务模型<br>转发和路由<br>路由器工作原理<br>通用转发<br>网络层协议的实例</p><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ol><li>在发送主机和接收主机对之间传送段</li><li>在发送端，将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ol><h3 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h3><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP分片和重组<br>IP编址<br>子网：IP地址高位部分相同，无需路由器介入。<br>IP地址分类：A类（126 networks, 16million hosts），B类，C类（大部分）<br>127.x.x.x 表示回路地址：自上而下到达IP层再反转回去<br>DHCP协议：动态从服务器获取IP地址</p><h3 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h3><p>每个路由器都有控制平面和数据平面，分布化实现，用路由表粘连控制平面和数据平面（控制平面控制路由表，数据平面利用路由表信息进行转发）<br>SDN特点：1）基于流的匹配+行动；2）控制平面和数据平面分离；3）控制平面功能在数据交换设备之外实现；4）可编程控制应用。<br>SDN架构：（自下而上） 数据平面交换机（基于南向API，SDN控制器访问基于流的交换机)，SDN控制器（通过北向API和控制应用交互，通过南向API和网络交换机交互；逻辑上集中，实现上分布），控制应用（采用下层SDN控制器提供的API，实现网络功能，e.g.防火墙、接入控制、负载均衡）。<br>南向接口：SDN控制器（软件层面）与网络设备（硬件层面）之间的通信接口。e.g.OpenFlow<br>北向接口：提供给其他厂家或运营商进行接入和管理的接口，即向上提供的接口。<br>通用流表的组成：模式，行动，优先权，计数器<br>转发表和流表是怎样计算出来的：通过控制平面</p><h2 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>传统路由选择算法<br>SDN控制器<br>ICMP<br>网络管理</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>路由：按照某种指标（站数、延迟、费用、队列长度）找到一条从源节点到目标节点的较好路径<br>路由器之间的最优路径=主机对之间的最优路径<br>路由选择算法就是为所有路由路由器找到并使用汇集树。<br>路由选择算法的原则：正确性，简单性（不应为获取路由信息而增加通信量），健壮性（能适应通信量和网络拓扑变化），稳定性，公平性，最优性。<br><strong>链路状态算法 link state</strong><br>步骤：1）获得整个网络拓扑和边的代价信息（我的链路状态分组在全网泛洪）；2）计算本站点到其它站点的最优路径（Dijkstra算法，可以找例题！复杂度O(n^2)，堆优化后是O(nlogn)），得到路由表；3）按此路由表转发分组。<br>e.g.OSPF，IS-IS<br><strong>距离矢量算法 distance vector</strong><br>思想：各路由器维护一张到目标的路由表；各路由器与相邻路由器交换路由表；根据获得的路由信息更新路由表。（最后让各个节点收敛到一个真实状态）<br>特点：好消息传得快，坏消息传的慢（无穷计算-&gt;水平分裂算法：减少影响，不能杜绝发生）。</p><p>比较：<br>（1）消息复杂度：DV胜出<br>（2）收敛时间：LS胜出<br>（3）健壮性：LS胜出</p><h3 id="因特网中自治系统内部的路由器选择"><a href="#因特网中自治系统内部的路由器选择" class="headerlink" title="因特网中自治系统内部的路由器选择"></a>因特网中自治系统内部的路由器选择</h3><p>路由分为内部网关协议和外部网关协议。<br>内部网关协议有RIP协议和OSPF协议。<br>RIP(routing information protocal)协议基于DV算法。<br>OSPF(open shortest path first)协议基于LS算法。特性：安全，允许多个代价相同的路径存在，有多重代价矩阵。</p><h3 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h3><p>（自治区之间的路由选择协议，外部网关协议）<br>BGP协议：边界网关协议。将互联网各个自治系统(AS)粘在一起的胶水。<br>使用TCP协议交换BGP报文。（只要了解什么是层次性路由，为什么要用层次性路由）<br>层次路由的优点：解决了规模问题，解决了管理问题。<br>热土豆策略：选择具备最小内部区域代价的网关作为出口，不考虑代价。</p><h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><p>传统方式：per-router控制平面<br>SDN方式：逻辑上的集中控制平面（2005年后，详见上）<br>为什么需要逻辑上的集中控制平面：管理更容易，允许可编程的路由器，控制平面的开放实现<br>传统方式实现流量工程困难，用SDN方式容易。<br>SDN控制器的实现：ODL,ONOS</p><h3 id="ICMP-因特网控制报文协议"><a href="#ICMP-因特网控制报文协议" class="headerlink" title="ICMP 因特网控制报文协议"></a>ICMP 因特网控制报文协议</h3><h3 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h3>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/30/LearnNet4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（三）——传输层</title>
      <link>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</link>
      <guid>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</guid>
      <pubDate>Mon, 27 Jan 2025 12:50:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解传输层的工作原理<br>（1）多路复用，解复用<br>（2）可靠数据传输<br>（3）流量控制<br>（4）拥塞控制<br>学习Internet的传输层协议：<br>（1）UDP无连接传输<br>（2）TCP面向连接的可靠传输<br>（3）TCP的可靠控制</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RDT，即reliable data transfer</p><p>物理层：传输实体，链路层：点到点，网络层：端到端，传输层：进程到进程，应用层：客户-服务</p><p>传输层提供进程与进程之间的，以message为单位的通信服务</p><p>传输协议运行在端系统。<br>发送方：讲应用层的报文分成报文段，然后传递给网络层。<br>接收方：将报文段重组成报文，然后传递给应用层。</p><p>有多个传输层协议可供应用选择</p><p>IP向上层提供的服务是不可靠的，TCP加强了可靠性；TCP向上层提供的服务是不安全的，SSL可以加强安全性。TCP无法降低延迟，无法增加带宽。TCP可以加强服务品质，但无法优化性能。</p><p>有连接的单位是分组，无连接的单位是数据报</p><p>字节流：Byte stream；数据报：Datagram；边界信息：Boundary information</p><p>best effort</p><h3 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h3><p>上一层实现IP的区分，到传输层引入端口，区分进程，完成源端的复用，到目标端的解复用。<br>复用是指多个tcp socket的信息都往下交,对方收到再分给不同的socket</p><p>共有65535个端口号</p><p>TCP和UDP使用端口的方式不一样</p><p>为了使穿过层间的信息最少，TCP和四元组相捆绑，即socket，socket包含四个信息：本地IP，本地port，对方IP，对方port。</p><p>socket是网络服务接口，对应进程</p><p>UDP的socket和本地IP，本地port相捆绑（二元组）。</p><p>应用往下传的是：（1）数据（2）socket（3）对方IP和对方port的地址（cad，指针）</p><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><p>应用：实时流媒体；事务性应用（一次往返）<br>UDP：用户数据报协议<br>UDP校验和：检测在被传输报文段中的差错。<br>残存错误：数据部分和EDC部分出错后依然符合校验规则。（概率小，但不可忽略）<br>发送方编码，接收方解码<br>进位回滚</p><h3 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt（可靠数据传输）在应用层、传输层和数据链路层都很重要。是网络Top10问题之一。<br>信道的不可靠特点决定了可靠数据传输协议的复杂性。</p><p>在可靠信道上传输：不出错，不丢失</p><p>超时重传机制（解决传错/丢失问题）</p><p>滑动窗口协议（slide window）：发送缓冲区。<br>发送窗口的最大值&lt;=发送缓冲区的值<br>发送窗口前沿移动的极限：不能超过发送缓冲区<br>接收窗口=接收缓冲区<br>GBN（Go-back-N）协议和SR(Selective Repeat)协议的异同：相同：发送窗口&gt;1，一次可发多个未经确认分组。区别：GBN接收窗口尺寸=1，只能顺序接收，一旦一个分组没有发成功，要返回错误的地方重发；SR接收窗口尺寸&gt;1，可乱序接收，发送未成可以选择性重发错的中间某一项。</p><p>GBN适用范围：出错率低（SR复杂易出错）<br>SR适用范围：链路容量大（延迟大，带宽大）<br>GBN:以时间换空间  SR: 以空间换时间</p><h3 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h3><p>（段结构；可靠数据传输；流量控制；连接管理）<br>TCP概述：点对点，可靠的、按顺序的字节流，管道化（流水线），发送和接收缓存，全双工数据，面向连接，有流量控制</p><p>MSS:Maximum Segment Size, 最大报文段大小，≤当然可以</p><p><strong>TCP往返延时（RTT）和超时</strong><br>在局域网中，两台计算机之间的往返延迟可以设置为固定的值；通过TCP处理进程通信的情况，超时时间是动态的、自适应的。<br>sampleRTT 当前采样RTT<br>estimatedRTT 移动平均RTT</p><p>TCP在IP不可靠服务的基础上建立了RTT</p><p>快速重传算法</p><p><strong>流量控制</strong><br>目的：防止发送方发的太快，超出了接收方的处理能力（防止接收方缓冲区溢出）。</p><p><strong>连接管理</strong><br>连接建立 和 连接拆除</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络拥塞的表现：分组丢失率变高，延迟更多<br>两种拥塞控制方法：端到端拥塞控制，网络辅助的拥塞控制<br>ATM网络：异步传输网络，它的数据单位是RM（信元）<br>ABR模式：弹性服务</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>如何检测拥塞：超时（拥塞）；收到某个段三个重复的ACK（轻微拥塞，没有发生拥塞，但是由于未通过差错检验，给源端一种发生拥塞的错觉）</p><p>rate=CongWin/RTT<br>两种控制同时考虑：接受窗口反映流量控制，拥塞窗口反映拥塞控制<br>拥塞控制的策略：慢启动（每个RTT，CongWin加倍；一开始慢速，但加速是指数性的）</p><p>拥塞控制的机制：线性增加-层性减-线性增加-层性减…<br>（改进）指数增加-线性增加-线性减-指数增加-线性增加-线性减…</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>传输层提供的服务：为应用进程间的逻辑通信服务（相对的，网络层提供的是主机和主机之间的通信服务），传输层协议包括TCP和UDP</li><li>原理：多路复用和解复用<br>区分进程使用的是：端口</li><li>无连接传输层协议UDP</li><li>可靠数据传输原理：停止等待协议（RDT），流水线协议（GBN：接收窗口=1，SR：接收窗口&gt;1）</li><li>TCP协议：TCP特性，面向连接的，进程到进程的；TCP报文段格式；TCO可靠传输机制；超时重传，快速重传；流量控制；连接管理</li><li>拥塞控制原理：拥塞原因，拥塞代价（方式：网络辅助e.g.ATM - 根据网络提供的反馈信息；端到端e.g.TCP - 超时和三个冗余ACK来判断拥塞）</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/27/LearnNet3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
