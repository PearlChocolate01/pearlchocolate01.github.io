<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Sat, 14 Jun 2025 13:09:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>02333 软件工程（六）——软件测试</title>
      <link>https://pearlchocolatezy.com/2025/06/13/02333-6/</link>
      <guid>https://pearlchocolatezy.com/2025/06/13/02333-6/</guid>
      <pubDate>Fri, 13 Jun 2025 13:47:56 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;调试是为了证明程序员的正确。&lt;/li&gt;
&lt;li&gt;调试的结果一般是不可预见的。&lt;/li&gt;
&lt;li&gt;调试是不受时间约束的。&lt;/li&gt;
&lt;li&gt;测试从一个侧面证明程序员的“失败”。&lt;/li&gt;
&lt;li&gt;测试以已知条件开始。&lt;/li&gt;
&lt;li&gt;静态软件评估技术：评审，代码</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>调试是为了证明程序员的正确。</li><li>调试的结果一般是不可预见的。</li><li>调试是不受时间约束的。</li><li>测试从一个侧面证明程序员的“失败”。</li><li>测试以已知条件开始。</li><li>静态软件评估技术：评审，代码检查（走查），静态分析（形式化证明）。</li><li>测试的首要目标是<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">预防错误</i>。</li><li>集成测试的目标是为了发现<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">与接口有关的错误</i>。</li><li>软件测试是一个有程序的过程，包括测试<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">设计</i>、测试<i id="answer9_2" class="answer" onclick="showOrHide('9_2')">执行</i>、测试<i id="answer9_3" class="answer" onclick="showOrHide('9_3')">结果比较</i>。</li><li>软件评估分为<i id="answer10_1" class="answer" onclick="showOrHide('10_1')">静态评估</i>，<i id="answer10_2" class="answer" onclick="showOrHide('10_2')">动态评估</i>。</li><li>依据程序逻辑结构的测试技术<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">白盒测试技术</i>。<br>包括：路径测试技术。</li><li>黑盒测试技术又称功能测试技术，包括：事务处理流程技术，定义域测试技术，状态测试技术；等价划分类，边界值分析，因果图。<br>黑盒测试定义：将被测软件看成黑盒子，只通过外部的输入和输出来发现软件中的错误。</li><li>测试度量：语句覆盖≤分支覆盖≤条件组合覆盖≤路径覆盖</li><li>条件覆盖：条件覆盖是白盒测试中的一种方法，其核心要求是设计测试用例，使得程序中每个判定表达式中的每个条件的所有可能结果（如真/假）至少被执行一次‌。</li><li>路径覆盖：路径覆盖是白盒测试中的一种方法，其核心要求是设计足够多的测试用例，确保程序的每条可能执行路径都至少被执行一次（若程序存在循环结构，则每个循环至少需经过一次）。</li><li>简述边界值分析在设计测试用例时可以遵循的原则：【难背】<br>（1）如果某个输入条件规定了输入值的范围，则应选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据；（1分）<br>（2）如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数作为测试数据；（1分）<br>（3）如果程序的规格说明中，输入域或输出域是有序集合，则选取集合的第一个元素、最后一个元素以及典型元素作为测试用例；（1分）<br>（4）如果程序中使用了内部数据结构，则应当选择这个内容数据结构的边界上的值作为测试用例；（1分）<br>（5）分析规格说明，找出其他可能的边界条件。（1分）</li><li>简述因果图方法生成测试用例的基本步骤：【难背】<br>（1）通过对软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符；（1分）<br>（2）分析原因与结果之间以及原因与原因之间对应的关系，并画出因果图；（1分）<br>（3）在因果图上标识出一些特定的约束或限制条件；（1分）<br>（4）把因果图转换成判定表；（1分）<br>（5）为判定表的每一列设计测试用例。（1分）</li><li>简述边界值分析与等价类划分技术的区别：【难背】<br>（1）边界值分析与等价类划分技术的区别在于：边界值分析着重边界的测试，应选取等于、刚刚大于或刚刚小于边界的值作为测试数据；（3分）<br>（2）而等价类划分是选取等价类中的典型值或任意值作为测试数据。（2分）</li><li>软件测试技术可分为两大类：<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">白盒测试技术</i>和<i id="answer18_2" class="answer" onclick="showOrHide('18_2')">黑盒测试技术</i>。</li><li>路径测试技术的基本要点：<br>（1）采用控制流程图来表达被测试程序模型,揭示程序中的控制结构。(2分)<br>（2）通过合理地选择一组穿过程序的路径,以达到某种测试度量。(2分)</li><li>白盒测试常用到的覆盖技术：语句覆盖，分支覆盖，条件覆盖，条件组合覆盖，路径覆盖。</li><li>在设计软件测试用例之前应<i id="answer22_1" class="answer" onclick="showOrHide('22_1')">建立环境模型</i>、<i id="answer22_2" class="answer" onclick="showOrHide('22_2')">被测对象模型</i>、<i id="answer22_3" class="answer" onclick="showOrHide('22_3')">错误模型</i>。</li><li>语句覆盖：至少执行程序中所有语句一次。</li><li>分支覆盖：至少将程序中的每个分支执行一次。</li><li>合理的测试序列：单元测试，集成测试，有效性测试，系统测试。<br>单元测试：考虑模块的局部数据结构，首先测试数据流，必须为每个模块单元测试开发<i id="answer25_1" class="answer" onclick="showOrHide('25_1')">驱动</i>模块和<i id="answer25_2" class="answer" onclick="showOrHide('25_2')">承接/桩</i>模块。<br>集成测试：发现与接口有关的错误，以主控模块作为测试驱动模块，主要缺点是需要设计承接模块，用于模块组合功能和软件结构检验的测试，每当组合一个模块要进行<i id="answer25_3" class="answer" onclick="showOrHide('25_3')">回归</i>测试，可采用<i id="answer25_4" class="answer" onclick="showOrHide('25_4')">自顶向下</i>和<i id="answer25_5" class="answer" onclick="showOrHide('25_5')">自底向上</i>两种集成方式递增组装软件。<br>有效性测试：发现软件实现功能与需求规格说明书不一致。</li><li>软件测试是一个有程序的过程，包括<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">测试设计</i>、<i id="answer26_2" class="answer" onclick="showOrHide('26_2')">测试执行</i>、<i id="answer26_3" class="answer" onclick="showOrHide('26_3')">测试结果比较</i>。</li><li>简述软件测试步骤中合理的软件测试序列及每个序列的关注点：<br>（1）合理的测试序列:单元测试、集成测试、有效性测试和系统测试。<br>（2）单元测试关注每个独立的模块。<br>（3）集成测试关注模块的组装。<br>（4）有效性测试关注检验是否符合用户所见的文档。<br>（5）系统测试关注检验习题中所有元素之间的协作是否合适,整个系统的性能、功能是否达到。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/13/02333-6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（六）——继承与多态</title>
      <link>https://pearlchocolatezy.com/2025/06/12/04747-06/</link>
      <guid>https://pearlchocolatezy.com/2025/06/12/04747-06/</guid>
      <pubDate>Thu, 12 Jun 2025 12:41:14 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;Java仅支持单重继承。&lt;/li&gt;
&lt;li&gt;如果一个类有父类，那么父类只能有一个，这条限制称为&lt;i id=&quot;answer2_1&quot; class=&quot;answer&quot; onclick=&quot;showOrHide(&#39;2_1&#39;)&quot;&gt;单重继承&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;子类不能继</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>Java仅支持单重继承。</li><li>如果一个类有父类，那么父类只能有一个，这条限制称为<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">单重继承</i></li><li>子类不能继承父类的构造方法。</li><li>允许用已定义的类来定义一个新类，新类称作<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">子类</i>。</li><li>在Java中如何判断两个对象各个属性（成员变量）的值是否相同？<br>在Java中要判断两个对象的属性(成员变量)的值是否相同,需要在类声明中对equals方法进行覆盖,即重新修改这个方法,重写的equals方法中对对象中的值是否相等一一判断。</li><li>请说明父类与子类的联系与区别：<br>大的更一般的类可以看作父类,包含在其中的特殊的、具体的类是子类。<br>子类与父类的关系是:<strong>子类对象“is a”父类对象。</strong>从层次关系上讲,子类继承自父类,父类的对象引用可以指向子类对象,反之则不行。从成员上讲,子类可以比父类拥有更多的成员变量和成员方法,这些成员变量和成员方法是子类独有的,父类不具有也不能使用。但是反过来,父类中具有公共、保护权限的成员变量和成员方法同时也属于子类,子类可以使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类对象引用指向子类对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">a.eat(); <span class="comment">// 输出：Dog is eating</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>判断父类变量指向的是不是子类实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog)&#123;<span class="comment">//判断父类变量指向的是不是子类实例</span></span><br><span class="line">Dog d=(Dog) a;<span class="comment">//将父类变量转换成对应的子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Java允许将一个子类的对象赋给父类的变量（子类对象可以作为父类对象使用），这称为<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">对象转型（向上转型）</i>。</li><li>什么是继承：<br>将一个已有类中的数据和方法保留,并加上自己特殊的数据和方法,从而构成一个新类。</li><li>简述通过继承，子类可以获得的好处：【难背】<br>（1）子类可以拥有父类的所有属性和方法(2分)；<br>（2）也可以扩展原有代码、生成新的类、原有代码可以不必重写(1分)。</li><li>类A某个成员变量的类型是类B，则类A<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">has a</i>类B。</li><li>方法覆盖：要求子类定义方法所用的名字、返回类型及参数列表和父类中的方法使用的完全一样，也就是具有相同的方法签名，从逻辑上看就是子类方法中的成员方法将隐藏父类中的同名方法。<br>名词解释：使用类的继承关系，可以从已有的类产生新的类。在原有特性的基础上，增加了新的特性。父类中原有的方法可能不能满足新的要求，因此需要修改父类中已有的方法。</li><li>重载的方法属于同一个类，覆盖的方法分属于<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">父类、子类</i>。</li><li>简述关键字super的作用：【难背】<br>如果子类重写了父类中的方法，但在子类中还想使用父类中被隐藏的方法，可以使用super关键字，另外，在子类的构造方法中也可以使用super关键字，其功能为调用父类的构造方法。<br>使用super关键字时要注意两个问题：<br>首先，使用super.method()调用父类中的方法method(),将执行父类方法中的所有操作，其中可能会包括一些原本不希望进行的操作，所以调用时要谨慎。<br>其次，由继承性的机制可以知道，super.method()语句所调用的方法不一定是在父类中加以描述的，它也可能是父类从它的祖先中继承来的。因此，有可能需要按继承层次关系依次向上查询才能找到。</li><li>方法覆盖的两条原则：【难背】<br>（1）覆盖方法的允许范围不能小于原方法。<br>（2）覆盖方法所抛出的异常不能比原方法多。</li><li>如果一个抽象类除了抽象方法外什么都没有，则使用接口更合适。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>用关键字<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">final</i>修饰的类是终极类，不能有子类。</li><li>接口及其实现的基础语法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>什么是抽象类、抽象方法？在使用过程中有什么注意事项？【难背】<br>定义时只定义了方法但没有定义具体实现的类称为抽象类，在Java中通过关键字abstract把一个类定义为抽象类。<br>每一个未被定义具体实现的方法也用关键字abstract修饰，这样的方法称为抽象方法，只有抽象类才有抽象方法。<br>在使用抽象类和抽象方法时要注意的事项有：不能用抽象类作为模板创建对象，必须定义抽象类的子类后，用子类作为模板才能创建实例。对于抽象方法不能进行调用，子类将抽象方法实现以后才可以调用。</li><li>接口中所有的方法都是抽象方法，没有方法体。</li><li>一个类可以实现多个接口，从而实现了多重继承。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, ..., 接口N &#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口可以定义自己的成员变量和方法，但成员变量必须赋初值且不可改变（系统会自动添加final和static关键字）。</li><li>实现接口必须实现该接口的所有方法。</li><li>接口可以继承。</li><li>简述抽象类与接口的联系与区别：【难背】<br>抽象类是指类中定义了方法但没有具体实现的类，抽象类代表一些基本行为，但又无法或不宜在这个类中对这些行为加以具体实现，而希望在子类中根据实际情况去实现。<br>接口是体现抽象类功能的另一种方式，可将其想象为一个“纯”的抽象类，接口中所有的方法都是抽象方法，都没有方法体，接口与抽象类都用来定义多个类的共同属性。<br>接口还可以实现与抽象类不同的功能，具体来说，Java不支持多重继承，一个类只能从唯一的一个类继承，但允许一个类实现多个接口，从而实现了多重继承的功能，并具有更加清晰的结构。</li><li>一个接口能够包含的元素有<i id="answer27_1" class="answer" onclick="showOrHide('27_1')">成员变量</i>，默认修饰符是<i id="answer27_2" class="answer" onclick="showOrHide('27_2')">abstract</i>；<i id="answer27_3" class="answer" onclick="showOrHide('27_3')">成员方法</i>，默认修饰符是<i id="answer27_4" class="answer" onclick="showOrHide('27_4')">static,final</i>。</li><li>子类中修改父类中已有的同名方法，称为方法<i id="answer28_1" class="answer" onclick="showOrHide('28_1')">覆盖/重写</i>。</li><li>同一个类中，具有不同签名的同名方法是<i id="answer29_1" class="answer" onclick="showOrHide('29_1')">重载</i>方法。</li><li>接口中的抽象方法不能是私有或受保护的方法。</li><li>Java中实现多重继承的机制是<i id="answer31_1" class="answer" onclick="showOrHide('31_1')">使用接口</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/12/04747-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（五）——面向对象方法RUP</title>
      <link>https://pearlchocolatezy.com/2025/06/11/02333-5/</link>
      <guid>https://pearlchocolatezy.com/2025/06/11/02333-5/</guid>
      <pubDate>Wed, 11 Jun 2025 08:59:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[面向对象方法RUL] --&gt; A1[RUP的特点]
    A --&gt; A2[核心工作流]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[面向对象方法RUL] --> A1[RUP的特点]    A --> A2[核心工作流]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><p>RUP：Rational Unified Process，统一软件开发过程</p><ol><li>面向对象符号体系。</li><li>三个突出特征：以<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">用况</i>为驱动、以<i id="answer1_2" class="answer" onclick="showOrHide('1_2')">体系结构</i>为中心的<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">迭代、增量式</i>开发。</li><li>RUP四个阶段：初始阶段 -&gt; 精化阶段 -&gt; 构造阶段 -&gt; 移交阶段。<br>精化阶段：估算成本进度，减少风险，至少要完成的阶段。<br>构造阶段：形成最终的系统体系结构基线，确保产品可以开始向客户交付，具有初始操作能力。<br>移交阶段：确保有一个实在的产品发布给客户。</li><li>一个核心工作流包括：需求获取、分析、设计、实现、测试。</li><li>RUP利用UML提供的术语和工具定义了<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">需求获取层</i>、<i id="answer5_2" class="answer" onclick="showOrHide('5_2')">系统分析层</i>、<i id="answer5_3" class="answer" onclick="showOrHide('5_3')">设计层</i>、<i id="answer5_4" class="answer" onclick="showOrHide('5_4')">实现层</i>，并给出了各层模型间的映射。</li><li>简述RUP设计模型以及包含的元素：【难背】<br>RUP的设计模型是RUP设计的主要结果，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入。（1分）<br>它包括以下元素：<br>（1）设计子系统和服务子系统，以及它们的依赖、接口和内容；（1分）<br>（2）设计类，以及它们具有的操作、属性、关系及其实现需求；（1分）<br>（3）用况细化；（1分）<br>（4）体系结构描述。（1分）</li><li>为什么UML要同RUP一起才称得上是软件开发的方法学？【难背】<br>（1）一种软件开发方法学，至少由三部分组成：用于表达基本信息的术语，用于组织基本信息的表达格式，用于在不同抽象层之间进行映射的过程指导。<br>（2）UML仅包含前两方面的内容，因此它只是一种可视化的建模语言，而不是一种特定的软件开发方法学。<br>（3）RUP给出的是一种基于UML的过程指导，满足软件开发方法学的第三项内容。<br>因此UML要同RUP一起才称得上是一种软件开发的方法学。</li><li>RUP的<i id="answer8_1" class="answer" onclick="showOrHide('8_1')">部署模型</i>包含节点和主动类到节点的初始映射。</li><li>RUP从两个角度描述软件结构：系统设计模型，表达物理分布的<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">系统部署模型</i>。</li><li>简述建造一个系统需求获取模型的活动（RUP创建系统用况模型应进行的活动，0.5分/个），以及各活动的输入和输出：【难背】<br>（1）活动:发现描述参与者和用况。输入:业务模型或领域模型,补充需求,特征表。输出:用况模型[概述],术语表;(1分)<br>（2）活动:赋予用况优先级。输入:用况模型[概述],补充需求,术语表。输出:体系结构描述[用况模型视角];(1分)<br>（3）活动:精化用况。输入:用况模型[概述],补充需求,术语表。输出:用况[精化];(1分)<br>（4）活动:构造人机接口原型（用户界面原型）。输入:用况[精化],用况模型[概述],补充需求,术语表。输出:人机接口原理;(1分)<br>（5）活动:用况模型结构化。输入:用况[精化],用况模型[概述],补充需求,术语表。输出:用况模型[精化]。(1分)</li><li>RUP中创建系统的分析模型，一般应进行<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">体系结构</i>分析、<i id="answer11_2" class="answer" onclick="showOrHide('11_2')">用况</i>分析、<i id="answer11_3" class="answer" onclick="showOrHide('11_3')">类的</i>分析、<i id="answer11_4" class="answer" onclick="showOrHide('11_4')">包的</i>分析4项活动。</li><li>RUP中的分析类分为：<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">边界类</i>、<i id="answer12_2" class="answer" onclick="showOrHide('12_2')">实体类</i>、<i id="answer12_3" class="answer" onclick="showOrHide('12_3')">控制类</i>。</li><li>简述RUP需求获取的基本步骤：【难背】<br>（1）列出候选的特征、(1 分)<br>（2）理解系统语境、(1 分)<br>（3）捕获系统功能需求、(2 分)<br>（4）捕获非功能需求。 (1 分)</li><li>RUP采用<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">Use Case</i>技术来获取需求，其目标是使用UML中的<i id="answer14_2" class="answer" onclick="showOrHide('14_2')">用况</i>、参与者以及依赖等术语来抽象客观实际问题，形成系统的需求获取模型。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/11/02333-5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（五）——数组和字符串</title>
      <link>https://pearlchocolatezy.com/2025/06/10/04747-05/</link>
      <guid>https://pearlchocolatezy.com/2025/06/10/04747-05/</guid>
      <pubDate>Tue, 10 Jun 2025 12:44:04 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;5-1-数组&quot;&gt;&lt;a href=&quot;#5-1-数组&quot; class=&quot;headerlink&quot; title=&quot;5.1 数组&quot;&gt;&lt;/a&gt;5.1 数组&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数组是相同类型的元素按一定顺序排列的集合。&lt;/li&gt;
&lt;li&gt;数组声明时不用说明容量，声明时不分</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><ol><li>数组是相同类型的元素按一定顺序排列的集合。</li><li>数组声明时不用说明容量，声明时不分配内存。</li><li>声明数组的格式：<code>类型 数组名[];</code></li><li>数组初始化的两种方法：静态初始化，动态初始化。</li><li>初始化数组的格式：<br>静态初始化：<code>类型 数组名[]=&#123;值1,值2,...&#125;;</code><br>动态初始化：<code>类型 数组名[]=new 类型[数组大小];</code></li><li>简述声明数组和创建数组的区别：<br>（1）声明数组是指定义一个数组，定义的格式为：类型 数组名[]。声明数组时不会为数组分配内存，声明的数组名只是引用变量，用来指向一个数组，还不能访问数组的任何元素。<br>（2）创建数组是指对声明过的数组进行分配空间，对其进行初始化，给数组的元素赋初值，创建数组以后可以使用数组的元素。数组创建分为静态初始化和动态初始化两种。静态初始化使用一对大括号{ }将初值括起来，每个元素对应一个引用。动态初始化使用运算符new为数组分配空间。</li><li>访问数组元素时需注意哪些问题：<br>（1）数组必须已经初始化,具有内存空间。<br>（2）访问数组元素通过数组名加上下标,即数组 名[下标数字]的形式进行,下标数字是从0 开始。<br>（3）数组初始化后其大小是固定不变的,所以访 问数组元素时需注意下标数字的必须小于数组的 length属性的值,否则会抛出越界异常。</li></ol><h3 id="5-2-字符串"><a href="#5-2-字符串" class="headerlink" title="5.2 字符串"></a>5.2 字符串</h3><ol><li>“==”与equals()的区别：<br>运算符“==”判定两个字符串对象是否是同一实例，内存中的存储空间是否相同。<br>方法equals()判定两个字符串的值是否相等。</li><li>substring(3,5)表示从位置3开始，到位置5结束，不含位置5。</li><li>简述String类和StringBuffer类在对象分配内存时的区别：<br>String类分配内存时,按照对象中所含字符的实际个数等量分配。<br>StringBuffer类对象分配内存时,除去字符所占空间外,再另加16个字符大小的缓冲区。</li><li>StringBuffer类用于处理<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">可变字符串</i>。</li><li>用字符数组创建字符串语句：<code>String s=new String(chars);</code></li></ol><h3 id="5-3-Vector类"><a href="#5-3-Vector类" class="headerlink" title="5.3 Vector类"></a>5.3 Vector类</h3><ol><li>Vector类的实例可以保存不同类型的数据。</li><li>Vector类可认为是动态数组，空间大小可变。</li><li><code>Vector v=new Vector(100,50);</code>50表示在v初始化的空间用尽后以50为单位递增空间。</li><li>简述数组与Vector的显著区别：<br>（1）数组初始化(创建)后其容量大小固定不变,不能缩小或追加空间。而 Vector类实例的大小可以根据需要来改变。<br>（2）Vector保存的数据类型与数组也不一样,数组只能保存同一种数据,而 Vector实例可以保存不同类型的数据。<br>（3）数组元素的类型可以是基本数据类型,也可以是类对象,而 Vector类实例只能保存类的对象,不能保存基本类型的数据。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/10/04747-05/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（四）——面向对象程序设计</title>
      <link>https://pearlchocolatezy.com/2025/06/08/04747-04/</link>
      <guid>https://pearlchocolatezy.com/2025/06/08/04747-04/</guid>
      <pubDate>Sun, 08 Jun 2025 09:06:42 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;类中可以不显示定义构造方法。&lt;br&gt;（可以不手动写，编译器会自动生成一个无参的）&lt;/li&gt;
&lt;li&gt;可以创建不带参数的构造方法。&lt;/li&gt;
&lt;li&gt;构造方法不能从父类继承。&lt;/li&gt;
&lt;li&gt;构造方法有返回值。（可以是对象的实例自己，可以是void）&lt;/li&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>类中可以不显示定义构造方法。<br>（可以不手动写，编译器会自动生成一个无参的）</li><li>可以创建不带参数的构造方法。</li><li>构造方法不能从父类继承。</li><li>构造方法有返回值。（可以是对象的实例自己，可以是void）</li><li>构造方法的调用方式与普通方法不同。</li><li>方法签名包括：方法名，参数列表。</li><li>重载方法的返回值可以相同也可以不同。</li><li>重载方法返回值类型不可作为区分重载方法的依据。<br>原因：选择哪个重载方法是在执行方法之前进行的，此时还不知道返回值是什么，所以不能确定返回值的类型。</li><li>如果方法的形参是引用类型，调用方法时，实参传递的内容：<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">将实参的首地址传给形参</i>。从方法返回时，对实参的影响：<i id="answer9_2" class="answer" onclick="showOrHide('9_2')">对形参的修改也即修改了实参</i>。</li><li>静态方法不能直接引用实例变量。</li><li>被整个类共享的变量为<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">静态变量</i>。</li><li>不需要创建对象就可以调用的方法为<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">静态变量</i>。</li><li>int,char,void,byte的包装类分别为<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">Interger</i>，<i id="answer13_2" class="answer" onclick="showOrHide('13_2')">Character</i>，<i id="answer13_3" class="answer" onclick="showOrHide('13_3')">Void</i>，<i id="answer13_4" class="answer" onclick="showOrHide('13_4')">Byte</i>。</li><li>简述包装类的用途：<br>当想用处理对象一样的方式来处理基本类型的数据时，必须将基本类型值包装成一个对象。</li><li>包装类定义在<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">java.lang</i>包中。</li><li>自动将基本数据类型转换为对应的包装类的过程为<i id="answer16_1" class="answer" onclick="showOrHide('16_1')">装箱</i>。</li><li>自动将包装类的对象转换为基本类型的过程为<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">拆箱</i>。</li><li>类中定义的静态成员，用static修饰，只分配一次内存，不同实例的该成员共享一块内存。<br>（Java中没有全局变量的概念，所有变量都必须属于某个类。）</li><li>类中含有的两部分元素：数据成员变量，成员方法。</li><li>类的修饰词<br>private：只能被类内部访问。<br>protected：只能被类所在包访问。（默认）<br>public：公共的，可以被所有对象访问。</li><li>子类构造方法调用父类构造方法，调用语句必须写在子类构造方法的第一行。</li><li>Java程序中源文件名必须根据文件中的<i id="answer22_1" class="answer" onclick="showOrHide('22_1')">共有类名</i>来定义。</li><li>简述构造方法重载：<br>在进行对象实例化时可能遇到许多不同情况，要求针对给定的不同参数，调用不同的构造方法，此时可以通过在一个类中同时定义若干个构造方法来实现。</li><li>简述类的概念：<br>现实世界中存在很多同类的对象，它们来自同一种原型或模板，或具有一些共性，可抽象提取为类。</li><li><i id="answer25_1" class="answer" onclick="showOrHide('25_1')">new</i>运算符可自动调用构造方法。</li><li>调用方法时传给方法的值称为<i id="answer26_1" class="answer" onclick="showOrHide('26_1')">实参</i>。</li><li>Java中实例变量与静态变量的区别是什么？<br>Java运行中系统生成类的每个实例对象时,会为每个对象的实例变量分配内存,然后才可以访问实例变量,而且不同对象的内存空间相互独立。<br>静态变量是不依赖于特定对象,系统只在类定义时为静态成员分配内存,此时还没有创建对象,也没有对对象进行实例化。以后生成该类的实例对象时,将不再为静态成员分配内存,不同对象的静态变量将共享同一块内存空间。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/08/04747-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（四）——面向对象方法UML</title>
      <link>https://pearlchocolatezy.com/2025/06/05/02333-4/</link>
      <guid>https://pearlchocolatezy.com/2025/06/05/02333-4/</guid>
      <pubDate>Thu, 05 Jun 2025 09:50:21 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[面向对象方法UML] --&gt; A1[UML术语表]
    A --&gt; A2[UML的模型表达格式]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mer</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[面向对象方法UML] --> A1[UML术语表]    A --> A2[UML的模型表达格式]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><h3 id="4-1-UML术语表"><a href="#4-1-UML术语表" class="headerlink" title="4.1 UML术语表"></a>4.1 UML术语表</h3><ol><li>UML表达关系的术语中，包含是一种特殊的<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">依赖</i>。</li><li><i id="answer2_1" class="answer" onclick="showOrHide('2_1')">UML</i>是面向对象技术发展中一个重要的里程碑。</li><li>关联的多重性是指类中对象参与一个关联的数目。</li><li>术语<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">依赖</i>可用于表达客观世界中各种各样事物之间的关系。</li><li>UML术语表：<br><code>+</code>：公共可见的（public）<br><code>-</code>：对该关联之外的任何对象而言，该端的对象是不可见的<br><code>#</code>：该端的对象只有另一端的“子孙”是可以访问的（protected）<br><code>~</code>：在同一包中声明的类是可访问的</li><li>接口使用注意以下问题：（选择）<br>（1）接口只可以被其他类目使用，而其本身不能访问其他类目。<br>（2）接口描述类的外部可见操作，通常是该类的一个特定有限行为。<br>（3）接口不描述其中操作的实现，也没有属性和状态。<br>（4）接口之间没有关联、泛化、实现和依赖，但可以参与泛化、实现和依赖。</li><li>为了描述模型化包之间的关系，UML给出了<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">引入</i>依赖和<i id="answer7_2" class="answer" onclick="showOrHide('7_2')">访问</i>依赖。</li><li>UML关系术语：<br><font color="midnightblue">关联：表示类与类之间的联系。方向箭头实线表示。<br>泛化：表示一般与特殊的关系。用带空心三角箭头的直线表示。<br>细化：一个类目规约了保证另一个类目执行的契约。<br>依赖：表示一个类使用另一个类的对象。用带箭头的虚线表示。<br>聚合：表示整体与部分的关系，部分可独立存在。用带空心菱形的直线表示。<br>组合：表示整体与部分的关系，部分对象与整体对象有相同的生命周期。用带实心菱形的直线表示。<br>实现：表示类与接口的关系。用带箭头的虚线表示。</font><br><strong>关联、泛化、细化都是一类特定的依赖。</strong></li><li>在类的关联中，对于一个给定的类目，可以通过<i id="answer9_1" class="answer" onclick="showOrHide('9_1')">导航</i>。</li><li>用于描述关联的一定内涵的术语是<i id="answer10_1" class="answer" onclick="showOrHide('10_1')">关联名</i>。</li><li>关联的一端的类目对另一端的类目的一种呈现，称为<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">角色</i>。</li><li>泛化的四个约束：<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">完整</i>、<i id="answer12_2" class="answer" onclick="showOrHide('12_2')">不完整</i>、<i id="answer12_3" class="answer" onclick="showOrHide('12_3')">互斥</i>、<i id="answer12_4" class="answer" onclick="showOrHide('12_4')">重叠</i>。</li><li>类是一组具有相同<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">属性</i>、<i id="answer13_2" class="answer" onclick="showOrHide('13_2')">操作</i>、<i id="answer13_3" class="answer" onclick="showOrHide('13_3')">关系</i>、<i id="answer13_4" class="answer" onclick="showOrHide('13_4')">语义</i>。</li><li>类的泛化关系中，如果一个类有多个父类，则说明它使用了<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">语义</i>。</li><li>UML中，实线椭圆表示<i id="answer15_1" class="answer" onclick="showOrHide('15_1')">用况</i>。</li><li>一种软件开发方法学至少由三部分组成：<br>（1）用于表达基本信息的术语<br>（2）用于组织基本信息的表达格式<br>（3）不同抽象层之间进行映射的过程指导</li><li>类中对象参与一个关联的数目，称为该关联的<i id="answer17_1" class="answer" onclick="showOrHide('17_1')">多重性</i>。</li><li>协作是一个交互，涉及交互<i id="answer18_1" class="answer" onclick="showOrHide('18_1')">各方</i>、交互<i id="answer18_2" class="answer" onclick="showOrHide('18_2')">方式</i>、交互<i id="answer18_3" class="answer" onclick="showOrHide('18_3')">内容</i>三要素。</li><li>节点具有<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">记忆</i>能力和<i id="answer19_2" class="answer" onclick="showOrHide('19_2')">处理</i>能力。</li><li>UML表达客观事物之间关系的术语及定义 <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）为了表达各类客观事物之间的关系，UML给出了表达关系的基本术语：关联、泛化、细化、依赖；（1分）<br>（2）关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。（1分）泛化是一般性类目和它的较为特殊性类目之间的一种关系。（1分）细化是类目之间的语义关系，其中一个类目规约了保证另一个类目执行的契约。（1分）依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。（1分）</li></ol><h3 id="4-2-UML的模型表达格式"><a href="#4-2-UML的模型表达格式" class="headerlink" title="4.2 UML的模型表达格式"></a>4.2 UML的模型表达格式</h3><ol><li>用况图（USE CASE图）：可以表达系统功能模型的图形化工具（背）；可用于概念模型和软件模型的动态结构。</li><li>类图：可用于描述概念模型和软件模型的静态结构。</li><li>状态图：从一个状态到另一个状态的控制流建模工具；支持生存周期的建模。</li><li>交互图：支持系统交互的建模。</li><li>UML两类图形化工具：结构图，行为图。</li><li>创建一个系统类图的步骤：（选择）<br>（1）模型化待建系统中的概念，形成类图中的基本元素；<br>（2）模型化待建系统中的各种关系，形成该系统的初始类图；<br>（3）模型化系统中的协作，给出该类图的最终类图；<br>（4）模型化逻辑数据库模式。</li><li>用况图的六个模型元素：主题、用况、参与者、关联、泛化、依赖。（背）<br>用况图模型元素之间的关系：用况图中，关联是操作者和用况之间的唯一关系。操作者之间的关系可以是泛化。用况之间可以有泛化、扩展和包含，其中包含和扩展是依赖的变体。（背）</li><li>UML中的事件类型：信号事件，调用事件，时间事件，变化事件。（背）<br>UML中的事件通常分为：内部事件，外部事件。</li><li>用况之间的关系：扩展，包含，泛化。</li><li>类图包含：类，接口，关联，泛化，依赖等关系。</li><li>简述状态图中的一个转换涉及的内容：<br>（1）源状态：发生状态转移的那个状态。<br>（2）转移触发器：满足其监护条件，则使状态发生转移。<br>（3）监护条件：布尔表达式，表达式为真，则触发转移；表达式为假，则不发生转移。<br>（4）效应：一种可执行的行为。<br>（5）目标状态：转移完成后所处的状态。</li><li>状态图的状态：初态，终态，通常状态。</li><li>简述创建系统类图所涉及的工作：<br>（1）创建一个系统的类图依赖于所使用的方法学；（1分）<br>（2）涉及以下4方面的工作：<br>模型化待建系统中的概念，形成类图中的基本元素；（1分）<br>模型化待建系统中的各种关系，形成该系统的初始类图；（1分）<br>模型化系统中的协作，给出该系统的最终类图：（1分）<br>模型化逻辑数据库模式。（1分）</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/05/02333-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（三）——流程控制语句</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-03/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-03/</guid>
      <pubDate>Mon, 02 Jun 2025 06:53:08 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;简述Java中异常的分类及其概念：&lt;br&gt;Java中异常可分为三类,分别为：受检异常、运行时异常、错误。&lt;br&gt;受检异常是程序执行期间发生的严重事件的后果。&lt;br&gt;运行时异常通常是程序中逻辑错误的结果。&lt;br&gt;错误是指发生了不正确的情况,这些情况都比较严重,一般</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>简述Java中异常的分类及其概念：<br>Java中异常可分为三类,分别为：受检异常、运行时异常、错误。<br>受检异常是程序执行期间发生的严重事件的后果。<br>运行时异常通常是程序中逻辑错误的结果。<br>错误是指发生了不正确的情况,这些情况都比较严重,一般程序很难处理。</li><li>如果程序中有package语句，那么该语句一定是源文件中的<i id="answer2_1" class="answer" onclick="showOrHide('2_1')">第一条非注释语句</i>。</li><li>Java中，通常用<i id="answer3_1" class="answer" onclick="showOrHide('3_1')"> classpath （环境变量）</i>指定搜寻包的路径。</li><li>简述package语句和import语句的区别：<br>(1)package语句为包语句,每个文件最多只有一个,且必须放在文件开始的地方(2分)。<br>(2)import语句为引入语句,可以没有,也可以有多个,如果有,必须放在所有类定义的前面(2分)</li><li>Java规定switch语句不允许使用浮点型或long型,表达式的结果必须是int型或char型,当用byte型或short型时,要进行提升。</li><li>Java中有哪几种流程控制语句：赋值语句、分支语句、循环语句、跳转语句。</li><li>continue语句的作用是<i id="answer7_1" class="answer" onclick="showOrHide('7_1')">立即结束本次循环</i>。</li><li>while语句和do语句的区别：<br>while语句先计算条件表达式的值,当值为真时,重复执行循环体语句,直到条件表达式为假时结束。如果第一次检查时条件表达式为假,则循环体语句一次也不执行。<br>do语句首先执行循环体语句,然后判定条件表达式的值,当值为真时,重复执行循环体语句,直到表达式的值为假时结束循环。不论条件表达式的值是真是假,do循环中的循环体都至少执行一次。</li><li>分支语句有：if，switch。</li><li>简述break语句的基本用法：<br>break语句可用于3类语句中：<br>第一类是在 switch语句中,第二类是在for、while及do等循环体中,第三类是在语句块中。<br>在switch语句及循环体语句中, break的语义是跳过本块中余下的所有语句, 转到块尾, 执行其后的语句。第三种使用方法是在块中和标号配合使用,其语义是跳出标号所标记的语句块,继续执行后面的语句。这种形式的break语句多用于嵌套块中,控制从内层跳到外层块之后。</li><li>Java语言中对异常进行处理时，不论是否捕获到异常，对于finally后面的语句都要执行。</li><li>Scanner类提供的许多方法，可用来方便地<i id="answer12_1" class="answer" onclick="showOrHide('12_1')">读入不同类型的输入值</i>。</li><li>一般地，如果一个方法引发了一个异常，而它自己又不处理，就要由<i id="answer13_1" class="answer" onclick="showOrHide('13_1')">调用者方法</i>。</li><li>Java把程序运行过程中遇到的非致命的、通过某种修正后程序还能继续执行的错误称为<i id="answer14_1" class="answer" onclick="showOrHide('14_1')">异常</i>。</li><li>简述程序员处理异常的方法：<br>Java语言中,程序员处理异常的方法有两种,一种是使用try块和 catch块,捕获到所发生的异常类,并进行相应的处理。<br>另一种方法是,程序员不在当前方法内处理异常,而是把异常抛出到调用方法中。当不能使用合理的方式来解决不正常或意外事件的情形下,才抛出异常。</li><li>说明嵌套的if语句中，if与else的个数应满足的条件及else语句的对应规则：<br>if的个数不少于else的个数。else与离它最近的未匹配的if语句对应。</li><li>简述try-catch块的处理过程：<br>（1）如果try块内没有发生异常，则try块内的语句全部执行，然后执行catch块后的语句。<br>（2）如果在try块内发生了某类异常，则执行立即转到对应的catch块，执行其中的语句去处理异常。<br>（3）不论是否捕获到异常，总要执行finally后面的语句。 </li><li>Java类库中的每个异常都有一个存取方法，可返回抛出异常时创建的描述字符串，该方法的名字是<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">getMessage()</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747-Java（二）——数据和表达式</title>
      <link>https://pearlchocolatezy.com/2025/06/02/04747-02/</link>
      <guid>https://pearlchocolatezy.com/2025/06/02/04747-02/</guid>
      <pubDate>Mon, 02 Jun 2025 06:52:59 GMT</pubDate>
      
        
        
      <description>&lt;ol&gt;
&lt;li&gt;包的命名要求：层次关系以点分割；通常用小写字母。&lt;/li&gt;
&lt;li&gt;Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）&lt;/li&gt;
&lt;li&gt;关键字的作用：&lt;br&gt;f</description>
        
      
      
      
      <content:encoded><![CDATA[<ol><li>包的命名要求：层次关系以点分割；通常用小写字母。</li><li>Java中标识符的命名规则：标识符是由字母、数字、下划线、美元符($)组成的字符串,且数字不能作为标识符的开头。标识符区分大小写,长度没有限制。（背）</li><li>关键字的作用：<br>final：用于声明常量变量。<br>static：用于声明静态变量或方法，表明该成员属于类本身不属于实例；不能用于声明常量变量，但<code>static final</code>结合使用可以定义常量变量。<br>protected：一种访问修饰符，用于控制类成员的访问权限，允许同一个包内或通过继承的子类访问该成员。<br>super：用于引用父类的成员。<br>class：用于定义类。<br>long：用于声明长整型变量。<br>new：用于创建新对象。</li><li>Java中的保留关键字：<br> 基本类型关键字<pre><code> byte short int long float double boolean char</code></pre> 控制语句关键字<pre><code> if else switch case default while do for break continue return</code></pre> 类、对象和接口定义关键字<pre><code> class interface extends implements this super new instanceof</code></pre> 包和导入关键字<pre><code> package import</code></pre> 访问控制关键字<pre><code> public protected private</code></pre> 异常处理关键字<pre><code> try catch finally throw throws</code></pre> 其他关键字<pre><code> static final abstract synchronized volatile transient native strictfp assert</code></pre> <a href="https://blog.csdn.net/weixin_48958956/article/details/140869156">Java关键字简介</a></li><li>简述包的概念及其命名要求：<br>（1）概念：包是类的容器,包的设计人员利用包来划分名字空间,以避免类名冲突。<br>（2）命名要求：包的名字有层次关系,各层之间以点分隔。包层次必须与Java开发系统的文件系统结构相同。通常包名中全部用小写字母。</li><li>Java程序的结构可以包含哪些内容：<br>一个Java程序的结构可以包含以下5方面的内容:<br>（1）package语句:包语句,每个文件最多只有一个,且必须放在文件开始的地方。<br>（2）import语句:引入语句,可以没有,也可以有多个,如果有 import语句,必须放在所有类定义的前面。<br>（3）具有 public权限的类定义:每个文件中最多有一个。<br>（4）类定义:每个文件中包含的非 public权限的类定义的个数没有限制。<br>（5）接口定义:每个文件中包含的接口定义个数没有限制。</li><li>变量取值范围<br>byte：-128~127<br>int：-2,147,483,648到2,147,483,647（$-2^(31)$~$2^(31)-1$）<br>long：-9,223,372,036,854,775,808（$-2^(63)$）到9,223,372,036,854,775,807（$2^(63)-1$）（‌字面量表示‌：若数值超出int范围（如大于2147483647），需在末尾添加L或l后缀（推荐大写L以避免与数字1混淆），例：long a=9876543210编译错误）</li><li>变量占用内存<br>byte：8位<br>short：16位<br>int：32位<br>long：64位</li><li>运算符优先级：括号 &gt; 基本运算 &gt; 移位 &gt; 大小对比 &gt; 逻辑&amp;&amp; &gt; 逻辑|| &gt; 三元运算</li><li><code>&gt;&gt;</code>是算术右移操作符，用于将二进制值向右移动指定位数，同时保留符号位。<br>例：求解<code>85&gt;&gt;1</code>：85转为二进制为（短除法）01010101，右移一位为00101010，再转为十进制（乘法）为42。<br>简单计算：右移一位相当于除以2，且向下取整。</li><li>表达式由<i id="answer11_1" class="answer" onclick="showOrHide('11_1')">运算符</i>和<i id="answer11_2" class="answer" onclick="showOrHide('11_2')">操作数</i>组成。</li><li>Java可以声明变量的地方及其区别：<br>声明变量的地方有两处,一处是在方法内,另一处是在类定义内。方法内定义的变量称为自动变量,也称为局部变量、临时变量或栈变量。类中定义的变量就是类的成员变量。</li><li><i id="answer13_1" class="answer" onclick="showOrHide('13_1')">null</i>表示引用不指向任何对象。</li><li>Java中数据类型转换的分类及其适用情况：<br>Java中的数据类型转换分为自动转换和强制转换两类。转换的一般原则是位数少的类型转换为位数多的类型,这称为自动类型转换。当位数多的类型向位数少的类型进行转换时,需要在程序中明确指明,这种转换称为强制类型转换。</li><li>基本数据类型什么时候有自己的内存空间：<br>基本数据类型的变量在声明之后,系统会自动在内存中分配相应的存储空间,即声明后即有自己的内存空间。</li><li>简述二元逻辑论中“短路”操作功能：<br>进行二元逻辑运算时,先计算运算符左侧表达式的值(2分)<br>如果使用该值能得到整个表达式的值,则跳过运算符右侧表达式的计算(1分),<br>否则计算运算符右侧表达式,并得到整个表达式的值(1分)。</li><li>Java中的基本数据类型byte、char、float、long和short在参与表达式计算时，能够进行自动类型变换的类型顺序依次是什么：依次是byte、short、char、long、float。</li><li><code>&amp;</code>按位与运算的结果是按位“皆1则1”。</li><li>Java逻辑与和逻辑或运算符有一个特殊的功能，当左侧操作数能决定表达式的值时，则跳过右侧操作数的运算。这个功能是<i id="answer19_1" class="answer" onclick="showOrHide('19_1')">短路操作</i>。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/02/04747-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（三）——结构化方法</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-3/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-3/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:51 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[结构化方法] --&gt; A1[结构化需求分析]
    A --&gt; A2[结构化设计]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[结构化方法] --> A1[结构化需求分析]    A --> A2[结构化设计]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><h3 id="3-1-结构化需求分析"><a href="#3-1-结构化需求分析" class="headerlink" title="3.1 结构化需求分析"></a>3.1 结构化需求分析</h3><ol><li>可以用于描述加工的是：<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">结构化自然语言</i>。</li><li>可以用于表示数据的静态结构的是：<i id="answer3_2" class="answer" onclick="showOrHide('3_2')">数据存储</i>。</li><li>结构化分析方法用于表达功能模型的工具：<i id="answer3_3_1" class="answer" onclick="showOrHide('3_3_1')">DFD图（数据流图、数据流程图）</i>。一般包含<i id="answer3_3_2" class="answer" onclick="showOrHide('3_3_2')">数据流</i>、<i id="answer3_3_3" class="answer" onclick="showOrHide('3_3_3')">数据存储</i>、<i id="answer3_3_4" class="answer" onclick="showOrHide('3_3_4')">加工</i>、<i id="answer3_3_5" class="answer" onclick="showOrHide('3_3_5')">数据源</i>、<i id="answer3_3_6" class="answer" onclick="showOrHide('3_3_6')">数据潭</i>等。</li><li>数据字典中定于数据结构的符号：m…n表示<i id="answer3_4_1" class="answer" onclick="showOrHide('3_4_1')">子界</i>，<code>&#123;&#125;</code>表示<i id="answer3_4_2" class="answer" onclick="showOrHide('3_4_2')">重复</i>。</li><li>结构化分析方法建模步骤：建立系统 -&gt; 建立层次 -&gt; 定义字典 -&gt; 加工。<br>（1）建立系统环境图,确定系统语境；（1分）<br>（2）自顶向下，逐步求精，建立系统的层次数据流图；（2分）<br>（3）定义数据字典；（1分）<br>（4）描述加工。（1分）</li><li>数据流图中，椭圆表示加工，双横线表示数据存储，方框表示数据源。</li><li>在结构化分析方法中，可采用<i id="answer3_7_1" class="answer" onclick="showOrHide('3_7_1')">结构化自然语言</i>、<i id="answer3_7_2" class="answer" onclick="showOrHide('3_7_2')">判定表</i>、<i id="answer3_7_3" class="answer" onclick="showOrHide('3_7_3')">判定树</i>描述加工。</li><li>结构化分析方法中，数据的变换单位是<i id="answer3_8" class="answer" onclick="showOrHide('3_8')">加工</i>。</li><li>事务流程图中，一个事务可以被另一个事务吸食，称为<i id="answer3_9" class="answer" onclick="showOrHide('3_9')">事务吸收</i>。</li><li>数据字典中，所有客体均可用<i id="answer3_10_1" class="answer" onclick="showOrHide('3_10_1')">顺序结构</i>、<i id="answer3_10_2" class="answer" onclick="showOrHide('3_10_2')">选择结构</i>、<i id="answer3_10_3" class="answer" onclick="showOrHide('3_10_3')">重复结构</i>三种基本结构表示。</li><li>结构化方法中，软件中具有特定标识的独立成分是<i id="answer3_11" class="answer" onclick="showOrHide('3_11')">模块</i>。</li><li>结构化方法包括：<i id="answer3_12_1" class="answer" onclick="showOrHide('3_12_1')">结构化分析方法</i>、<i id="answer3_12_2" class="answer" onclick="showOrHide('3_12_2')">结构化设计方法</i>、<i id="answer3_12_3" class="answer" onclick="showOrHide('3_12_3')">结构化程序设计方法</i>。</li></ol><h3 id="3-2-结构化设计"><a href="#3-2-结构化设计" class="headerlink" title="3.2 结构化设计"></a>3.2 结构化设计</h3><ol><li>耦合：不同模块间相互依赖程度。<br>耦合程度：内容耦合 &gt; 公共耦合 &gt; 控制耦合 &gt; 数据耦合<br>数据耦合：通过传递参数调用模块。<br>控制耦合：通过传递开关量（只有两种状态的离散信号）调用模块。<br>公共耦合：一组模块共同引用一个全局数据项。<br>内容耦合：一个模块直接操作另一个模块的数据，或一个模块不通过正常入口转入另一个模块。</li><li>内聚：一个模块内部各成分之间相互关联程度。<br>常见内聚类型：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。<br>内聚程度：功能内聚 &gt; 过程内聚 &gt; 逻辑内聚<br>通信内聚：一个模块内所有成分都生成或操作同一数据集。<br>偶然内聚：一个模块的各成分之间基本不存在任何关系。</li><li>提高模块独立性的原则：高内聚低耦合</li><li>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/06/01/02333-3/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程度高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </li><li>宽度：同一层次上模块总数的最大值。</li><li>深度：粗略标志一个系统的规模和复杂程度。</li><li>作用域：模块内受一个判定所“影响”的所有模块的集合。（背）</li><li>控制域：模块本身或所有直接或间接“从属”于它的模块的集合。（背）</li><li>作用域和控制域的启发式原则：尽力使模块的作用域在其控制域之内。</li><li>逐步求精：每一步是对上一步结果的细化。（使用N-S盒图）</li><li>详细设计工具：PFD图（程序流程图/框图）、N-S图（盒图）、PAD图（问题分析图）、PDL（类程序设计语言）。<br>N-S图：盒图，支持自顶向下逐步求精，严格控制一个处理到另一个处理的转移。<br>PAD图：问题分析图，用二维树结构表示程序控制流，面向高级语言。<br><strong>简述PDL特点：</strong><br>（1）PDL也称为伪码,它是一种用正文形式表示数据和处理过程的设计工具。<br>（2）PDL借用某种结构化程序设计语言(如Pascal或)的关键字作为语法框架,用于定义控制结构和数据结构。<br>（3）PDL通常使用某种自然语言(如汉语或英语)的词汇,灵活自由地表示实际的操作和判定条件。<br>（4）PDL可以作为注释工具直接插在源程序中间。</li><li>程序流程图优缺点<br>（1）优点：对控制流程描绘很直观，便于初学者掌握。<br>（2）缺点：不是一种逐步求精的工具；控制流不受约束，可能破坏好的系统结构；不易表示数据结构。</li><li>结构化程序设计：顺序结构、选择结构、循环结构。<br>选择结构的表达式：IF-THEN-ELSE。</li><li>针对具有变换型流图和事务型DFD的总体设计步骤：<br>（1）在软件总体设计中，通常以变换设计为主，事务设计为辅进行结构设计；（1分）<br>（2）首先利用变换设计，把软件系统分为输入，中心变换和输出3个部分，设计上层模块；（1分）<br>（3）然后根据各部分数据流图的结构特点，适当地利用变换设计和事务设计进行细化，得到初始的模块结构图；（1分）<br>（4）再按照“高内聚低耦合”的原则，对初始的模块结构图进行精化，得到最终的模块结构图。（2分）</li><li>变换设计的基本步骤：<br>（1）设计准备，复审并精化系统模块；（1分）<br>（2）确定输入、变换、输出这三部分之间的边界；（1分）<br>（3）设计系统模块结构图的顶层和第一层；（1分）<br>（4）自顶向下，逐步求精。（2分）</li><li>结构化方法的不同阶段：可行性研究阶段、需求分析阶段、总体设计阶段、详细设计阶段、编码实现阶段、测试阶段、维护阶段。<br>总体设计阶段使用HIPO图，由IPO图和H图（层次图）组成。<br>层次图：适合自顶向下的软件设计过程。<br><strong>总体设计阶段内的三个阶段：</strong> <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</li><li>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> <br>（1）系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。（1分）<br>（2）功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。（1分）<br>（3）接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。（1分）<br>（4）数据库设计：设计核心数据的逻辑结构。（1分）<br>（5）测试需求等。（1分）</li><li>待建系统的数据流图两种类型：变换型数据流图、事务型数据流图。</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程（二）——软件需求与软件需求规约</title>
      <link>https://pearlchocolatezy.com/2025/06/01/02333-2/</link>
      <guid>https://pearlchocolatezy.com/2025/06/01/02333-2/</guid>
      <pubDate>Sun, 01 Jun 2025 12:15:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR
    A[软件需求] --&gt; A1[需求概念]
    A --&gt; A2[需求获取]
    A --&gt; A3[需求规约]&lt;/pre&gt;&lt;br&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p><pre class="mermaid">graph LR    A[软件需求] --> A1[需求概念]    A --> A2[需求获取]    A --> A3[需求规约]</pre><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div></p><ol><li>软件需求分为：功能需求（主体），非功能需求。</li><li>接口需求的分类：用户接口，硬件接口，软件接口，通信接口，内存约束，运行，地点需求。</li><li>单个需求必须具有的基本性质：必要的、无歧义的、可测的、可测量的。</li><li>需求分析的三大挑战：问题空间理解，人与人之间的通信，需求的变化性。</li><li>初始发现需求的常用技术：自悟，交谈（提问/回答），观察（可能引起抵触），小组会，提炼（已有文档）。</li><li>验证需求是否正确的技术：自悟、提炼。</li><li>需求规约的定义：需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，它表达了一个软件产品/系统的概念模型。</li><li>软件需求规约的性质：重要性，稳定性，可修改性，完整性（基本），一致性。</li><li>需求规约的三种形式：<br>（1）非形式化的需求规约：基于自然语言来编制需求规约。<br>（2）半形式化的需求规约：以半形式化符号体系（术语表）等表达需求规约。<br>（3）形式化规约：基于良构数学概念符号体系来编制需求规约。</li><li>需求规约在项目开发中的基本作用：<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现；（1分）<br>（2）对于项目的其余大多数工作，需求规约是一个管理控制点；（1分）<br>（3）对于产品/系统的设计，需求规约是一个正式的、受控的起始点；（1分）<br>（4）是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档：初始测试计划和用户系统操作描述。（2分）</li><li>需求规约与项目需求有哪些不同？<br>（1）需求规约是软件开发组织和用户之间一份事实上的技术合同书，即关注产品需求，（1分）回答“交付给客户的产品/系统是什么了（1分）。<br>（2）项目需求是客户和开发者之间有关技术合同-产品/ 系统需求的理解。（1分）应记录在工作陈述中或其他某一项目文档中,即关注项目工作于管理，（1分）回答“开发组要做的是什么事。（1分）</li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/06/01/02333-2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
