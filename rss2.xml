<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>珍珠巧克力</title>
    <link>https://pearlchocolatezy.com/</link>
    
    <atom:link href="https://pearlchocolatezy.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Mon panache. - 我的勇气。</description>
    <pubDate>Thu, 20 Feb 2025 14:59:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>PostgreSQL逐行累加——实现账目余额报表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/</guid>
      <pubDate>Thu, 20 Feb 2025 14:52:03 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;惊艳了同事的sum over语法~(✧◡✧)&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </description>
        
      
      
      
      <content:encoded><![CDATA[<p>惊艳了同事的sum over语法~(✧◡✧)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(colA) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> colB <span class="keyword">order</span> <span class="keyword">by</span> colC) <span class="keyword">from</span> temp</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlSumover/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PostgreSQL递归语法——读取树形结构表</title>
      <link>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</link>
      <guid>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/</guid>
      <pubDate>Thu, 20 Feb 2025 14:44:48 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--recursive + inner join</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> temp <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> class_id,mother_id,class_id::text <span class="keyword">as</span> path, class_name <span class="keyword">from</span> item_class <span class="comment">--and class_id=123</span></span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> iic.class_id,iic.mother_id,iic.class_id::text<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.path <span class="keyword">as</span> path, iic.class_name<span class="operator">||</span><span class="string">&#x27;/&#x27;</span><span class="operator">||</span>temp.class_name <span class="keyword">as</span> class_name <span class="keyword">from</span> item_class iic <span class="keyword">inner</span> <span class="keyword">join</span> temp <span class="keyword">on</span> temp.mother_id<span class="operator">=</span>iic.class_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;/&#x27;</span>,path,<span class="string">&#x27;/&#x27;</span>) <span class="keyword">as</span> path, class_name,split_part(path,<span class="string">&#x27;/&#x27;</span>,LENGTH(path) <span class="operator">-</span> LENGTH(REPLACE(path, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>))<span class="operator">+</span><span class="number">1</span>) <span class="keyword">as</span>  class_id <span class="keyword">from</span> temp <span class="keyword">where</span> mother_id<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> <span class="built_in">position</span>(<span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> path)<span class="operator">&gt;</span><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/DataBase/">DataBase</category>
      
      <category domain="https://pearlchocolatezy.com/tags/PostgreSQL-Pgsql/">PostgreSQL(Pgsql)</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/20/PgsqlRecursion/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>13015 计算机系统原理</title>
      <link>https://pearlchocolatezy.com/2025/02/15/LearnCO/</link>
      <guid>https://pearlchocolatezy.com/2025/02/15/LearnCO/</guid>
      <pubDate>Sat, 15 Feb 2025 13:02:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;1&amp;#39;*10=10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*10=20&lt;/code&gt;&lt;br&gt;名词解释：&lt;code&gt;3&amp;#39;*2=6&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;6&amp;#39;*4=24&lt;/code&gt;&lt;br&gt;综合计算题：&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>1&#39;*10=10</code><br>填空题：<code>2&#39;*10=20</code><br>名词解释：<code>3&#39;*2=6</code><br>简答题：<code>6&#39;*4=24</code><br>综合计算题：<code>10&#39;*4=40</code></p><p>共六章</p><h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><h3 id="一-1-计算机基本工作原理"><a href="#一-1-计算机基本工作原理" class="headerlink" title="一/1 计算机基本工作原理"></a>一/1 计算机基本工作原理</h3><p><strong>大纲知识点</strong></p><ol><li>名词解释<br>（1）中央处理器（CPU）：控制部件、运算部件和各类寄存器互连组成的电路。<br>（2）算术逻辑部件（ALU）：用来进行算术逻辑运算的部件。<br>（3）通用寄存器：用于临时存放从主存取来的数据或运算的结果。<br>（4）程序计数器（PC）：CPU 为了自动按序读取主存中的指令，需要程序计数器 , 在执行当前指令的过程中，自动计算出下一条指令的地址并送到PC中保存。<br>（5）指令寄存器（IR）：用于临时保存从主存取来的指令。<br>（6）控制器：用于自动逐条取出指令并进行译码的部件。<br>（7）主存储器：用来存放指令和数据的部件。<br>（8）总线：连接不同部件进行信息传输的介质。<br>（9）主存地址寄存器（MAR）：CPU送到地址线的主存地址先存放的位置。<br>（10）主存数据寄存器（MDR）：发送到或从数据线取来的信息存放的位置。<br>（11）机器指令：计算机能理解和执行的，用0和1表示的一串0/1序列。<br>（12）指令操作码：计算机指令中用于指示CPU执行特定操作的部分。<br>（13）高级程序设计语言：是指面向算法设计的、较接近于日常英语书面语言的程序设计语言，如C、Java等。<br>（14）汇编语言：通过用简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序。<br>（15）机器语言：使用特定计算机规定的指令格式而形成的0/1序列。<br>（16）机器级语言：是计算机硬件能够直接理解和执行的低级语言，它是计算机指令的最底层表示形式，由一系列二进制代码组成，这些代码直接对应计算机硬件的操作指令。<br>（17）源程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，被翻译的程序为源程序。<br>（18）目标程序：把一种编程语言表示的程序转换为功能等价的另一种编程语言程序时，翻译生成的程序为目标程序。<br>（19）编译程序：也称编译器。用于将高级语言源程序翻译成汇编语言或机器语言目标程序。<br>（20）解释程序：也称解释器。用于将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行。<br>（21）汇编程序：也称汇编器。用于将汇编语言源程序翻译成机器语言目标程序。<br>（22）语言处理系统：提供程序编辑器和各类翻译转换软件的工具包。<br>（23）设备控制器：I/0控制器或I/0适配器统称为设备控制器，用于连接外设到主机。<br>（24）最终用户：使用应用软件完成特定任务的计算机用户。<br>（25）系统管理员：是指利用操作系统、数据库管理系统等软件提供的功能对系统进行配置、管理和维护，以建立高效合理的系统环境供计算机用户使用的操作人员。<br>（26）应用程序员：是指使用高级编程语言编制应用软件的程序员。<br>（27）系统程序员：指设计和开发系统软件的程序员。<br>（28）指令集体系结构（ISA）：是软件和硬件之间接口的一个完整定义。<br>（29）微体系结构：实现ISA的电路逻辑结构。<br>（30）透明：在计算机技术中，一个存在的事物或概念从某个角度看似乎不存在，即对实际存在的事物或概念感觉不到。<br>（31）响应时间：指从作业提交开始到作业完成所用的时间。<br>（32）吞吐率：在单位时间内所完成的工作量。<br>（33）用户CPU时间：指真正用于运行用户程序代码的时间。<br>（34）时钟周期：CPU主脉冲信号（计算机产生的同步的时钟定时信号）的宽度。<br>（35）主频：CPU主脉冲信号的时钟频率，是CPU时钟周期的倒数。<br>（36）CPI：执行一条指令所需的时钟周期数。<br>（37）基准程序：是专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间，从而评测其性能。<br>（38）MIPS：指令速度所用的计量单位，含义是平均每秒钟执行多少百万条指令。<br>（39）峰值MIPS：选取一组指令组合，使 得 得 到 的 平 均 C P I最小，由此得到的MIPS是峰值MIPS。<br>（40）相对MIPS：根据某个公认的参考机型来定义的相应MIPS值，是被测机型相对于参考机型MIPS的倍数。<br>（41）MFLOPS：每秒所执行的浮点运算有多少百万次。<br>（42）GFLOPS：每秒所执行的浮点运算有多少$10^9$次。<br>（43）TFLOPS：每秒所执行的浮点运算有多少$10^{12}$次。<br>（44）PFLOPS：每秒所执行的浮点运算有多少$10^{15}$次。<br>（44）EFLOPS：每秒所执行的浮点运算有多少$10^{18}$次。</li></ol><p><strong>真题</strong></p><ol><li>冯·诺依曼计算机工作方式的基本特点：<br>（1）“存储程序”工作方式 <mark class="hl-label default">（2024-10XZ 1'）</mark> <br>（2）计算机由五大部件组成：<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">运算器</i>、<i id="answer1_2" class="answer" onclick="showOrHide('1_2')">控制器</i>、<i id="answer1_3" class="answer" onclick="showOrHide('1_3')">存储器</i>、<i id="answer1_4" class="answer" onclick="showOrHide('1_4')">输入设备</i>、<i id="answer1_5" class="answer" onclick="showOrHide('1_5')">输出设备</i>。<br>（3）存储器能存放数据和指令；<br>控制器能自动执行指令；<br>运算器能进行基本算术和逻辑运算；<br>操作人员可以通过I/O设备使用计算机<br>（4）计算机内部以二进制形式表示指令和数据；<br>每条指令=操作码+地址码+…，操作码指出操作类型，地址码指出操作数的地址；<br>由一串指令组成程序。</li></ol><h3 id="一-2-程序的开发与运行"><a href="#一-2-程序的开发与运行" class="headerlink" title="一/2 程序的开发与运行"></a>一/2 程序的开发与运行</h3><h3 id="一-3-计算机系统的层次结构"><a href="#一-3-计算机系统的层次结构" class="headerlink" title="一/3 计算机系统的层次结构"></a>一/3 计算机系统的层次结构</h3><h3 id="一-4-计算机系统性能评价"><a href="#一-4-计算机系统性能评价" class="headerlink" title="一/4 计算机系统性能评价"></a>一/4 计算机系统性能评价</h3><ol><li><p>主频：主频就是 CPU 主脉冲信号的时钟频率,是 CPU 时钟周期的倒数。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> </p></li><li><p>运算器的核心部件是<i id="answer1_6" class="answer" onclick="showOrHide('1_6')">算术逻辑运算单元</i>。</p></li></ol><h2 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><ol><li><p>简述计算机内部和外部需要进行数制转换的原因： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>计算机内部所有信息都采用二进制编码表示。(2分)<br>但在计算机外部,大都采用八、十或十六进制表示形式。(2分)<br>因此,计算机在数据输入后或输出前都必须实现这些进制数和二进制数之间的转换。(2分)</p></blockquote></li><li><p>二进制、八进制、十六进制转十进制： <mark class="hl-label default">（2024-10XZ 1'）</mark> </p><script type="math/tex; mode=display">(10010)_2=2^4+2^1=18</script><script type="math/tex; mode=display">(347)_8=3*2^2+4*2^1+7*2^0=27</script><script type="math/tex; mode=display">(28E)_{16}=2*16^2+8*16^1+14*16^0=654</script><p>十六进制：A=10，B=11，C=12，D=13，E=14，F=15</p></li><li><p>浮点运算器可以用阶码部件和尾数部件来实现。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="三、程序的转换-及-机器级表示"><a href="#三、程序的转换-及-机器级表示" class="headerlink" title="三、程序的转换 及 机器级表示"></a>三、程序的转换 及 机器级表示</h2><ol><li>指令系统中采用不同寻址方式的目的主要是：缩短指令长度，扩大寻址空间，提高编程灵活性。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </li></ol><h2 id="四、可执行文件的生成-与-加载执行"><a href="#四、可执行文件的生成-与-加载执行" class="headerlink" title="四、可执行文件的生成 与 加载执行"></a>四、可执行文件的生成 与 加载执行</h2><ol><li><p>从源程序变为可执行文件的步骤：<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">预处理</i>、<i id="answer4_2" class="answer" onclick="showOrHide('4_2')">编译</i>、<i id="answer4_3" class="answer" onclick="showOrHide('4_3')">汇编</i>、<i id="answer4_4" class="answer" onclick="showOrHide('4_4')">链接</i>。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li><li><p>在父进程中创建一个子进程，使用<i id="answer4_5" class="answer" onclick="showOrHide('4_5')">fork</i>函数。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="五、程序的存储访问"><a href="#五、程序的存储访问" class="headerlink" title="五、程序的存储访问"></a>五、程序的存储访问</h2><ol><li><p>重定位：重新确定代码和数据的地址,并更新指令中被引用符号地址的操作。 <mark class="hl-label default">（2024-10MCJS 3'）</mark> </p></li><li><p>简述在递归深度较深时，递归调用的时间开销和空间开销都会较大的原因：  <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>每个过程包含准备阶段和结束阶段,并在栈中新增一个栈帧,(2分)<br>因而,每增加一次过程调用,就要增加许多条包含在准备阶段和结束阶段的额外指令,并增加一个栈帧的空间,(2分)<br>当递归调用深度较深时,这些额外指令的执行时间开销和栈帧的空间开销就会很大,有些情况下甚至发生栈溢出。(2分)</p></blockquote></li><li><p>简述动态链接的共享性和动态性： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>共享性是指共享库中的代码段在内存只有一个副本,当应用程序在其代码中需要引用共享库中的符号时,在引用处通过某种方式确定指向共享库中对应定义符号的地址即可;(3分)<br>动态性是指共享库只有使用它的程序被加载或执行时才加载到内存。(3 分)</p></blockquote></li><li><p>非易失性存储器：ROM，次表面存储器，光存储器。<br>易失性存储器：主存，高速缓冲存储。 <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><h2 id="六、程序中I-O操作的实现"><a href="#六、程序中I-O操作的实现" class="headerlink" title="六、程序中I/O操作的实现"></a>六、程序中I/O操作的实现</h2><ol><li><p>简述中断控制I/0方式的基本思想： <mark class="hl-label default">（2024-10JD 6'）</mark> </p><blockquote><p>当需要进行I /O 操作时,首先启动外设进行第一个数据的 I /O 操作,然后阻塞请求I /O的用户进程,并调度其他进程到 CPU上执行,期间外设在设备控制器的控制下工作。(2 分)<br>外设完成 I /O 操作后,向 CPU 发送一个中断请求信号,CPU 检测到该信号后,则进行上下文切换,调出相应的中断服务程序执行。(2分)<br>中断服务程序将启动后续数据的 I /O操作,然后返回到被打断的进程继续执行。(2分)</p></blockquote></li><li><p>子系统层次结构（图） <mark class="hl-label default">（2024-10XZ 1'）</mark> </p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/15/LearnCO/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>02333 软件工程 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</link>
      <guid>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/</guid>
      <pubDate>Wed, 12 Feb 2025 13:34:14 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15=30&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8=40&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;共八章&lt;/p&gt;
&lt;h2 id=&quot;一、绪论&quot;&gt;&lt;a href=&quot;#一、绪</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*15=30</code><br>填空题：<code>2&#39;*15=30</code><br>简答题：<code>5&#39;*8=40</code></p><p>共八章</p><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><ol><li><p>软件开发的本质及其涉及到的问题 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）将软件开发的本质概括为：不同抽象层术语之间的“映射”，以及不同抽象层处理逻辑之间的“映射”。（2’）<br>（2）它涉及到两方面的问题：<br>①一是如何实现这样的映射，这是技术层面上的问题。（1’）<br>②二是如何管理这样的映射，以保障映射的有效性和正确性。这是管理层面上的问题。（2’）</p></blockquote></li><li><p>计算机软件=<i id="answer1_1" class="answer" onclick="showOrHide('1_1')">程序</i>+文档</p></li></ol><h2 id="二、软件需求与规约"><a href="#二、软件需求与规约" class="headerlink" title="二、软件需求与规约"></a>二、软件需求与规约</h2><h2 id="三、结构化方法"><a href="#三、结构化方法" class="headerlink" title="三、结构化方法"></a>三、结构化方法</h2><ol><li><p>在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/2.png" width="80%"><br>按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。<br>设计良好的软件结构，通常顶层扇出比较大，中间扇出小，底层模块则有大扇入。（大小大）<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>结构化方法总体设计的三个阶段 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）第一阶段为初始设计。对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。（1分）<br>（2）第二阶段为精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。（2分）<br>（3）第三阶段为复审阶段。对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作。（2分）</p></blockquote></li><li><p>结构精细化设计的原则：高内聚低耦合<mark class="hl-label default">（2024-04XZ 2'）</mark> ；逐步细化；清晰第一，效率第二；遵循结构化控制结构……</p></li><li><p>在结构化设计中，执行一个特殊任务的一个过程以及相关的数据结构，称之为<i id="answer3_1" class="answer" onclick="showOrHide('3_1')">模块</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> <br>模块（Module）是结构化设计的核心概念之一，它将程序分解为可管理的、功能单一的代码单元，每个模块完成一个特定的任务，并通过明确的接口与其他模块交互。</p></li></ol><h2 id="四、面向对象方法UML"><a href="#四、面向对象方法UML" class="headerlink" title="四、面向对象方法UML"></a>四、面向对象方法UML</h2><ol><li><p>UML表达客观事物之间关系的术语及定义 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）为了表达各类客观事物之间的关系，UML给出了表达关系的基本术语：关联、泛化、细化、依赖；（1分）<br>（2）关联是类目之间的一种结构关系，是对一组具有相同结构、相同链的描述。（1分）泛化是一般性类目和它的较为特殊性类目之间的一种关系。（1分）细化是类目之间的语义关系，其中一个类目规约了保证另一个类目执行的契约。（1分）依赖是一种使用关系，用于描述一个类目使用另一类目的信息和服务。（1分）</p></blockquote></li><li><p>为了进一步表达泛化的语义，UML给出了4个约束，分别为完整、不完整、<i id="answer4_1" class="answer" onclick="showOrHide('4_1')">互斥、重叠</i>。 <mark class="hl-label default">（2024-04TK 2'）</mark> </p></li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段"><a href="#（一）初始阶段" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段"><a href="#（二）细化阶段" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><p>使用类图来定义分析类（边界类、实体类、控制类）<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/1.png" width="80%"></p><h3 id="（三）构建阶段"><a href="#（三）构建阶段" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段"><a href="#（四）交付阶段" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="五、面向对象方法RUP"><a href="#五、面向对象方法RUP" class="headerlink" title="五、面向对象方法RUP"></a>五、面向对象方法RUP</h2><p>定义：Rational Unified Process，统一软件开发过程。</p><ol><li>RUP中<i id="answer5_1" class="answer" onclick="showOrHide('5_1')">部署模型</i> <mark class="hl-label default">（2024-04TK 2'）</mark>  的主要内容：节点，节点之间的通信关系，主动类到节点的映射 <mark class="hl-label default">（2024-04TK 2'）</mark> ，软件组件到节点的映射，部署配置，部署视图，部署计划</li></ol><p>四个主要阶段：</p><h3 id="（一）初始阶段-1"><a href="#（一）初始阶段-1" class="headerlink" title="（一）初始阶段"></a>（一）初始阶段</h3><h3 id="（二）细化阶段-1"><a href="#（二）细化阶段-1" class="headerlink" title="（二）细化阶段"></a>（二）细化阶段</h3><h3 id="（三）构建阶段-1"><a href="#（三）构建阶段-1" class="headerlink" title="（三）构建阶段"></a>（三）构建阶段</h3><h3 id="（四）交付阶段-1"><a href="#（四）交付阶段-1" class="headerlink" title="（四）交付阶段"></a>（四）交付阶段</h3><h2 id="六、软件测试"><a href="#六、软件测试" class="headerlink" title="六、软件测试"></a>六、软件测试</h2><ol><li><p>描述系统或软件问题时常用的术语：<br>错误：由于开发人员的疏忽、误解或其他原因导致的不符合预期的行为或状态。错误通常发生在开发阶段，例如需求分析、设计或编码过程中。<br>故障：系统或组件的内部状态不正常。能是偶然的（如硬件故障）或系统的（如软件设计缺陷）。<br><i id="answer6_2" class="answer" onclick="showOrHide('6_2')">失效</i>：系统或组件未能按照预期执行其功能，是用户可观察到的错误行为或结果。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p></li><li><p>人类对软件测试目的的认识经历了<i id="answer6_1" class="answer" onclick="showOrHide('6_1')"> 5 </i>个阶段 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br>（1）错误检测阶段<br>（2）验证阶段<br>（3）质量保证阶段<br>（4）风险控制阶段<br>（5）用户体验和价值交付阶段</p></li></ol><h2 id="七、软件生命周期"><a href="#七、软件生命周期" class="headerlink" title="七、软件生命周期"></a>七、软件生命周期</h2><ol><li><p>螺旋模型概念及其特点 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）螺旋模型是瀑布模型与演化模型的基础上，加入两者所忽略的风险分析所建立的一种软件开发模型。（2’）<br>（2）螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。（3’）</p></blockquote><p> <img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/3.png" width="80%"></p></li><li>瀑布模型适用于需求明确、稳定且对安全性和可靠性要求高的项目，例如企业内部管理信息系统、航空航天和医疗设备领域的软件开发。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/4.png" width="80%"></li></ol><p>五个主要阶段：</p><h3 id="（一）需求分析"><a href="#（一）需求分析" class="headerlink" title="（一）需求分析"></a>（一）需求分析</h3><h3 id="（二）设计阶段"><a href="#（二）设计阶段" class="headerlink" title="（二）设计阶段"></a>（二）设计阶段</h3><h4 id="（二-1）概要设计"><a href="#（二-1）概要设计" class="headerlink" title="（二/1）概要设计"></a>（二/1）概要设计</h4><ol><li><p>概要设计规约的主要内容 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>系统架构设计：包括系统的物理硬件架构、软件架构、技术平台选择等。<br>功能模块设计：根据需求将功能划分到子系统或模块中，包括主要数据结构。<br>接口设计：定义系统内部模块间或与外部系统的交互接口，以及必要的注释。<br>数据库设计：设计核心数据的逻辑结构。</p></blockquote></li><li><p>概要设计规约的作用</p><blockquote><p>是系统设计阶段的重要文档，用于指导详细设计和后续的开发工作。<br>是系统架构和功能模块设计的正式文档，为开发团队提供整体设计思路。</p></blockquote></li></ol><h4 id="（二-2）详细设计"><a href="#（二-2）详细设计" class="headerlink" title="（二/2）详细设计"></a>（二/2）详细设计</h4><h3 id="（三）编码阶段"><a href="#（三）编码阶段" class="headerlink" title="（三）编码阶段"></a>（三）编码阶段</h3><h3 id="（四）测试阶段"><a href="#（四）测试阶段" class="headerlink" title="（四）测试阶段"></a>（四）测试阶段</h3><h3 id="（五）维护阶段"><a href="#（五）维护阶段" class="headerlink" title="（五）维护阶段"></a>（五）维护阶段</h3><h2 id="八、集成化能力成熟度模型CMMI"><a href="#八、集成化能力成熟度模型CMMI" class="headerlink" title="八、集成化能力成熟度模型CMMI"></a>八、集成化能力成熟度模型CMMI</h2><p>定义：是一种用于评估和改进组织在软件开发、系统集成、项目管理等方面过程能力的框架。<br>CMMI的成熟度等级：初始级，已管理级，已定义级，已量化管理级，持续优化级。共 5 个等级，每个等级要记英文，可能会考某个等级的名字；最高等级为第5级，优化级。<mark class="hl-label default">（2024-04XZ 2'）</mark> </p><ol><li><p>能力等级和成熟度等级之间的区别和联系 <mark class="hl-label default">（2024-04JD 5'）</mark> </p><blockquote><p>（1）区别：能力等级是一种过程改善路径，该路径可使组织针对单一过程域不断改善该过程域。（1分）成熟度等级也是一种过程改善路径，该路径可使组织通过关注一组过程域不断改善一组相关的过程域;（1分）<br>（2）联系：能力等级和成熟度等级都是CMMI提供的两种过程改善路径，侧重不同：它们都是按共用目标从弱到强。（1分）当某一过程域逐步完成了所有等级的“最佳实践”，它才可能满足成熟度等级对单一过程域的要求。（1分）当一组过程域及相关共用目标的一个成熟度等级完成后，软件过程才能实现高一级别的“成熟”，从而实现对软件过程有效管理的“最佳实践”。（1分）</p></blockquote></li><li><p>CMMI模型根据核心能力领域对过程域进行分类，这些能力领域包括：<br>治理：提供高级管理在过程治理中的角色指导。<br>实施基础设施：确保组织的重要过程和资产被持续使用和改进。<br>过程管理：包括组织过程焦点、过程定义等。<br>项目管理：包括项目规划、监控、风险管理等。<br>工程：涉及需求开发、技术方案、验证等。<mark class="hl-label default">（2024-04XZ 2'）</mark> <br>支持：包括配置管理、度量分析、质量保证等。<br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/6.png" width="80%"></p></li><li><p>CMMI的模型部件中，实践部件的图形是菱形 <mark class="hl-label default">（2024-04XZ 2'）</mark> <br><img class="zy_img_shadow" src="/2025/02/12/LearnSoftwareEngineering/5.png" width="80%"></p></li></ol><script>//填空专用function showOrHide(index){    let answer_text=document.getElementById(`answer${index}`);    if(answer_text.classList.contains('hide_answer')){        answer_text.classList.remove('hide_answer');    }else {        answer_text.classList.add('hide_answer');    }}</script><style>.answer{    color:transparent;    position: relative;}.answer::after {  content: "";  position: absolute;  left: 0;  bottom: 0;  width: 100%;  height: 1px; /* 下划线高度 */  background-color: black; /* 下划线颜色 */}.hide_answer{    color:black;}</style>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/12/LearnSoftwareEngineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>04747 Java语言程序设计 框架+知识点</title>
      <link>https://pearlchocolatezy.com/2025/02/05/LearnJava/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/LearnJava/</guid>
      <pubDate>Wed, 05 Feb 2025 13:33:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;选择题：&lt;code&gt;2&amp;#39;*10&lt;/code&gt;&lt;br&gt;填空题：&lt;code&gt;2&amp;#39;*15&lt;/code&gt;&lt;br&gt;简答题：&lt;code&gt;5&amp;#39;*8&lt;/code&gt;&lt;/p&gt;
&lt;!--
## 2024-10真题
### 1.1 Java语言支持的基本数据类型 及 包含的</description>
        
      
      
      
      <content:encoded><![CDATA[<p>选择题：<code>2&#39;*10</code><br>填空题：<code>2&#39;*15</code><br>简答题：<code>5&#39;*8</code></p><!--## 2024-10真题### 1.1 Java语言支持的基本数据类型 及 包含的各类型对应的所有关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整数类型：byte, short, int, long (1&#x27;)</span><br><span class="line">浮点数类型：float, double (1&#x27;)</span><br><span class="line">字符类型：string (1&#x27;)</span><br><span class="line">布尔类型：boolean (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-2-Java的异常类型及各自特点"><a href="#1-2-Java的异常类型及各自特点" class="headerlink" title="1.2 Java的异常类型及各自特点"></a>1.2 Java的异常类型及各自特点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java的异常分为三种类型： (1&#x27;)</span><br><span class="line">（1）受检异常，必须被处理  (1&#x27;)</span><br><span class="line">（2）运行时异常，不需要处理  (1&#x27;)</span><br><span class="line">（3）错误，不需要处理  (1&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-3-什么是包装类"><a href="#1-3-什么是包装类" class="headerlink" title="1.3 什么是包装类"></a>1.3 什么是包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包装类是一种特殊的基本类型。 (2&#x27;)</span><br><span class="line">当想用处理对象一样的方式来处理基本数据类型的数据时，必须将基本数据类型值“包装”为一个对象。  (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-4-什么是抽象类-及其作用"><a href="#1-4-什么是抽象类-及其作用" class="headerlink" title="1.4 什么是抽象类 及其作用"></a>1.4 什么是抽象类 及其作用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义了方法但没有定义具体实现的类称为抽象类，通过abstract关键字完成。 (2&#x27;)</span><br><span class="line">在程序中，需要创建某个类代表一些基本行为，并为其规范定义一些方法，但又无法或不宜在这个类实现，希望在其子类实现。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="1-5-描述Java的委托事件处理模型"><a href="#1-5-描述Java的委托事件处理模型" class="headerlink" title="1.5 描述Java的委托事件处理模型"></a>1.5 描述Java的委托事件处理模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每当用户在组件上进行某种操作时，事件处理系统会生成一个事件类对象。 (2&#x27;)</span><br><span class="line">事件被直接送往产生这个事件的组件，组件需要注册一个或多个侦听程序。 (1&#x27;)</span><br><span class="line">侦听程序的类中包含了事件处理程序，用来接收和处理这个事件。 (1&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**Expand**</span><br><span class="line">Java的委托事件处理模型（Delegation Event Model）是Java中用于处理事件的一种机制，它基于观察者模式（Observer Pattern），将事件源（Event Source）和事件监听器（Event Listener）分离，从而实现低耦合和高灵活性。</span><br><span class="line">1. 基本概念</span><br><span class="line">    事件源（Event Source）：是产生事件的对象，例如按钮（Button）、文本框（TextField）等。事件源可以触发一个或多个事件。</span><br><span class="line">    事件（Event）：是某个动作或状态的表示，例如鼠标点击（ActionEvent）、键盘输入（KeyEvent）等。</span><br><span class="line">    事件监听器（Event Listener）：是实现特定接口的对象，用于处理事件。监听器接口定义了事件处理方法，例如 ActionListener 接口中的 actionPerformed 方法。</span><br><span class="line">    事件处理器（Event Handler）：是事件监听器中实现的事件处理方法，用于响应事件。</span><br><span class="line">2. 工作原理</span><br><span class="line">（1）注册事件监听器，通过实现特定的接口来定义事件处理逻辑</span><br><span class="line">（2）事件触发，当用户与事件源交互时（例如点击按钮），事件源会生成一个事件对象（如 ActionEvent）。事件源将事件对象传递给所有注册的监听器。</span><br><span class="line">（3）事件处理</span><br><span class="line">3. 事件传播机制</span><br><span class="line">    捕获阶段（Capturing Phase）：事件从最顶层的容器开始向下传播，直到到达事件源。</span><br><span class="line">    冒泡阶段（Bubbling Phase）：事件从事件源开始向上传播，直到到达最顶层的容器。</span><br></pre></td></tr></table></figure><h2 id="2024-04真题"><a href="#2024-04真题" class="headerlink" title="2024-04真题"></a>2024-04真题</h2><h3 id="2-1-接口与多重继承的关系"><a href="#2-1-接口与多重继承的关系" class="headerlink" title="2.1 接口与多重继承的关系"></a>2.1 接口与多重继承的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java不支持多重继承，一个类只能从唯一的一个类继承而来。但是，这并不意味着Java不能实现多重继承的功能。 (2&#x27;)</span><br><span class="line">具体来说，Java允许一个类实现多个接口，从而具备了多重继承的能力。因为接口中声明的方法体是空的，所以不会出现多重继承中固有的混乱。 (2&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口（Interface）是一种特殊的抽象类型，它定义了一组行为规范，但不提供具体实现。当一个类实现某个接口时，它必须提供接口中声明的所有方法的具体实现。这种机制被称为契约机制。</span><br><span class="line">面向接口编程是一种重要的设计原则，它强调通过接口来定义和交互，而不是直接依赖具体的类。这种方式可以带来以下好处：解耦（实现类和使用类之间只依赖接口，而不是具体的实现），多态（通过接口引用调用方法时，可以根据实际对象的类型动态调用相应的方法）。</span><br></pre></td></tr></table></figure><h3 id="2-2-解释线程控制中方法的功能（max-4’）"><a href="#2-2-解释线程控制中方法的功能（max-4’）" class="headerlink" title="2.2 解释线程控制中方法的功能（max:4’）"></a>2.2 解释线程控制中方法的功能（max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start()：启动线程对象。 (2&#x27;)</span><br><span class="line">yield()：用于强制终止线程的执行。 (2&#x27;)</span><br><span class="line">wait()：导致当前线程等待。 (2&#x27;)</span><br><span class="line">notify()：当其它线程调用某线程的notify方法时，唤醒该线程。 (2&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"><a href="#2-3-创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号" class="headerlink" title="2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号"></a>2.3 创建Font类型对象fn的代码，属性值是Courier字体，BOLD样式，20磅字号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Font</span> <span class="variable">fn</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Courier&quot;</span>,Font.BOLD,<span class="number">20</span>);  <span class="comment">//(4&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="2-4-静态方法的特点（1’-answer，max-4’）"><a href="#2-4-静态方法的特点（1’-answer，max-4’）" class="headerlink" title="2.4 静态方法的特点（1’/answer，max:4’）"></a>2.4 静态方法的特点（1’/answer，max:4’）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）静态方法以static修饰；</span><br><span class="line">（2）静态方法属于类，不属于对象；</span><br><span class="line">（3）调用静态方法时，前缀可以使用类名；</span><br><span class="line">（4）静态方法中不能访问类对象的非静态成员，只能访问类的静态成员；</span><br><span class="line">（5）静态方法中没有this指针；</span><br><span class="line">（6）静态方法不可以被重写。</span><br></pre></td></tr></table></figure><p>—&gt;</p>-->]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/X2080901/">X2080901</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Java/">Java</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/LearnJava/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>解决ssh: connect to host github.com port 22: Connection timed out</title>
      <link>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</link>
      <guid>https://pearlchocolatezy.com/2025/02/05/SolveSshError/</guid>
      <pubDate>Wed, 05 Feb 2025 01:57:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;部署在github上的hexo博客，用了很久的默认22端口突然连不上了&lt;br&gt;&lt;img class=&quot;zy_img_shadow&quot; src=&quot;/2025/02/05/SolveSshError/1.png&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能原因是：&lt;/p&gt;
&lt;b</description>
        
      
      
      
      <content:encoded><![CDATA[<p>部署在github上的hexo博客，用了很久的默认22端口突然连不上了<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/1.png" width="60%"></p><p>可能原因是：</p><blockquote><p>网络连接问题<br>SSH秘钥配置错误<br>22端口已占用<br>……</p></blockquote><p>排除下来22端口被占用或其他环境因素禁用的可能性比较大，可以改为443端口（HTTPS端口，通常开放）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/2.png" width="60%"><br>跟<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">GitHub官网</a>的主机密钥指纹对比确认正确后输入yes<br><img class="zy_img_shadow" src="/2025/02/05/SolveSshError/3.png" width="60%"></p><p><strong>在.ssh文件夹中配置新的端口号：</strong><br>找到目录：C:\Users\&lt;你的用户名&gt;.ssh\config（Windows）<br>如果没有config文件可以在.ssh文件夹下新建一个config空文件<br>文件内容为：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">  <span class="string">HostName</span> <span class="string">ssh.github.com</span></span><br><span class="line">  <span class="string">Port</span> <span class="number">443</span></span><br><span class="line">  <span class="string">User</span> <span class="string">git</span></span><br><span class="line">  <span class="string">PreferredAuthentications</span> <span class="string">publickey</span></span><br><span class="line">  <span class="string">IdentityFile</span> <span class="string">~\.ssh\id_rsa</span></span><br></pre></td></tr></table></figure><br>尝试重新推送即可。</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Hexo-Butterfly/">Hexo|Butterfly</category>
      
      <category domain="https://pearlchocolatezy.com/tags/Git/">Git</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/05/SolveSshError/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（五）——链路层和局域网</title>
      <link>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</link>
      <guid>https://pearlchocolatezy.com/2025/02/04/LearnNet5/</guid>
      <pubDate>Tue, 04 Feb 2025 08:35:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;链路层&quot;&gt;&lt;a href=&quot;#链路层&quot; class=&quot;headerlink&quot; title=&quot;链路层&quot;&gt;&lt;/a&gt;链路层&lt;/h2&gt;&lt;h3 id=&quot;目标：原理和实现&quot;&gt;&lt;a href=&quot;#目标：原理和实现&quot; class=&quot;headerlink&quot; title=&quot;目标：原理</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="目标：原理和实现"><a href="#目标：原理和实现" class="headerlink" title="目标：原理和实现"></a>目标：原理和实现</h3><p>原理：<br>检错和纠错<br>共享广播信道：多点接入<br>链路层寻址<br>LAN：以太网，VLANs<br>可靠数据传输</p><p>链路层技术的实现</p><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><p>广域网WAN：网络形式采用点到点链路，实现容易<br>局域网LAN：一般采用多点连接方式，实现复杂<br>链路层的主要功能：一个节点把帧通过链路传到相邻的另一个节点（点到点）。<br>链路层服务：成帧，链路介入；在相邻两个节点完成可靠数据传递；在相邻节点间进行可靠转发；流量控制；错误检测；差错纠正；半双工和全双工（可收可发）。（一个特定的链路层只提供其中一种服务）<br>链路层功能在哪里实现：每个主机上，装了网卡，网卡实现网络层和链路层的功能；路由器上有多个网卡，每个网卡实现了物理层和相应链路层的功能。即，链路层功能在网卡上实现，网卡又称网络适配器（NIC），开机自动运行，按照协议工作。</p><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p>残存错误<br>奇偶校验<br>CRC循环冗余校验码：<br>1）模2运算（按位异或，加法不进位）；<br>2）位串的两种表示（0和1；多项式表示）；<br>3）生成多项式（r次方的比特序列）；<br>4）约定：sender多项式<code>[D][EDC]</code> 使得 receiver多项式<code>[D][EDC]</code>满足 接收方r位多项式/生成多项式=整数，则数据在传输过程中没有出错<br>CRC性能分析：能够查出所有1bit的错误、双bit的错误……</p><h3 id="多点访问协议"><a href="#多点访问协议" class="headerlink" title="多点访问协议"></a>多点访问协议</h3><p>多路访问链路和协议：<br>两种类型的链路：点对点，广播（共享线路和媒体）<br>多路访问协议：MAC<br>理想的MAP协议：1）当一个节点要发送时，按R速率（按信道设计带宽全速）发送；2）当M个节点要发送，每个以R/M的平均速率发送；3）完全分布；4）简单。<br>MAC分类：信道划分，随机访问，依次轮流。<br>信道划分MAC协议：<br>（1）TDMA(time division multiple access)：轮流使用信道，信道的时间分为周期（时分复用）<br>（2）FDMA(frequency division multiple access)：信道的有效频率被分为一个个小的频段（频分复用）<br>（3）CDMA(code division multiple access)：码分多路访问<br>随机存取协议</p>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/02/04/LearnNet5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（四）——网络层</title>
      <link>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</link>
      <guid>https://pearlchocolatezy.com/2025/01/30/LearnNet4/</guid>
      <pubDate>Thu, 30 Jan 2025 02:44:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;网络层：数据平面&quot;&gt;&lt;a href=&quot;#网络层：数据平面&quot; class=&quot;headerlink&quot; title=&quot;网络层：数据平面&quot;&gt;&lt;/a&gt;网络层：数据平面&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; titl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a>网络层：数据平面</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解网络服务的基本原理<br>网络服务模型<br>转发和路由<br>路由器工作原理<br>通用转发<br>网络层协议的实例</p><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ol><li>在发送主机和接收主机对之间传送段</li><li>在发送端，将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ol><h3 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h3><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP分片和重组<br>IP编址<br>子网：IP地址高位部分相同，无需路由器介入。<br>IP地址分类：A类（126 networks, 16million hosts），B类，C类（大部分）<br>127.x.x.x 表示回路地址：自上而下到达IP层再反转回去<br>DHCP协议：动态从服务器获取IP地址</p><h3 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h3><p>每个路由器都有控制平面和数据平面，分布化实现，用路由表粘连控制平面和数据平面（控制平面控制路由表，数据平面利用路由表信息进行转发）<br>SDN特点：1）基于流的匹配+行动；2）控制平面和数据平面分离；3）控制平面功能在数据交换设备之外实现；4）可编程控制应用。<br>SDN架构：（自下而上） 数据平面交换机（基于南向API，SDN控制器访问基于流的交换机)，SDN控制器（通过北向API和控制应用交互，通过南向API和网络交换机交互；逻辑上集中，实现上分布），控制应用（采用下层SDN控制器提供的API，实现网络功能，e.g.防火墙、接入控制、负载均衡）。<br>南向接口：SDN控制器（软件层面）与网络设备（硬件层面）之间的通信接口。e.g.OpenFlow<br>北向接口：提供给其他厂家或运营商进行接入和管理的接口，即向上提供的接口。<br>通用流表的组成：模式，行动，优先权，计数器<br>转发表和流表是怎样计算出来的：通过控制平面</p><h2 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a>网络层：控制平面</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>传统路由选择算法<br>SDN控制器<br>ICMP<br>网络管理</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>路由：按照某种指标（站数、延迟、费用、队列长度）找到一条从源节点到目标节点的较好路径<br>路由器之间的最优路径=主机对之间的最优路径<br>路由选择算法就是为所有路由路由器找到并使用汇集树。<br>路由选择算法的原则：正确性，简单性（不应为获取路由信息而增加通信量），健壮性（能适应通信量和网络拓扑变化），稳定性，公平性，最优性。<br><strong>链路状态算法 link state</strong><br>步骤：1）获得整个网络拓扑和边的代价信息（我的链路状态分组在全网泛洪）；2）计算本站点到其它站点的最优路径（Dijkstra算法，可以找例题！复杂度O(n^2)，堆优化后是O(nlogn)），得到路由表；3）按此路由表转发分组。<br>e.g.OSPF，IS-IS<br><strong>距离矢量算法 distance vector</strong><br>思想：各路由器维护一张到目标的路由表；各路由器与相邻路由器交换路由表；根据获得的路由信息更新路由表。（最后让各个节点收敛到一个真实状态）<br>特点：好消息传得快，坏消息传的慢（无穷计算-&gt;水平分裂算法：减少影响，不能杜绝发生）。</p><p>比较：<br>（1）消息复杂度：DV胜出<br>（2）收敛时间：LS胜出<br>（3）健壮性：LS胜出</p><h3 id="因特网中自治系统内部的路由器选择"><a href="#因特网中自治系统内部的路由器选择" class="headerlink" title="因特网中自治系统内部的路由器选择"></a>因特网中自治系统内部的路由器选择</h3><p>路由分为内部网关协议和外部网关协议。<br>内部网关协议有RIP协议和OSPF协议。<br>RIP(routing information protocal)协议基于DV算法。<br>OSPF(open shortest path first)协议基于LS算法。特性：安全，允许多个代价相同的路径存在，有多重代价矩阵。</p><h3 id="ISP之间的路由选择"><a href="#ISP之间的路由选择" class="headerlink" title="ISP之间的路由选择"></a>ISP之间的路由选择</h3><p>（自治区之间的路由选择协议，外部网关协议）<br>BGP协议：边界网关协议。将互联网各个自治系统(AS)粘在一起的胶水。<br>使用TCP协议交换BGP报文。（只要了解什么是层次性路由，为什么要用层次性路由）<br>层次路由的优点：解决了规模问题，解决了管理问题。<br>热土豆策略：选择具备最小内部区域代价的网关作为出口，不考虑代价。</p><h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><p>传统方式：per-router控制平面<br>SDN方式：逻辑上的集中控制平面（2005年后，详见上）<br>为什么需要逻辑上的集中控制平面：管理更容易，允许可编程的路由器，控制平面的开放实现<br>传统方式实现流量工程困难，用SDN方式容易。<br>SDN控制器的实现：ODL,ONOS</p><h3 id="ICMP-因特网控制报文协议"><a href="#ICMP-因特网控制报文协议" class="headerlink" title="ICMP 因特网控制报文协议"></a>ICMP 因特网控制报文协议</h3><h3 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h3>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/30/LearnNet4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（三）——传输层</title>
      <link>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</link>
      <guid>https://pearlchocolatezy.com/2025/01/27/LearnNet3/</guid>
      <pubDate>Mon, 27 Jan 2025 12:50:22 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解传输层的工作原理<br>（1）多路复用，解复用<br>（2）可靠数据传输<br>（3）流量控制<br>（4）拥塞控制<br>学习Internet的传输层协议：<br>（1）UDP无连接传输<br>（2）TCP面向连接的可靠传输<br>（3）TCP的可靠控制</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RDT，即reliable data transfer</p><p>物理层：传输实体，链路层：点到点，网络层：端到端，传输层：进程到进程，应用层：客户-服务</p><p>传输层提供进程与进程之间的，以message为单位的通信服务</p><p>传输协议运行在端系统。<br>发送方：讲应用层的报文分成报文段，然后传递给网络层。<br>接收方：将报文段重组成报文，然后传递给应用层。</p><p>有多个传输层协议可供应用选择</p><p>IP向上层提供的服务是不可靠的，TCP加强了可靠性；TCP向上层提供的服务是不安全的，SSL可以加强安全性。TCP无法降低延迟，无法增加带宽。TCP可以加强服务品质，但无法优化性能。</p><p>有连接的单位是分组，无连接的单位是数据报</p><p>字节流：Byte stream；数据报：Datagram；边界信息：Boundary information</p><p>best effort</p><h3 id="多路复用-解复用"><a href="#多路复用-解复用" class="headerlink" title="多路复用/解复用"></a>多路复用/解复用</h3><p>上一层实现IP的区分，到传输层引入端口，区分进程，完成源端的复用，到目标端的解复用。<br>复用是指多个tcp socket的信息都往下交,对方收到再分给不同的socket</p><p>共有65535个端口号</p><p>TCP和UDP使用端口的方式不一样</p><p>为了使穿过层间的信息最少，TCP和四元组相捆绑，即socket，socket包含四个信息：本地IP，本地port，对方IP，对方port。</p><p>socket是网络服务接口，对应进程</p><p>UDP的socket和本地IP，本地port相捆绑（二元组）。</p><p>应用往下传的是：（1）数据（2）socket（3）对方IP和对方port的地址（cad，指针）</p><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><p>应用：实时流媒体；事务性应用（一次往返）<br>UDP：用户数据报协议<br>UDP校验和：检测在被传输报文段中的差错。<br>残存错误：数据部分和EDC部分出错后依然符合校验规则。（概率小，但不可忽略）<br>发送方编码，接收方解码<br>进位回滚</p><h3 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h3><p>rdt（可靠数据传输）在应用层、传输层和数据链路层都很重要。是网络Top10问题之一。<br>信道的不可靠特点决定了可靠数据传输协议的复杂性。</p><p>在可靠信道上传输：不出错，不丢失</p><p>超时重传机制（解决传错/丢失问题）</p><p>滑动窗口协议（slide window）：发送缓冲区。<br>发送窗口的最大值&lt;=发送缓冲区的值<br>发送窗口前沿移动的极限：不能超过发送缓冲区<br>接收窗口=接收缓冲区<br>GBN（Go-back-N）协议和SR(Selective Repeat)协议的异同：相同：发送窗口&gt;1，一次可发多个未经确认分组。区别：GBN接收窗口尺寸=1，只能顺序接收，一旦一个分组没有发成功，要返回错误的地方重发；SR接收窗口尺寸&gt;1，可乱序接收，发送未成可以选择性重发错的中间某一项。</p><p>GBN适用范围：出错率低（SR复杂易出错）<br>SR适用范围：链路容量大（延迟大，带宽大）<br>GBN:以时间换空间  SR: 以空间换时间</p><h3 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h3><p>（段结构；可靠数据传输；流量控制；连接管理）<br>TCP概述：点对点，可靠的、按顺序的字节流，管道化（流水线），发送和接收缓存，全双工数据，面向连接，有流量控制</p><p>MSS:Maximum Segment Size, 最大报文段大小，≤当然可以</p><p><strong>TCP往返延时（RTT）和超时</strong><br>在局域网中，两台计算机之间的往返延迟可以设置为固定的值；通过TCP处理进程通信的情况，超时时间是动态的、自适应的。<br>sampleRTT 当前采样RTT<br>estimatedRTT 移动平均RTT</p><p>TCP在IP不可靠服务的基础上建立了RTT</p><p>快速重传算法</p><p><strong>流量控制</strong><br>目的：防止发送方发的太快，超出了接收方的处理能力（防止接收方缓冲区溢出）。</p><p><strong>连接管理</strong><br>连接建立 和 连接拆除</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>网络拥塞的表现：分组丢失率变高，延迟更多<br>两种拥塞控制方法：端到端拥塞控制，网络辅助的拥塞控制<br>ATM网络：异步传输网络，它的数据单位是RM（信元）<br>ABR模式：弹性服务</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>如何检测拥塞：超时（拥塞）；收到某个段三个重复的ACK（轻微拥塞，没有发生拥塞，但是由于未通过差错检验，给源端一种发生拥塞的错觉）</p><p>rate=CongWin/RTT<br>两种控制同时考虑：接受窗口反映流量控制，拥塞窗口反映拥塞控制<br>拥塞控制的策略：慢启动（每个RTT，CongWin加倍；一开始慢速，但加速是指数性的）</p><p>拥塞控制的机制：线性增加-层性减-线性增加-层性减…<br>（改进）指数增加-线性增加-线性减-指数增加-线性增加-线性减…</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>传输层提供的服务：为应用进程间的逻辑通信服务（相对的，网络层提供的是主机和主机之间的通信服务），传输层协议包括TCP和UDP</li><li>原理：多路复用和解复用<br>区分进程使用的是：端口</li><li>无连接传输层协议UDP</li><li>可靠数据传输原理：停止等待协议（RDT），流水线协议（GBN：接收窗口=1，SR：接收窗口&gt;1）</li><li>TCP协议：TCP特性，面向连接的，进程到进程的；TCP报文段格式；TCO可靠传输机制；超时重传，快速重传；流量控制；连接管理</li><li>拥塞控制原理：拥塞原因，拥塞代价（方式：网络辅助e.g.ATM - 根据网络提供的反馈信息；端到端e.g.TCP - 超时和三个冗余ACK来判断拥塞）</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/27/LearnNet3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>计算机网络自顶向下（二）——应用层</title>
      <link>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</link>
      <guid>https://pearlchocolatezy.com/2025/01/06/LearnNet2/</guid>
      <pubDate>Mon, 06 Jan 2025 13:19:12 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;h3 id=&quot;提纲&quot;&gt;&lt;a href=&quot;#提纲&quot; class=&quot;headerlink&quot; title=&quot;提纲&quot;&gt;&lt;/a&gt;提纲&lt;/h3&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>目标：原理&amp;实例&amp;编程</p><ol><li>应用层协议原理</li><li>Web and HTTP</li><li>FTP*</li><li>Email<br>（1）SMTP（2）POP3（3）IMAP</li><li>DNS</li><li>P2P应用</li><li>CDN</li><li>TCP套接字（Soclet）编程</li><li>UDP套接字编程</li></ol><h3 id="应用层原理"><a href="#应用层原理" class="headerlink" title="应用层原理"></a>应用层原理</h3><p>网络应用的例子：E-mail，Web，文本消息，远程登录，P2P文件共享，即时通信，多用户网络游戏，流媒体（YouTube,Netflix），Internet电话，实时电视会议，社交网络，搜索……<br>网络应用得到体系结构：客户-服务器模式（C/S），对等模式（P2P），混合体</p><ol><li>客户-服务器（C/S）体系结构<br>服务器：一直运行；固定的IP地址和周知的端口号（约定）；扩展性差；可靠性差（服务器会宕机）。<br>客户端：主动与服务器通信；与互联网有间歇性的连接；可能是动态IP地址；不直接与其它客户端通信。</li><li>对等体（P2P）体系结构<br>（几乎）没有一直运行的服务器；<br>任意端系统之间可以进行通信；<br><font color="purple">每一个节点即是客户端又是服务器</font>，自扩展性；<br>参与的主机间歇性连接且可以改变IP地址（难以管理）。<br>e.g.迅雷</li><li><p>C/S和P2P混合体<br>（1）e.g.Napster</p><blockquote><p>《Napster》是一个真实的案例，是一家音乐分享平台的。它以其革命性的P2P（点对点）文件共享技术引发了音乐行业的巨大变革，但最终因未能应对法律和商业压力而走向失败。如今Napster以经营付费服务为主，而免费的Napster的流行和回响使其在电脑界和娱乐业里成为一个传奇的象征。</p></blockquote><p> 文件搜索：集中<br> 文件传输：P2P<br> （2）即时通信</p></li><li>进程通信<br>进程：在主机上运行的应用程序<br>客户端进程：发起通信的进程<br>服务器进程：等待连接的进程<br>在同一个主机内，使用进程间通信机制通信（由操作系统定义）。<br>不同主机，通过交换报文（message）来通信（使用OS提供的通信服务；借助传输层的服务，按照应用协议交换报文）。<br>P2P架构也有客户端进程和服务器进程之分。</li><li>分布式应用进程需要解决的问题<br>（1）进程标识和寻址问题（服务用户）<br>（2）传输层-应用层怎样提供服务（位置：层间界面的SAP；形式：应用程序接口API）<br>（3）如何使用传输层提供的服务，实现应用进程间的报文交换，实现应用（用户使用服务）（定义应用层协议，编制程序）<br><br><strong>（1）-&gt; 对进程进行编址（addressing）</strong><br>进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）：<br>①每台主机有唯一的32位IP地址，但IP地址无法唯一标识一个进程。<br>②采用的传输层协议：TCP or UDP<br>③端口号（Port Numbers）<br>约定默认端口号：<br>FTP：21<br>Telnet：23<br>HTTP:TCP：80<br>MAIL:TCP：25<br>ftp:TCP：2<br>一个进程：IP+port标示端节点<br>本质上，一对主机进程之间的通信由2个端节点构成。<br>TCP和UDP使用端口的方式不同。<br><strong>（2）-&gt; 传输层提供的服务-需要穿过层间的信息</strong><br>层间接口必须要携带的信息：<br>①要传输的报文（本层SDU）<br>②谁传的：对方的应用进程标示：IP+TCP(UDP)端口<br>③传给谁：对方的应用进程标示：对方的IP+TCP(UDP)端口号<br>传输层实体（TCP or UDP实体）根据这些信息进程TCP报文段（UDP数据报）的封装。<br>如果Socket API每次传输报文，都携带这么多信息（IP+TCP/UDP端口），易出错，不易管理。<br><mark class="hl-label pink">TCP Socket</mark> ：TCP服务，两个进程通信之前需要建立连接（持续一段时间）。<br>可以用一个整数表示两个实体之间的通信关系（本地标示）；穿过层间的信息量最小。<br><font color="purple">TCP Socket是本地IP、本地TCP端口、对方IP、对方TCP端口以及连接状态的一个本地标识，是一个整数。</font>（会话关系的本地标识）<br>Socket是TCP之上的套接字。<font color="purple">4元组</font>，唯一指定一个会话。简单，便于管理。<br>TCP是传数据报和Socket这两样东西。<br><mark class="hl-label pink">UDP Socket</mark> ：UDP服务，两个进程通信前无需建立连接。<br>每条报文独立传输；前后报文可能给不同的分布式进程。因此只能用一个整数表示本应用实体的标示。穿过层间接口的信息量最小。<br><font color="purple">UDP Socket是本地IP、本地端口号的标识。2元组。</font>传输报文时需要提供对方IP、对方端口；接收报文时需要上传对方IP、对方端口。<br>UDP是传数据报、Socket、对方IP、对方端口号这四样东西。<br>套接字Socket像是门（饥荒小木牌）。进程向套接字发送报文或从套接字接收报文。<br><strong>（3.1）-&gt; 如何使用传输层提供的服务实现应用</strong><br>定义应用层协议：报文格式、解释、时序等。<br>编制程序：通过API调用网络基础设施提供通信服务传报文、解析报文、实现应用时序等。<br><mark class="hl-label pink">应用层协议</mark> 定义了运行在不同端系统上的应用进程如何交换报文，规范了报文类型、语法、语义、规则。<br>应用协议是应用的一个组成成分。<br>公开协议：HTTP，SMTP等。由RFC文档定义。<br>私有协议：Skype等。<br><strong>（3.2）-&gt; 应用层需要传输层提供什么样的服务</strong><br>要素：数据丢失率，延迟，吞吐，安全性。</li><li>安全TCP<br>（1）TCP&amp;UDP<br>（2）SSL（Security Socket Layer）：基于TCP提供加密的TCP连接，位于应用层。<br>网站http开头：跑在TCP之上；https开头：跑在SSL over TCP之上。</li></ol><h3 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h3><p>Web网页：由一些对象组成（e.g.HTML文件、图片、Java小程序、mp3文件等）。<br>Web页含有一个基本的HTML文件，该文件包含若干对象的引用（链接）。<br>通过URL对每个对象进行引用，URL包含访问协议，用户名，口令字，端口号等。</p><ol><li>HTTP概况<br>HTTP：超文本传输协议。Web的应用层协议。<br>客户/服务器模式：<br>（1）客户：请求、接收和显示Web对象的浏览器。<br>（2）服务器：对请求进行响应，发送对象的Web服务器。<pre><code> PC/mobile browser-&gt;HTTP request                     HTTP response&lt;-Web server</code></pre>HTTP跑在TCP之上：<br>（1）客户发起与服务器的TCP连接（建立套接字）；<br>（2）服务器接收客户的TCP连接；<br>（3）在浏览器与Web服务器交换HTTP报文；<br>（4）关闭TCP连接。<br>HTTP是无状态的，服务器不维护。<br>服务器刚刚建立的时候，守候在默认的80端口，套接字为Socket1（S1）；一个连接建立起来后得到S2，又一个连接建立后得到S3，原来的S1等待着其它Web浏览器的并发建立连接请求。（S1是waiting socket，特殊socket）<br><strong>非持久HTTP</strong><br>最多只有一个对象在TCP连接上发送；<br>下载多个对象需要多个TCP连接；<br>HTTP/1.0使用非持久连接。<br>三次握手：[连接请求，连接确认，http request]，http response，关闭连接。（上传10个文件就重复操作这五步10次）<br>缺点：每个对象要两个RTT；操作系统必须为每个TCP连接分配资源；浏览器通常打开并行TCP连接以获取引用对象。<br><strong>持久HTTP</strong><br>多个对象可以在一个TCP上传输；<br>HTTP/1.1默认使用持久连接。<br>三次握手基础上不关闭连接。<br>优点：保持连接；反复请求，使用相同连接传送；引用对象可以尽快发送。<br>（1）非流水方式的持久HTTP：客户端收到一个响应才能发送新的请求；每个引用对象花费一个RTT。（串行）<br>（2）流水方式的持久HTTP：HTTP/1.1默认模式；客户端遇到一个引用对象就立刻产生一个请求；有可能所有引用对象只花费一个RTT。（并行，多线程）<br><strong>响应时间模型</strong><br>往返时间RTT：一次往返传播的时间（传播是两主机的距离要有时间，传输是把数据打到电线上要的时间。这里传输时间不计）<br>响应时间：一个RTT用来发起TCP连接，一个RTT用来发送HTTP请求并等待HTTP响应。<br>文件传输时间：2RTT+1个对象传输时间</li><li>HTTP请求报文<br>两种类型：请求，响应<br>格式：ASCII，可读<br>HTTP请求报文：请求行（get,post,head命令） + 首部行（host,user-agent,connection等信息） + 换行回车符（表示结束）<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/1.jpg" width="50%"><br>提交表单输入：post方式（网页通常包括表单输入，包含在实体主体中的输入被提交到服务器），url方式（通过请求行额度url字段上载）<br><code>www.123.com/test?monkeys&amp;banana</code></li><li>HTTP响应报文<br>状态行（协议版本，状态码，状态信息） + 首部行 + 数据（e.g.请求的HTML文件）<br><a href>HTTP响应状态码</a>（待补充）</li><li>用户-服务器状态：cookies<br>四个组成部分：。。。（刷到题再记）</li><li>Web缓存 代理服务器（proxy server）<br>不访问原始服务器，就满足客户请求。<blockquote><p>一类是Gib Mib Kib,代表的是1024进制的计数单位,一类是gb mb kb,代表的是1000进制的计数单位无特殊标注。<br>大部分简写都表示1024进制换算单位，u盘厂商一般是按1000进制换算的，这也是u盘插电脑上显示的内存都会比标注的少的原因。<br>速率按1000，大小按1024。<br>b是bit，B是字节。MBps和Mbps不一样。</p></blockquote></li><li>条件get</li></ol><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h3><p>功能：上传&amp;下载-&gt;文件共享<br>默认端口：21（waiting port）<br>明文传输<br>控制连接（port21，带外传送）&amp;数据连接（port20，带内）<br>FTP特点：控制命令和数据传输分别在两个不同TCP连接上。而HTTP的控制和响应数据在一个连接上。<br>HTTP本身无状态，通过cookies变成有状态协议；FTP是有状态协议。</p><h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><p>协议组成部分：用户代理，邮件服务器，简单邮件传输协议SMTP<br>用户代理：又名“邮件阅读器”，e.g.Foxmail、QQ邮箱，输入和输出邮件保存在服务器。<br>三跳：用户代理发给邮件服务器 -&gt; 邮件服务器发给目标邮件服务器 -&gt; 用户代理POP3存取协议从邮件服务器拉取邮件。(前两跳是推，最后一跳是拉)<br>SMTP协议：使用TCP在客户端和服务器之间传送报文，默认端口号25。传输的三个阶段（握手，传输报文，关闭）。<br>MINE：multimedia mail extension 多媒体邮件扩展。编码和解码。<br>原始的SMTP协议只能传输ASCII字符的邮件，引入MINE扩展后可以传输更多内容。<br>POP3协议：邮件的存取协议。拉邮件。用户确认阶段，事务处理阶段。无状态。本地管理文件夹。<br>IMAP：保留用户状态。远程管理文件夹。<br><img class="zy_img_shadow" src="/2025/01/06/LearnNet2/2.jpg" width="60%"></p><h3 id="DNS（Domain-Name-System）-域名解析系统"><a href="#DNS（Domain-Name-System）-域名解析系统" class="headerlink" title="DNS（Domain Name System） 域名解析系统"></a>DNS（Domain Name System） 域名解析系统</h3><p>不是直接给人用的，是为其它应用服务的，其它应用最终是给人用的。<br>服务：域名（应用层）和IP地址（传输层）的转换。用于Web,ftp等。<br>必要性：IP地址不便记忆，便于通过域名寻址。<br>需要解决的三个问题：分层命名，分布式解析，增加和删除域名（命名，解析，维护）<br>历史：ARPANET解决方案，存在一个维护站，主机数量太大时难以分配<br>DNS的思想：分层命名，分布式数据库（树状关系），运行在UDP之上，核心的Internet功能但以应用层协议实现。<br>核心部分：互连的路由器,网络的网络，为边缘部分提供服务(连通性和数据交换)，核心功能是路由(决定分组采用的到目标的路径)和转发(将分组从路由的输入链路转到输出链路)。互联网很多核心内容在建立在互联网边缘的端系统的应用之上实现的。（应该是核心部分简单稳定却强大，把复杂易错的精细活交给边缘设备）<br>DNS其它目的：别名转换为规范名字；负载均衡。<br>DNS域名结构：层次树状结构（每个树叶代表主机，用dot区分层次）。Internet根被划分为几百个顶级域名，分为通用的（.com, .edu, .gov…）和国家的（.cn, .us…）；顶级域可以分为若干个二级域……<br>全球共13个根名字服务器，可靠。（10个在美国、1个在英国、1个在瑞典、1个在荷兰）<br>域的划分是逻辑的，不是物理的。<br>DNS：保存资源记录（RR）的分布式数据库，RR格式（name,value,type,ttl）。（TTL:生存时间，决定该资源记录从缓存中删除的时间，默认2天）<br>DNS大致工作过程：应用调用解析器；解析器作为客户向Name Server发出查询报文；Name Server返回响应报文。<br>一台设备上网必须具备四个信息：ip地址，子网掩码，默认网关default gateway，local name server(DNS)。（得到Name和IP的对应关系）</p><h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p>（P2P与C/S模式并列）<br>纯P2P架构：几乎没有一直运行的服务器；任意端系统可以直接通信；利用peer的服务能力，peer节点间歇上网，每次IP地址可能有变化。（e.g.Skype, BitTorrent, KanKan）<br>采用C/S方法将一个F大小的文件分发给N个客户端耗时（下限）：</p><script type="math/tex; mode=display">D_{C-S} \geq max\{\dfrac{NF}{u_{s}},\dfrac{F}{d_{min}}\} （随着N线性增长）</script><p>所有用户都从服务器下载。u是服务器上载速率，d是客户端下载速率。总时间与N呈线性增加关系。<br>采用P2P方法讲一个F大小文件分发给N个客户端耗时：</p><script type="math/tex; mode=display">D_{P2P} \geq max\{\dfrac{F}{u_{s}},\dfrac{F}{d_{min}},\dfrac{NF}{u_{s}+\sum{u_{i}}}\}</script><p>所有peer节点（客户端）都可以上载。N越大，时间越长，但相比C/S节省的时间也越多。（斜率变小）<br>随着N的数量增加，请求资源的节点数量在增加，提供服务的节点数量也在增加，可扩充用户数量比C/S多得多。可扩展性好，但难以维护。</p><p>P2P资源共享的两大问题：如何定位所需资源，如何处理对等方的加入与离开；可能的方案：集中，分散，半分散。</p><p><strong>非结构化P2P</strong><br>peer与peer构成了一个覆盖网，构成一条边，是随机的。<br>非结构化P2P：集中式目录，完全分布式，混合体。<br>集中式目录存在的问题：单点故障，性能瓶颈，侵犯版权。（文件传输是分散的，而定位内容是高度集中的）<br>完全分布式例子：查询洪泛：Gnutella：没有中心服务器，许多Gnutella客户端，覆盖网络（图）。（去中心化）<br>Gnutella：对等方加入。X试图与可用对等方列表上的对等方建立TCP连接，X向Y发送一个Ping报文，收到Ping报文的对等方以Pong报文响应，然后它能建立TCP连接。<br>混合体例子：利用不匀称性：KaZaA<br>每个对等方是组长或属于一个组长，对等方与组长间或组长之间存在TCP连接。<br>每个文件有唯一hash值（散列标识码）作为id，一个描述字段用于查询<br>KaZaA实例：BigTorrent：请求，发送文件块。新的Peer节点加入洪流（bitmap），成为吸血鬼，开始白嫖，先下载稀缺块（稀缺优先策略），并且优先向那些为我提供最好服务的节点提供服务，巧妙地将集体利益和个人利益结合在一起。<br><strong>结构化（DHT）P2P</strong><br>peer与peer构成一个有序的overlay，构成一个环/树。<br>结构化P2P维护一个树状或环状有序拓扑，每个节点用ip对应的16字节hash值作为唯一标识。文件也有对应的hash，节点ID与文件是重叠的 文件在哪些节点之上是约定好的，通过有序的节点与节点之间的拓扑，能很快找到内容所在的位置，实现快速内容分发。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>视频流化服务：视频流量占据着互联网的大部分带宽。挑战：规模性，异构性。解决方案：分布式的、应用层面的基础设施。<br>视频：固定速度显示的图像序列。<br>CBR：constant bit rate 以固定速率编码。<br>VBR：variable bit rate 视频编码速率随时间的变化而变化。<br>（画面变化更多的视频比几乎不变的视频丢失帧率更多）<br>AVS：高级视频编码。<br>存储视频的流化服务：缓冲<br>DASH协议：动态自适应流化，基于HTTP。服务器将视频分割成多个块，每个块独立存储，编码于不同码率，告示文件（manifest file）提供不同块的url。客户端先获取告示文件，周期性地测量服务器到客户端的带宽，查询告示文件，一个时刻请求一个块，HTTP头部指定字节范围。（客户端根据带宽、网络能力、播放需求等一边播放一遍决定后续请求哪些块 -&gt; B站）<br>CDN：Content Distribution Networks<br>挑战：服务器如何通过网络向上百万用户同时流化视频内容。<br>方案1：单个大的超级服务中心（缺点：瓶颈链路带宽小导致停顿，单点故障，视频拷贝多效率低，周边网络拥塞）（评价：简单，但不可扩展）<br>方案2：CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务。<br>（1）enter  deep：将CDN服务器深入到许多接入网（优点：距离近，数量多，速度快）（缺点：管理困难）e.g.Akamai<br>（2）bring home：部署在少数（10个左右）关键位置，采用租用线路将服务器簇连接起来。e.g.Limelight<br>在CDN节点中存储内容的多个拷贝，用户从CDN中请求内容。<br>位于应用层，靠主机与主机之间的配合提供服务。<br>Netflix网飞案例：网飞制作内容，上传至亚马逊云端（Amazon Cloud），卖给多个运营商，包括Akamai CDN, Limelight CDN, Level-3 CDN，来加速内部访问。网飞自己维护认证服务器，完成认证后访问网页，网页也在云端，用户可以自己选也可以自动选择最近的运营商缓存节点，从而得到服务。</p><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>作用：通信<br>Socket编程：socket是传输报文应用层和传输层的门，socket api是创建socket的函数。<br>两种传输层服务的socket类型：TCP可靠，UDP不可靠。<br>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户。<br>TCP服务：从一个进程向另一个进程可靠地传输字节流。<br><strong>TCP套接字编程步骤</strong>：<br>（1）服务器首先运行，等待连接建立。创建欢迎socket，和本地端口捆绑，在欢迎socket上阻塞式等待接收用户的连接。<br>（2）客户端主动和服务器建立连接。创建客户端本地套接字（隐式捆绑到本地port），指定服务器进程的IP地址和端口号，与服务器进程连接。<br>（3）当与客户连接请求到来时，服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket，与客户端通信。允许服务器与多个客户端通信，使用源IP和源端口来区分不同的客户。<br>（4）连接API调用有效时，客户端P与服务器建立了TCP连接。建立<br>（原来的welcome socket和本地端口捆绑，connect socket和客户端IP捆绑；<br>连接后，connect socket关闭，welcome socket仍然守候。）<br>从应用进程角度：TCP在客户端和服务器进程之间提供了可靠的字节流（管道）服务。</p><div class="table-container"><table><thead><tr><th>数据结构 socketaddr_in</th><th>IP地址与port跳转关系的数据结构（标识进程的端节点）</th></tr></thead><tbody><tr><td>sin_family</td><td>地址簇，常量，代表用的TCP/IP协议还是IPX协议</td></tr><tr><td>sin_port</td><td>端口号port</td></tr><tr><td>sin_addr</td><td>IP地址</td></tr><tr><td>sin_zero[8]</td><td>对齐</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>数据结构 hostent</th><th></th></tr></thead><tbody><tr><td>*h_name</td><td>主机域名</td></tr><tr><td>**h_aliases</td><td>多个域名别名</td></tr><tr><td>h_length</td><td></td></tr><tr><td>**h_addr_list[i]</td><td>多个IP地址（放到socketaddr_in/sin_addr）</td></tr></tbody></table></div><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>UDP socket<br>客户端与服务器之间没有连接，没有握手。<br>包括信息：我的socket值（本地IP和UDP端口），发送内容，发给谁（对方IP对方端口）。<br>收报文时的两件事：对方发送的内容，对方的端节点。<br>传送的数据可能丢失。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>应用程序体系结构：C/S，PSP，混合。</li><li>应用程序需要的服务器品质描述：可靠性，带宽，延时，安全。</li><li>Internet传输层服务模式：TCP（可靠的、面向连接的服务），UDP（不可靠的数据报）。</li><li>流行的应用层协议：HTTP,FTP,SMTP,POP,IMAP,DNS。</li><li>Socket编程。</li><li>应用层协议报文类型：请求/响应报文：客户端请求信息或服务；服务器以数据、状态码进行响应。</li><li>报文格式：首部（关于数据信息的字段），数据（被交换的信息）。</li><li>一个协议定义了在两个或多个通信实体之间交换报文的格式和次序，以及一条报文传输和接收或其它事件采取的动作。</li></ol>]]></content:encoded>
      
      
      <category domain="https://pearlchocolatezy.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</category>
      
      
      <category domain="https://pearlchocolatezy.com/tags/Net/">Net</category>
      
      
      <comments>https://pearlchocolatezy.com/2025/01/06/LearnNet2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
